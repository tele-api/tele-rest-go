/** 
 * Telegram Bot API - REST API Client
 * The Bot API is an HTTP-based interface created for developers keen on building bots for Telegram. To learn how to create and set up a bot, please consult our Introduction to Bots and Bot FAQ.
 * 
 * ## Metadata
 *    * - **Copyright**: Copyright (c) 2025 Qntx
 *    * - **Author**: ΣX <gitctrlx@gmail.com>
 *    * - **Version**: 9.1.0
 *    * - **Modified**: 2025-07-19T09:30:13.278207440Z[Etc/UTC]
 *    * - **Generator Version**: 7.14.0
 * 
 * <details>
 * <summary><strong>⚠️ Important Disclaimer & Limitation of Liability</strong></summary>
 * <br>
 * > **IMPORTANT**: This software is provided "as is" without any warranties, express or implied, including but not limited
 * > to warranties of merchantability, fitness for a particular purpose, or non-infringement. The developers, contributors,
 * > and licensors (collectively, "Developers") make no representations regarding the accuracy, completeness, or reliability
 * > of this software or its outputs.
 * > 
 * > This client is not intended to provide financial, investment, tax, or legal advice. It facilitates interaction with the
 * > Telegram Bot API service but does not endorse or recommend any financial actions, including the purchase, sale, or holding of
 * > financial instruments (e.g., stocks, bonds, derivatives, cryptocurrencies). Users must consult qualified financial or
 * > legal professionals before making decisions based on this software's outputs.
 * > 
 * > Financial markets are inherently speculative and carry significant risks. Using this software in trading, analysis, or
 * > other financial activities may result in substantial losses, including total loss of capital. The Developers are not
 * > liable for any losses or damages arising from such use. Users assume full responsibility for validating the software's
 * > outputs and ensuring their suitability for intended purposes.
 * > 
 * > This client may rely on third-party data or services (e.g., market feeds, APIs). The Developers do not control or verify
 * > the accuracy of these services and are not liable for any errors, delays, or losses resulting from their use. Users must
 * > comply with third-party terms and conditions.
 * > 
 * > Users are solely responsible for ensuring compliance with all applicable financial, tax, and regulatory requirements in
 * > their jurisdiction. This includes obtaining necessary licenses or approvals for trading or investment activities. The
 * > Developers disclaim liability for any legal consequences arising from non-compliance.
 * > 
 * > To the fullest extent permitted by law, the Developers shall not be liable for any direct, indirect, incidental,
 * > consequential, or punitive damages arising from the use or inability to use this software, including but not limited to
 * > loss of profits, data, or business opportunities.
 * 
 * </details>
 */

package tele_rest

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


type DefaultAPI interface {

	/*
	PostAddStickerToSet addStickerToSet

	Use this method to add a new sticker to a set created by the bot. Emoji sticker sets can have up to 200 stickers. Other sticker sets can have up to 120 stickers. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostAddStickerToSetRequest
	*/
	PostAddStickerToSet(ctx context.Context) ApiPostAddStickerToSetRequest

	// PostAddStickerToSetExecute executes the request
	//  @return AddStickerToSetResponse
	PostAddStickerToSetExecute(r ApiPostAddStickerToSetRequest) (*AddStickerToSetResponse, *http.Response, error)

	/*
	PostAnswerCallbackQuery answerCallbackQuery

	Use this method to send answers to callback queries sent from [inline keyboards](https://core.telegram.org/bots/features#inline-keyboards). The answer will be displayed to the user as a notification at the top of the chat screen or as an alert. On success, *True* is returned.

Alternatively, the user can be redirected to the specified Game URL. For this option to work, you must first create a game for your bot via [@BotFather](https://t.me/botfather) and accept the terms. Otherwise, you may use links like `t.me/your_bot?start=XXXX` that open your bot with a parameter.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostAnswerCallbackQueryRequest
	*/
	PostAnswerCallbackQuery(ctx context.Context) ApiPostAnswerCallbackQueryRequest

	// PostAnswerCallbackQueryExecute executes the request
	//  @return AnswerCallbackQueryResponse
	PostAnswerCallbackQueryExecute(r ApiPostAnswerCallbackQueryRequest) (*AnswerCallbackQueryResponse, *http.Response, error)

	/*
	PostAnswerInlineQuery answerInlineQuery

	Use this method to send answers to an inline query. On success, *True* is returned.  
No more than **50** results per query are allowed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostAnswerInlineQueryRequest
	*/
	PostAnswerInlineQuery(ctx context.Context) ApiPostAnswerInlineQueryRequest

	// PostAnswerInlineQueryExecute executes the request
	//  @return AnswerInlineQueryResponse
	PostAnswerInlineQueryExecute(r ApiPostAnswerInlineQueryRequest) (*AnswerInlineQueryResponse, *http.Response, error)

	/*
	PostAnswerPreCheckoutQuery answerPreCheckoutQuery

	Once the user has confirmed their payment and shipping details, the Bot API sends the final confirmation in the form of an [Update](https://core.telegram.org/bots/api/#update) with the field *pre\_checkout\_query*. Use this method to respond to such pre-checkout queries. On success, *True* is returned. **Note:** The Bot API must receive an answer within 10 seconds after the pre-checkout query was sent.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostAnswerPreCheckoutQueryRequest
	*/
	PostAnswerPreCheckoutQuery(ctx context.Context) ApiPostAnswerPreCheckoutQueryRequest

	// PostAnswerPreCheckoutQueryExecute executes the request
	//  @return AnswerPreCheckoutQueryResponse
	PostAnswerPreCheckoutQueryExecute(r ApiPostAnswerPreCheckoutQueryRequest) (*AnswerPreCheckoutQueryResponse, *http.Response, error)

	/*
	PostAnswerShippingQuery answerShippingQuery

	If you sent an invoice requesting a shipping address and the parameter *is\_flexible* was specified, the Bot API will send an [Update](https://core.telegram.org/bots/api/#update) with a *shipping\_query* field to the bot. Use this method to reply to shipping queries. On success, *True* is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostAnswerShippingQueryRequest
	*/
	PostAnswerShippingQuery(ctx context.Context) ApiPostAnswerShippingQueryRequest

	// PostAnswerShippingQueryExecute executes the request
	//  @return AnswerShippingQueryResponse
	PostAnswerShippingQueryExecute(r ApiPostAnswerShippingQueryRequest) (*AnswerShippingQueryResponse, *http.Response, error)

	/*
	PostAnswerWebAppQuery answerWebAppQuery

	Use this method to set the result of an interaction with a [Web App](https://core.telegram.org/bots/webapps) and send a corresponding message on behalf of the user to the chat from which the query originated. On success, a [SentWebAppMessage](https://core.telegram.org/bots/api/#sentwebappmessage) object is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostAnswerWebAppQueryRequest
	*/
	PostAnswerWebAppQuery(ctx context.Context) ApiPostAnswerWebAppQueryRequest

	// PostAnswerWebAppQueryExecute executes the request
	//  @return AnswerWebAppQueryResponse
	PostAnswerWebAppQueryExecute(r ApiPostAnswerWebAppQueryRequest) (*AnswerWebAppQueryResponse, *http.Response, error)

	/*
	PostApproveChatJoinRequest approveChatJoinRequest

	Use this method to approve a chat join request. The bot must be an administrator in the chat for this to work and must have the *can\_invite\_users* administrator right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostApproveChatJoinRequestRequest
	*/
	PostApproveChatJoinRequest(ctx context.Context) ApiPostApproveChatJoinRequestRequest

	// PostApproveChatJoinRequestExecute executes the request
	//  @return ApproveChatJoinRequestResponse
	PostApproveChatJoinRequestExecute(r ApiPostApproveChatJoinRequestRequest) (*ApproveChatJoinRequestResponse, *http.Response, error)

	/*
	PostBanChatMember banChatMember

	Use this method to ban a user in a group, a supergroup or a channel. In the case of supergroups and channels, the user will not be able to return to the chat on their own using invite links, etc., unless [unbanned](https://core.telegram.org/bots/api/#unbanchatmember) first. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostBanChatMemberRequest
	*/
	PostBanChatMember(ctx context.Context) ApiPostBanChatMemberRequest

	// PostBanChatMemberExecute executes the request
	//  @return BanChatMemberResponse
	PostBanChatMemberExecute(r ApiPostBanChatMemberRequest) (*BanChatMemberResponse, *http.Response, error)

	/*
	PostBanChatSenderChat banChatSenderChat

	Use this method to ban a channel chat in a supergroup or a channel. Until the chat is [unbanned](https://core.telegram.org/bots/api/#unbanchatsenderchat), the owner of the banned chat won't be able to send messages on behalf of **any of their channels**. The bot must be an administrator in the supergroup or channel for this to work and must have the appropriate administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostBanChatSenderChatRequest
	*/
	PostBanChatSenderChat(ctx context.Context) ApiPostBanChatSenderChatRequest

	// PostBanChatSenderChatExecute executes the request
	//  @return BanChatSenderChatResponse
	PostBanChatSenderChatExecute(r ApiPostBanChatSenderChatRequest) (*BanChatSenderChatResponse, *http.Response, error)

	/*
	PostClose close

	Use this method to close the bot instance before moving it from one local server to another. You need to delete the webhook before calling this method to ensure that the bot isn't launched again after server restart. The method will return error 429 in the first 10 minutes after the bot is launched. Returns *True* on success. Requires no parameters.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostCloseRequest
	*/
	PostClose(ctx context.Context) ApiPostCloseRequest

	// PostCloseExecute executes the request
	//  @return CloseResponse
	PostCloseExecute(r ApiPostCloseRequest) (*CloseResponse, *http.Response, error)

	/*
	PostCloseForumTopic closeForumTopic

	Use this method to close an open topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights, unless it is the creator of the topic. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostCloseForumTopicRequest
	*/
	PostCloseForumTopic(ctx context.Context) ApiPostCloseForumTopicRequest

	// PostCloseForumTopicExecute executes the request
	//  @return CloseForumTopicResponse
	PostCloseForumTopicExecute(r ApiPostCloseForumTopicRequest) (*CloseForumTopicResponse, *http.Response, error)

	/*
	PostCloseGeneralForumTopic closeGeneralForumTopic

	Use this method to close an open 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostCloseGeneralForumTopicRequest
	*/
	PostCloseGeneralForumTopic(ctx context.Context) ApiPostCloseGeneralForumTopicRequest

	// PostCloseGeneralForumTopicExecute executes the request
	//  @return CloseGeneralForumTopicResponse
	PostCloseGeneralForumTopicExecute(r ApiPostCloseGeneralForumTopicRequest) (*CloseGeneralForumTopicResponse, *http.Response, error)

	/*
	PostConvertGiftToStars convertGiftToStars

	Converts a given regular gift to Telegram Stars. Requires the *can\_convert\_gifts\_to\_stars* business bot right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostConvertGiftToStarsRequest
	*/
	PostConvertGiftToStars(ctx context.Context) ApiPostConvertGiftToStarsRequest

	// PostConvertGiftToStarsExecute executes the request
	//  @return ConvertGiftToStarsResponse
	PostConvertGiftToStarsExecute(r ApiPostConvertGiftToStarsRequest) (*ConvertGiftToStarsResponse, *http.Response, error)

	/*
	PostCopyMessage copyMessage

	Use this method to copy messages of any kind. Service messages, paid media messages, giveaway messages, giveaway winners messages, and invoice messages can't be copied. A quiz [poll](https://core.telegram.org/bots/api/#poll) can be copied only if the value of the field *correct\_option\_id* is known to the bot. The method is analogous to the method [forwardMessage](https://core.telegram.org/bots/api/#forwardmessage), but the copied message doesn't have a link to the original message. Returns the [MessageId](https://core.telegram.org/bots/api/#messageid) of the sent message on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostCopyMessageRequest
	*/
	PostCopyMessage(ctx context.Context) ApiPostCopyMessageRequest

	// PostCopyMessageExecute executes the request
	//  @return CopyMessageResponse
	PostCopyMessageExecute(r ApiPostCopyMessageRequest) (*CopyMessageResponse, *http.Response, error)

	/*
	PostCopyMessages copyMessages

	Use this method to copy messages of any kind. If some of the specified messages can't be found or copied, they are skipped. Service messages, paid media messages, giveaway messages, giveaway winners messages, and invoice messages can't be copied. A quiz [poll](https://core.telegram.org/bots/api/#poll) can be copied only if the value of the field *correct\_option\_id* is known to the bot. The method is analogous to the method [forwardMessages](https://core.telegram.org/bots/api/#forwardmessages), but the copied messages don't have a link to the original message. Album grouping is kept for copied messages. On success, an array of [MessageId](https://core.telegram.org/bots/api/#messageid) of the sent messages is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostCopyMessagesRequest
	*/
	PostCopyMessages(ctx context.Context) ApiPostCopyMessagesRequest

	// PostCopyMessagesExecute executes the request
	//  @return CopyMessagesResponse
	PostCopyMessagesExecute(r ApiPostCopyMessagesRequest) (*CopyMessagesResponse, *http.Response, error)

	/*
	PostCreateChatInviteLink createChatInviteLink

	Use this method to create an additional invite link for a chat. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. The link can be revoked using the method [revokeChatInviteLink](https://core.telegram.org/bots/api/#revokechatinvitelink). Returns the new invite link as [ChatInviteLink](https://core.telegram.org/bots/api/#chatinvitelink) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostCreateChatInviteLinkRequest
	*/
	PostCreateChatInviteLink(ctx context.Context) ApiPostCreateChatInviteLinkRequest

	// PostCreateChatInviteLinkExecute executes the request
	//  @return CreateChatInviteLinkResponse
	PostCreateChatInviteLinkExecute(r ApiPostCreateChatInviteLinkRequest) (*CreateChatInviteLinkResponse, *http.Response, error)

	/*
	PostCreateChatSubscriptionInviteLink createChatSubscriptionInviteLink

	Use this method to create a [subscription invite link](https://telegram.org/blog/superchannels-star-reactions-subscriptions#star-subscriptions) for a channel chat. The bot must have the *can\_invite\_users* administrator rights. The link can be edited using the method [editChatSubscriptionInviteLink](https://core.telegram.org/bots/api/#editchatsubscriptioninvitelink) or revoked using the method [revokeChatInviteLink](https://core.telegram.org/bots/api/#revokechatinvitelink). Returns the new invite link as a [ChatInviteLink](https://core.telegram.org/bots/api/#chatinvitelink) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostCreateChatSubscriptionInviteLinkRequest
	*/
	PostCreateChatSubscriptionInviteLink(ctx context.Context) ApiPostCreateChatSubscriptionInviteLinkRequest

	// PostCreateChatSubscriptionInviteLinkExecute executes the request
	//  @return CreateChatSubscriptionInviteLinkResponse
	PostCreateChatSubscriptionInviteLinkExecute(r ApiPostCreateChatSubscriptionInviteLinkRequest) (*CreateChatSubscriptionInviteLinkResponse, *http.Response, error)

	/*
	PostCreateForumTopic createForumTopic

	Use this method to create a topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. Returns information about the created topic as a [ForumTopic](https://core.telegram.org/bots/api/#forumtopic) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostCreateForumTopicRequest
	*/
	PostCreateForumTopic(ctx context.Context) ApiPostCreateForumTopicRequest

	// PostCreateForumTopicExecute executes the request
	//  @return CreateForumTopicResponse
	PostCreateForumTopicExecute(r ApiPostCreateForumTopicRequest) (*CreateForumTopicResponse, *http.Response, error)

	/*
	PostCreateInvoiceLink createInvoiceLink

	Use this method to create a link for an invoice. Returns the created invoice link as *String* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostCreateInvoiceLinkRequest
	*/
	PostCreateInvoiceLink(ctx context.Context) ApiPostCreateInvoiceLinkRequest

	// PostCreateInvoiceLinkExecute executes the request
	//  @return CreateInvoiceLinkResponse
	PostCreateInvoiceLinkExecute(r ApiPostCreateInvoiceLinkRequest) (*CreateInvoiceLinkResponse, *http.Response, error)

	/*
	PostCreateNewStickerSet createNewStickerSet

	Use this method to create a new sticker set owned by a user. The bot will be able to edit the sticker set thus created. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostCreateNewStickerSetRequest
	*/
	PostCreateNewStickerSet(ctx context.Context) ApiPostCreateNewStickerSetRequest

	// PostCreateNewStickerSetExecute executes the request
	//  @return CreateNewStickerSetResponse
	PostCreateNewStickerSetExecute(r ApiPostCreateNewStickerSetRequest) (*CreateNewStickerSetResponse, *http.Response, error)

	/*
	PostDeclineChatJoinRequest declineChatJoinRequest

	Use this method to decline a chat join request. The bot must be an administrator in the chat for this to work and must have the *can\_invite\_users* administrator right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostDeclineChatJoinRequestRequest
	*/
	PostDeclineChatJoinRequest(ctx context.Context) ApiPostDeclineChatJoinRequestRequest

	// PostDeclineChatJoinRequestExecute executes the request
	//  @return DeclineChatJoinRequestResponse
	PostDeclineChatJoinRequestExecute(r ApiPostDeclineChatJoinRequestRequest) (*DeclineChatJoinRequestResponse, *http.Response, error)

	/*
	PostDeleteBusinessMessages deleteBusinessMessages

	Delete messages on behalf of a business account. Requires the *can\_delete\_sent\_messages* business bot right to delete messages sent by the bot itself, or the *can\_delete\_all\_messages* business bot right to delete any message. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostDeleteBusinessMessagesRequest
	*/
	PostDeleteBusinessMessages(ctx context.Context) ApiPostDeleteBusinessMessagesRequest

	// PostDeleteBusinessMessagesExecute executes the request
	//  @return DeleteBusinessMessagesResponse
	PostDeleteBusinessMessagesExecute(r ApiPostDeleteBusinessMessagesRequest) (*DeleteBusinessMessagesResponse, *http.Response, error)

	/*
	PostDeleteChatPhoto deleteChatPhoto

	Use this method to delete a chat photo. Photos can't be changed for private chats. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostDeleteChatPhotoRequest
	*/
	PostDeleteChatPhoto(ctx context.Context) ApiPostDeleteChatPhotoRequest

	// PostDeleteChatPhotoExecute executes the request
	//  @return DeleteChatPhotoResponse
	PostDeleteChatPhotoExecute(r ApiPostDeleteChatPhotoRequest) (*DeleteChatPhotoResponse, *http.Response, error)

	/*
	PostDeleteChatStickerSet deleteChatStickerSet

	Use this method to delete a group sticker set from a supergroup. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Use the field *can\_set\_sticker\_set* optionally returned in [getChat](https://core.telegram.org/bots/api/#getchat) requests to check if the bot can use this method. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostDeleteChatStickerSetRequest
	*/
	PostDeleteChatStickerSet(ctx context.Context) ApiPostDeleteChatStickerSetRequest

	// PostDeleteChatStickerSetExecute executes the request
	//  @return DeleteChatStickerSetResponse
	PostDeleteChatStickerSetExecute(r ApiPostDeleteChatStickerSetRequest) (*DeleteChatStickerSetResponse, *http.Response, error)

	/*
	PostDeleteForumTopic deleteForumTopic

	Use this method to delete a forum topic along with all its messages in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_delete\_messages* administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostDeleteForumTopicRequest
	*/
	PostDeleteForumTopic(ctx context.Context) ApiPostDeleteForumTopicRequest

	// PostDeleteForumTopicExecute executes the request
	//  @return DeleteForumTopicResponse
	PostDeleteForumTopicExecute(r ApiPostDeleteForumTopicRequest) (*DeleteForumTopicResponse, *http.Response, error)

	/*
	PostDeleteMessage deleteMessage

	Use this method to delete a message, including service messages, with the following limitations:  
\- A message can only be deleted if it was sent less than 48 hours ago.  
\- Service messages about a supergroup, channel, or forum topic creation can't be deleted.  
\- A dice message in a private chat can only be deleted if it was sent more than 24 hours ago.  
\- Bots can delete outgoing messages in private chats, groups, and supergroups.  
\- Bots can delete incoming messages in private chats.  
\- Bots granted *can\_post\_messages* permissions can delete outgoing messages in channels.  
\- If the bot is an administrator of a group, it can delete any message there.  
\- If the bot has *can\_delete\_messages* permission in a supergroup or a channel, it can delete any message there.  
Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostDeleteMessageRequest
	*/
	PostDeleteMessage(ctx context.Context) ApiPostDeleteMessageRequest

	// PostDeleteMessageExecute executes the request
	//  @return DeleteMessageResponse
	PostDeleteMessageExecute(r ApiPostDeleteMessageRequest) (*DeleteMessageResponse, *http.Response, error)

	/*
	PostDeleteMessages deleteMessages

	Use this method to delete multiple messages simultaneously. If some of the specified messages can't be found, they are skipped. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostDeleteMessagesRequest
	*/
	PostDeleteMessages(ctx context.Context) ApiPostDeleteMessagesRequest

	// PostDeleteMessagesExecute executes the request
	//  @return DeleteMessagesResponse
	PostDeleteMessagesExecute(r ApiPostDeleteMessagesRequest) (*DeleteMessagesResponse, *http.Response, error)

	/*
	PostDeleteMyCommands deleteMyCommands

	Use this method to delete the list of the bot's commands for the given scope and user language. After deletion, [higher level commands](https://core.telegram.org/bots/api/#determining-list-of-commands) will be shown to affected users. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostDeleteMyCommandsRequest
	*/
	PostDeleteMyCommands(ctx context.Context) ApiPostDeleteMyCommandsRequest

	// PostDeleteMyCommandsExecute executes the request
	//  @return DeleteMyCommandsResponse
	PostDeleteMyCommandsExecute(r ApiPostDeleteMyCommandsRequest) (*DeleteMyCommandsResponse, *http.Response, error)

	/*
	PostDeleteStickerFromSet deleteStickerFromSet

	Use this method to delete a sticker from a set created by the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostDeleteStickerFromSetRequest
	*/
	PostDeleteStickerFromSet(ctx context.Context) ApiPostDeleteStickerFromSetRequest

	// PostDeleteStickerFromSetExecute executes the request
	//  @return DeleteStickerFromSetResponse
	PostDeleteStickerFromSetExecute(r ApiPostDeleteStickerFromSetRequest) (*DeleteStickerFromSetResponse, *http.Response, error)

	/*
	PostDeleteStickerSet deleteStickerSet

	Use this method to delete a sticker set that was created by the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostDeleteStickerSetRequest
	*/
	PostDeleteStickerSet(ctx context.Context) ApiPostDeleteStickerSetRequest

	// PostDeleteStickerSetExecute executes the request
	//  @return DeleteStickerSetResponse
	PostDeleteStickerSetExecute(r ApiPostDeleteStickerSetRequest) (*DeleteStickerSetResponse, *http.Response, error)

	/*
	PostDeleteStory deleteStory

	Deletes a story previously posted by the bot on behalf of a managed business account. Requires the *can\_manage\_stories* business bot right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostDeleteStoryRequest
	*/
	PostDeleteStory(ctx context.Context) ApiPostDeleteStoryRequest

	// PostDeleteStoryExecute executes the request
	//  @return DeleteStoryResponse
	PostDeleteStoryExecute(r ApiPostDeleteStoryRequest) (*DeleteStoryResponse, *http.Response, error)

	/*
	PostDeleteWebhook deleteWebhook

	Use this method to remove webhook integration if you decide to switch back to [getUpdates](https://core.telegram.org/bots/api/#getupdates). Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostDeleteWebhookRequest
	*/
	PostDeleteWebhook(ctx context.Context) ApiPostDeleteWebhookRequest

	// PostDeleteWebhookExecute executes the request
	//  @return DeleteWebhookResponse
	PostDeleteWebhookExecute(r ApiPostDeleteWebhookRequest) (*DeleteWebhookResponse, *http.Response, error)

	/*
	PostEditChatInviteLink editChatInviteLink

	Use this method to edit a non-primary invite link created by the bot. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns the edited invite link as a [ChatInviteLink](https://core.telegram.org/bots/api/#chatinvitelink) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostEditChatInviteLinkRequest
	*/
	PostEditChatInviteLink(ctx context.Context) ApiPostEditChatInviteLinkRequest

	// PostEditChatInviteLinkExecute executes the request
	//  @return EditChatInviteLinkResponse
	PostEditChatInviteLinkExecute(r ApiPostEditChatInviteLinkRequest) (*EditChatInviteLinkResponse, *http.Response, error)

	/*
	PostEditChatSubscriptionInviteLink editChatSubscriptionInviteLink

	Use this method to edit a subscription invite link created by the bot. The bot must have the *can\_invite\_users* administrator rights. Returns the edited invite link as a [ChatInviteLink](https://core.telegram.org/bots/api/#chatinvitelink) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostEditChatSubscriptionInviteLinkRequest
	*/
	PostEditChatSubscriptionInviteLink(ctx context.Context) ApiPostEditChatSubscriptionInviteLinkRequest

	// PostEditChatSubscriptionInviteLinkExecute executes the request
	//  @return EditChatSubscriptionInviteLinkResponse
	PostEditChatSubscriptionInviteLinkExecute(r ApiPostEditChatSubscriptionInviteLinkRequest) (*EditChatSubscriptionInviteLinkResponse, *http.Response, error)

	/*
	PostEditForumTopic editForumTopic

	Use this method to edit name and icon of a topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights, unless it is the creator of the topic. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostEditForumTopicRequest
	*/
	PostEditForumTopic(ctx context.Context) ApiPostEditForumTopicRequest

	// PostEditForumTopicExecute executes the request
	//  @return EditForumTopicResponse
	PostEditForumTopicExecute(r ApiPostEditForumTopicRequest) (*EditForumTopicResponse, *http.Response, error)

	/*
	PostEditGeneralForumTopic editGeneralForumTopic

	Use this method to edit the name of the 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostEditGeneralForumTopicRequest
	*/
	PostEditGeneralForumTopic(ctx context.Context) ApiPostEditGeneralForumTopicRequest

	// PostEditGeneralForumTopicExecute executes the request
	//  @return EditGeneralForumTopicResponse
	PostEditGeneralForumTopicExecute(r ApiPostEditGeneralForumTopicRequest) (*EditGeneralForumTopicResponse, *http.Response, error)

	/*
	PostEditMessageCaption editMessageCaption

	Use this method to edit captions of messages. On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned. Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within **48 hours** from the time they were sent.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostEditMessageCaptionRequest
	*/
	PostEditMessageCaption(ctx context.Context) ApiPostEditMessageCaptionRequest

	// PostEditMessageCaptionExecute executes the request
	//  @return EditMessageCaptionResponse
	PostEditMessageCaptionExecute(r ApiPostEditMessageCaptionRequest) (*EditMessageCaptionResponse, *http.Response, error)

	/*
	PostEditMessageChecklist editMessageChecklist

	Use this method to edit a checklist on behalf of a connected business account. On success, the edited [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostEditMessageChecklistRequest
	*/
	PostEditMessageChecklist(ctx context.Context) ApiPostEditMessageChecklistRequest

	// PostEditMessageChecklistExecute executes the request
	//  @return EditMessageChecklistResponse
	PostEditMessageChecklistExecute(r ApiPostEditMessageChecklistRequest) (*EditMessageChecklistResponse, *http.Response, error)

	/*
	PostEditMessageLiveLocation editMessageLiveLocation

	Use this method to edit live location messages. A location can be edited until its *live\_period* expires or editing is explicitly disabled by a call to [stopMessageLiveLocation](https://core.telegram.org/bots/api/#stopmessagelivelocation). On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostEditMessageLiveLocationRequest
	*/
	PostEditMessageLiveLocation(ctx context.Context) ApiPostEditMessageLiveLocationRequest

	// PostEditMessageLiveLocationExecute executes the request
	//  @return EditMessageLiveLocationResponse
	PostEditMessageLiveLocationExecute(r ApiPostEditMessageLiveLocationRequest) (*EditMessageLiveLocationResponse, *http.Response, error)

	/*
	PostEditMessageMedia editMessageMedia

	Use this method to edit animation, audio, document, photo, or video messages, or to add media to text messages. If a message is part of a message album, then it can be edited only to an audio for audio albums, only to a document for document albums and to a photo or a video otherwise. When an inline message is edited, a new file can't be uploaded; use a previously uploaded file via its file\_id or specify a URL. On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned. Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within **48 hours** from the time they were sent.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostEditMessageMediaRequest
	*/
	PostEditMessageMedia(ctx context.Context) ApiPostEditMessageMediaRequest

	// PostEditMessageMediaExecute executes the request
	//  @return EditMessageMediaResponse
	PostEditMessageMediaExecute(r ApiPostEditMessageMediaRequest) (*EditMessageMediaResponse, *http.Response, error)

	/*
	PostEditMessageReplyMarkup editMessageReplyMarkup

	Use this method to edit only the reply markup of messages. On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned. Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within **48 hours** from the time they were sent.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostEditMessageReplyMarkupRequest
	*/
	PostEditMessageReplyMarkup(ctx context.Context) ApiPostEditMessageReplyMarkupRequest

	// PostEditMessageReplyMarkupExecute executes the request
	//  @return EditMessageReplyMarkupResponse
	PostEditMessageReplyMarkupExecute(r ApiPostEditMessageReplyMarkupRequest) (*EditMessageReplyMarkupResponse, *http.Response, error)

	/*
	PostEditMessageText editMessageText

	Use this method to edit text and [game](https://core.telegram.org/bots/api/#games) messages. On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned. Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within **48 hours** from the time they were sent.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostEditMessageTextRequest
	*/
	PostEditMessageText(ctx context.Context) ApiPostEditMessageTextRequest

	// PostEditMessageTextExecute executes the request
	//  @return EditMessageTextResponse
	PostEditMessageTextExecute(r ApiPostEditMessageTextRequest) (*EditMessageTextResponse, *http.Response, error)

	/*
	PostEditStory editStory

	Edits a story previously posted by the bot on behalf of a managed business account. Requires the *can\_manage\_stories* business bot right. Returns [Story](https://core.telegram.org/bots/api/#story) on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostEditStoryRequest
	*/
	PostEditStory(ctx context.Context) ApiPostEditStoryRequest

	// PostEditStoryExecute executes the request
	//  @return EditStoryResponse
	PostEditStoryExecute(r ApiPostEditStoryRequest) (*EditStoryResponse, *http.Response, error)

	/*
	PostEditUserStarSubscription editUserStarSubscription

	Allows the bot to cancel or re-enable extension of a subscription paid in Telegram Stars. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostEditUserStarSubscriptionRequest
	*/
	PostEditUserStarSubscription(ctx context.Context) ApiPostEditUserStarSubscriptionRequest

	// PostEditUserStarSubscriptionExecute executes the request
	//  @return EditUserStarSubscriptionResponse
	PostEditUserStarSubscriptionExecute(r ApiPostEditUserStarSubscriptionRequest) (*EditUserStarSubscriptionResponse, *http.Response, error)

	/*
	PostExportChatInviteLink exportChatInviteLink

	Use this method to generate a new primary invite link for a chat; any previously generated primary link is revoked. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns the new invite link as *String* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostExportChatInviteLinkRequest
	*/
	PostExportChatInviteLink(ctx context.Context) ApiPostExportChatInviteLinkRequest

	// PostExportChatInviteLinkExecute executes the request
	//  @return ExportChatInviteLinkResponse
	PostExportChatInviteLinkExecute(r ApiPostExportChatInviteLinkRequest) (*ExportChatInviteLinkResponse, *http.Response, error)

	/*
	PostForwardMessage forwardMessage

	Use this method to forward messages of any kind. Service messages and messages with protected content can't be forwarded. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostForwardMessageRequest
	*/
	PostForwardMessage(ctx context.Context) ApiPostForwardMessageRequest

	// PostForwardMessageExecute executes the request
	//  @return ForwardMessageResponse
	PostForwardMessageExecute(r ApiPostForwardMessageRequest) (*ForwardMessageResponse, *http.Response, error)

	/*
	PostForwardMessages forwardMessages

	Use this method to forward multiple messages of any kind. If some of the specified messages can't be found or forwarded, they are skipped. Service messages and messages with protected content can't be forwarded. Album grouping is kept for forwarded messages. On success, an array of [MessageId](https://core.telegram.org/bots/api/#messageid) of the sent messages is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostForwardMessagesRequest
	*/
	PostForwardMessages(ctx context.Context) ApiPostForwardMessagesRequest

	// PostForwardMessagesExecute executes the request
	//  @return ForwardMessagesResponse
	PostForwardMessagesExecute(r ApiPostForwardMessagesRequest) (*ForwardMessagesResponse, *http.Response, error)

	/*
	PostGetAvailableGifts getAvailableGifts

	Returns the list of gifts that can be sent by the bot to users and channel chats. Requires no parameters. Returns a [Gifts](https://core.telegram.org/bots/api/#gifts) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetAvailableGiftsRequest
	*/
	PostGetAvailableGifts(ctx context.Context) ApiPostGetAvailableGiftsRequest

	// PostGetAvailableGiftsExecute executes the request
	//  @return GetAvailableGiftsResponse
	PostGetAvailableGiftsExecute(r ApiPostGetAvailableGiftsRequest) (*GetAvailableGiftsResponse, *http.Response, error)

	/*
	PostGetBusinessAccountGifts getBusinessAccountGifts

	Returns the gifts received and owned by a managed business account. Requires the *can\_view\_gifts\_and\_stars* business bot right. Returns [OwnedGifts](https://core.telegram.org/bots/api/#ownedgifts) on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetBusinessAccountGiftsRequest
	*/
	PostGetBusinessAccountGifts(ctx context.Context) ApiPostGetBusinessAccountGiftsRequest

	// PostGetBusinessAccountGiftsExecute executes the request
	//  @return GetBusinessAccountGiftsResponse
	PostGetBusinessAccountGiftsExecute(r ApiPostGetBusinessAccountGiftsRequest) (*GetBusinessAccountGiftsResponse, *http.Response, error)

	/*
	PostGetBusinessAccountStarBalance getBusinessAccountStarBalance

	Returns the amount of Telegram Stars owned by a managed business account. Requires the *can\_view\_gifts\_and\_stars* business bot right. Returns [StarAmount](https://core.telegram.org/bots/api/#staramount) on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetBusinessAccountStarBalanceRequest
	*/
	PostGetBusinessAccountStarBalance(ctx context.Context) ApiPostGetBusinessAccountStarBalanceRequest

	// PostGetBusinessAccountStarBalanceExecute executes the request
	//  @return GetBusinessAccountStarBalanceResponse
	PostGetBusinessAccountStarBalanceExecute(r ApiPostGetBusinessAccountStarBalanceRequest) (*GetBusinessAccountStarBalanceResponse, *http.Response, error)

	/*
	PostGetBusinessConnection getBusinessConnection

	Use this method to get information about the connection of the bot with a business account. Returns a [BusinessConnection](https://core.telegram.org/bots/api/#businessconnection) object on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetBusinessConnectionRequest
	*/
	PostGetBusinessConnection(ctx context.Context) ApiPostGetBusinessConnectionRequest

	// PostGetBusinessConnectionExecute executes the request
	//  @return GetBusinessConnectionResponse
	PostGetBusinessConnectionExecute(r ApiPostGetBusinessConnectionRequest) (*GetBusinessConnectionResponse, *http.Response, error)

	/*
	PostGetChat getChat

	Use this method to get up-to-date information about the chat. Returns a [ChatFullInfo](https://core.telegram.org/bots/api/#chatfullinfo) object on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetChatRequest
	*/
	PostGetChat(ctx context.Context) ApiPostGetChatRequest

	// PostGetChatExecute executes the request
	//  @return GetChatResponse
	PostGetChatExecute(r ApiPostGetChatRequest) (*GetChatResponse, *http.Response, error)

	/*
	PostGetChatAdministrators getChatAdministrators

	Use this method to get a list of administrators in a chat, which aren't bots. Returns an Array of [ChatMember](https://core.telegram.org/bots/api/#chatmember) objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetChatAdministratorsRequest
	*/
	PostGetChatAdministrators(ctx context.Context) ApiPostGetChatAdministratorsRequest

	// PostGetChatAdministratorsExecute executes the request
	//  @return GetChatAdministratorsResponse
	PostGetChatAdministratorsExecute(r ApiPostGetChatAdministratorsRequest) (*GetChatAdministratorsResponse, *http.Response, error)

	/*
	PostGetChatMember getChatMember

	Use this method to get information about a member of a chat. The method is only guaranteed to work for other users if the bot is an administrator in the chat. Returns a [ChatMember](https://core.telegram.org/bots/api/#chatmember) object on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetChatMemberRequest
	*/
	PostGetChatMember(ctx context.Context) ApiPostGetChatMemberRequest

	// PostGetChatMemberExecute executes the request
	//  @return GetChatMemberResponse
	PostGetChatMemberExecute(r ApiPostGetChatMemberRequest) (*GetChatMemberResponse, *http.Response, error)

	/*
	PostGetChatMemberCount getChatMemberCount

	Use this method to get the number of members in a chat. Returns *Int* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetChatMemberCountRequest
	*/
	PostGetChatMemberCount(ctx context.Context) ApiPostGetChatMemberCountRequest

	// PostGetChatMemberCountExecute executes the request
	//  @return GetChatMemberCountResponse
	PostGetChatMemberCountExecute(r ApiPostGetChatMemberCountRequest) (*GetChatMemberCountResponse, *http.Response, error)

	/*
	PostGetChatMenuButton getChatMenuButton

	Use this method to get the current value of the bot's menu button in a private chat, or the default menu button. Returns [MenuButton](https://core.telegram.org/bots/api/#menubutton) on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetChatMenuButtonRequest
	*/
	PostGetChatMenuButton(ctx context.Context) ApiPostGetChatMenuButtonRequest

	// PostGetChatMenuButtonExecute executes the request
	//  @return GetChatMenuButtonResponse
	PostGetChatMenuButtonExecute(r ApiPostGetChatMenuButtonRequest) (*GetChatMenuButtonResponse, *http.Response, error)

	/*
	PostGetCustomEmojiStickers getCustomEmojiStickers

	Use this method to get information about custom emoji stickers by their identifiers. Returns an Array of [Sticker](https://core.telegram.org/bots/api/#sticker) objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetCustomEmojiStickersRequest
	*/
	PostGetCustomEmojiStickers(ctx context.Context) ApiPostGetCustomEmojiStickersRequest

	// PostGetCustomEmojiStickersExecute executes the request
	//  @return GetCustomEmojiStickersResponse
	PostGetCustomEmojiStickersExecute(r ApiPostGetCustomEmojiStickersRequest) (*GetCustomEmojiStickersResponse, *http.Response, error)

	/*
	PostGetFile getFile

	Use this method to get basic information about a file and prepare it for downloading. For the moment, bots can download files of up to 20MB in size. On success, a [File](https://core.telegram.org/bots/api/#file) object is returned. The file can then be downloaded via the link `https://api.telegram.org/file/bot<token>/<file_path>`, where `<file_path>` is taken from the response. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling [getFile](https://core.telegram.org/bots/api/#getfile) again.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetFileRequest
	*/
	PostGetFile(ctx context.Context) ApiPostGetFileRequest

	// PostGetFileExecute executes the request
	//  @return GetFileResponse
	PostGetFileExecute(r ApiPostGetFileRequest) (*GetFileResponse, *http.Response, error)

	/*
	PostGetForumTopicIconStickers getForumTopicIconStickers

	Use this method to get custom emoji stickers, which can be used as a forum topic icon by any user. Requires no parameters. Returns an Array of [Sticker](https://core.telegram.org/bots/api/#sticker) objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetForumTopicIconStickersRequest
	*/
	PostGetForumTopicIconStickers(ctx context.Context) ApiPostGetForumTopicIconStickersRequest

	// PostGetForumTopicIconStickersExecute executes the request
	//  @return GetForumTopicIconStickersResponse
	PostGetForumTopicIconStickersExecute(r ApiPostGetForumTopicIconStickersRequest) (*GetForumTopicIconStickersResponse, *http.Response, error)

	/*
	PostGetGameHighScores getGameHighScores

	Use this method to get data for high score tables. Will return the score of the specified user and several of their neighbors in a game. Returns an Array of [GameHighScore](https://core.telegram.org/bots/api/#gamehighscore) objects.

This method will currently return scores for the target user, plus two of their closest neighbors on each side. Will also return the top three users if the user and their neighbors are not among them. Please note that this behavior is subject to change.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetGameHighScoresRequest
	*/
	PostGetGameHighScores(ctx context.Context) ApiPostGetGameHighScoresRequest

	// PostGetGameHighScoresExecute executes the request
	//  @return GetGameHighScoresResponse
	PostGetGameHighScoresExecute(r ApiPostGetGameHighScoresRequest) (*GetGameHighScoresResponse, *http.Response, error)

	/*
	PostGetMe getMe

	A simple method for testing your bot's authentication token. Requires no parameters. Returns basic information about the bot in form of a [User](https://core.telegram.org/bots/api/#user) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetMeRequest
	*/
	PostGetMe(ctx context.Context) ApiPostGetMeRequest

	// PostGetMeExecute executes the request
	//  @return GetMeResponse
	PostGetMeExecute(r ApiPostGetMeRequest) (*GetMeResponse, *http.Response, error)

	/*
	PostGetMyCommands getMyCommands

	Use this method to get the current list of the bot's commands for the given scope and user language. Returns an Array of [BotCommand](https://core.telegram.org/bots/api/#botcommand) objects. If commands aren't set, an empty list is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetMyCommandsRequest
	*/
	PostGetMyCommands(ctx context.Context) ApiPostGetMyCommandsRequest

	// PostGetMyCommandsExecute executes the request
	//  @return GetMyCommandsResponse
	PostGetMyCommandsExecute(r ApiPostGetMyCommandsRequest) (*GetMyCommandsResponse, *http.Response, error)

	/*
	PostGetMyDefaultAdministratorRights getMyDefaultAdministratorRights

	Use this method to get the current default administrator rights of the bot. Returns [ChatAdministratorRights](https://core.telegram.org/bots/api/#chatadministratorrights) on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetMyDefaultAdministratorRightsRequest
	*/
	PostGetMyDefaultAdministratorRights(ctx context.Context) ApiPostGetMyDefaultAdministratorRightsRequest

	// PostGetMyDefaultAdministratorRightsExecute executes the request
	//  @return GetMyDefaultAdministratorRightsResponse
	PostGetMyDefaultAdministratorRightsExecute(r ApiPostGetMyDefaultAdministratorRightsRequest) (*GetMyDefaultAdministratorRightsResponse, *http.Response, error)

	/*
	PostGetMyDescription getMyDescription

	Use this method to get the current bot description for the given user language. Returns [BotDescription](https://core.telegram.org/bots/api/#botdescription) on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetMyDescriptionRequest
	*/
	PostGetMyDescription(ctx context.Context) ApiPostGetMyDescriptionRequest

	// PostGetMyDescriptionExecute executes the request
	//  @return GetMyDescriptionResponse
	PostGetMyDescriptionExecute(r ApiPostGetMyDescriptionRequest) (*GetMyDescriptionResponse, *http.Response, error)

	/*
	PostGetMyName getMyName

	Use this method to get the current bot name for the given user language. Returns [BotName](https://core.telegram.org/bots/api/#botname) on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetMyNameRequest
	*/
	PostGetMyName(ctx context.Context) ApiPostGetMyNameRequest

	// PostGetMyNameExecute executes the request
	//  @return GetMyNameResponse
	PostGetMyNameExecute(r ApiPostGetMyNameRequest) (*GetMyNameResponse, *http.Response, error)

	/*
	PostGetMyShortDescription getMyShortDescription

	Use this method to get the current bot short description for the given user language. Returns [BotShortDescription](https://core.telegram.org/bots/api/#botshortdescription) on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetMyShortDescriptionRequest
	*/
	PostGetMyShortDescription(ctx context.Context) ApiPostGetMyShortDescriptionRequest

	// PostGetMyShortDescriptionExecute executes the request
	//  @return GetMyShortDescriptionResponse
	PostGetMyShortDescriptionExecute(r ApiPostGetMyShortDescriptionRequest) (*GetMyShortDescriptionResponse, *http.Response, error)

	/*
	PostGetMyStarBalance getMyStarBalance

	A method to get the current Telegram Stars balance of the bot. Requires no parameters. On success, returns a [StarAmount](https://core.telegram.org/bots/api/#staramount) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetMyStarBalanceRequest
	*/
	PostGetMyStarBalance(ctx context.Context) ApiPostGetMyStarBalanceRequest

	// PostGetMyStarBalanceExecute executes the request
	//  @return GetMyStarBalanceResponse
	PostGetMyStarBalanceExecute(r ApiPostGetMyStarBalanceRequest) (*GetMyStarBalanceResponse, *http.Response, error)

	/*
	PostGetStarTransactions getStarTransactions

	Returns the bot's Telegram Star transactions in chronological order. On success, returns a [StarTransactions](https://core.telegram.org/bots/api/#startransactions) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetStarTransactionsRequest
	*/
	PostGetStarTransactions(ctx context.Context) ApiPostGetStarTransactionsRequest

	// PostGetStarTransactionsExecute executes the request
	//  @return GetStarTransactionsResponse
	PostGetStarTransactionsExecute(r ApiPostGetStarTransactionsRequest) (*GetStarTransactionsResponse, *http.Response, error)

	/*
	PostGetStickerSet getStickerSet

	Use this method to get a sticker set. On success, a [StickerSet](https://core.telegram.org/bots/api/#stickerset) object is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetStickerSetRequest
	*/
	PostGetStickerSet(ctx context.Context) ApiPostGetStickerSetRequest

	// PostGetStickerSetExecute executes the request
	//  @return GetStickerSetResponse
	PostGetStickerSetExecute(r ApiPostGetStickerSetRequest) (*GetStickerSetResponse, *http.Response, error)

	/*
	PostGetUpdates getUpdates

	Use this method to receive incoming updates using long polling ([wiki](https://en.wikipedia.org/wiki/Push_technology#Long_polling)). Returns an Array of [Update](https://core.telegram.org/bots/api/#update) objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetUpdatesRequest
	*/
	PostGetUpdates(ctx context.Context) ApiPostGetUpdatesRequest

	// PostGetUpdatesExecute executes the request
	//  @return GetUpdatesResponse
	PostGetUpdatesExecute(r ApiPostGetUpdatesRequest) (*GetUpdatesResponse, *http.Response, error)

	/*
	PostGetUserChatBoosts getUserChatBoosts

	Use this method to get the list of boosts added to a chat by a user. Requires administrator rights in the chat. Returns a [UserChatBoosts](https://core.telegram.org/bots/api/#userchatboosts) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetUserChatBoostsRequest
	*/
	PostGetUserChatBoosts(ctx context.Context) ApiPostGetUserChatBoostsRequest

	// PostGetUserChatBoostsExecute executes the request
	//  @return GetUserChatBoostsResponse
	PostGetUserChatBoostsExecute(r ApiPostGetUserChatBoostsRequest) (*GetUserChatBoostsResponse, *http.Response, error)

	/*
	PostGetUserProfilePhotos getUserProfilePhotos

	Use this method to get a list of profile pictures for a user. Returns a [UserProfilePhotos](https://core.telegram.org/bots/api/#userprofilephotos) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetUserProfilePhotosRequest
	*/
	PostGetUserProfilePhotos(ctx context.Context) ApiPostGetUserProfilePhotosRequest

	// PostGetUserProfilePhotosExecute executes the request
	//  @return GetUserProfilePhotosResponse
	PostGetUserProfilePhotosExecute(r ApiPostGetUserProfilePhotosRequest) (*GetUserProfilePhotosResponse, *http.Response, error)

	/*
	PostGetWebhookInfo getWebhookInfo

	Use this method to get current webhook status. Requires no parameters. On success, returns a [WebhookInfo](https://core.telegram.org/bots/api/#webhookinfo) object. If the bot is using [getUpdates](https://core.telegram.org/bots/api/#getupdates), will return an object with the *url* field empty.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGetWebhookInfoRequest
	*/
	PostGetWebhookInfo(ctx context.Context) ApiPostGetWebhookInfoRequest

	// PostGetWebhookInfoExecute executes the request
	//  @return GetWebhookInfoResponse
	PostGetWebhookInfoExecute(r ApiPostGetWebhookInfoRequest) (*GetWebhookInfoResponse, *http.Response, error)

	/*
	PostGiftPremiumSubscription giftPremiumSubscription

	Gifts a Telegram Premium subscription to the given user. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostGiftPremiumSubscriptionRequest
	*/
	PostGiftPremiumSubscription(ctx context.Context) ApiPostGiftPremiumSubscriptionRequest

	// PostGiftPremiumSubscriptionExecute executes the request
	//  @return GiftPremiumSubscriptionResponse
	PostGiftPremiumSubscriptionExecute(r ApiPostGiftPremiumSubscriptionRequest) (*GiftPremiumSubscriptionResponse, *http.Response, error)

	/*
	PostHideGeneralForumTopic hideGeneralForumTopic

	Use this method to hide the 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. The topic will be automatically closed if it was open. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostHideGeneralForumTopicRequest
	*/
	PostHideGeneralForumTopic(ctx context.Context) ApiPostHideGeneralForumTopicRequest

	// PostHideGeneralForumTopicExecute executes the request
	//  @return HideGeneralForumTopicResponse
	PostHideGeneralForumTopicExecute(r ApiPostHideGeneralForumTopicRequest) (*HideGeneralForumTopicResponse, *http.Response, error)

	/*
	PostLeaveChat leaveChat

	Use this method for your bot to leave a group, supergroup or channel. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostLeaveChatRequest
	*/
	PostLeaveChat(ctx context.Context) ApiPostLeaveChatRequest

	// PostLeaveChatExecute executes the request
	//  @return LeaveChatResponse
	PostLeaveChatExecute(r ApiPostLeaveChatRequest) (*LeaveChatResponse, *http.Response, error)

	/*
	PostLogOut logOut

	Use this method to log out from the cloud Bot API server before launching the bot locally. You **must** log out the bot before running it locally, otherwise there is no guarantee that the bot will receive updates. After a successful call, you can immediately log in on a local server, but will not be able to log in back to the cloud Bot API server for 10 minutes. Returns *True* on success. Requires no parameters.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostLogOutRequest
	*/
	PostLogOut(ctx context.Context) ApiPostLogOutRequest

	// PostLogOutExecute executes the request
	//  @return LogOutResponse
	PostLogOutExecute(r ApiPostLogOutRequest) (*LogOutResponse, *http.Response, error)

	/*
	PostPinChatMessage pinChatMessage

	Use this method to add a message to the list of pinned messages in a chat. If the chat is not a private chat, the bot must be an administrator in the chat for this to work and must have the 'can\_pin\_messages' administrator right in a supergroup or 'can\_edit\_messages' administrator right in a channel. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostPinChatMessageRequest
	*/
	PostPinChatMessage(ctx context.Context) ApiPostPinChatMessageRequest

	// PostPinChatMessageExecute executes the request
	//  @return PinChatMessageResponse
	PostPinChatMessageExecute(r ApiPostPinChatMessageRequest) (*PinChatMessageResponse, *http.Response, error)

	/*
	PostPostStory postStory

	Posts a story on behalf of a managed business account. Requires the *can\_manage\_stories* business bot right. Returns [Story](https://core.telegram.org/bots/api/#story) on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostPostStoryRequest
	*/
	PostPostStory(ctx context.Context) ApiPostPostStoryRequest

	// PostPostStoryExecute executes the request
	//  @return PostStoryResponse
	PostPostStoryExecute(r ApiPostPostStoryRequest) (*PostStoryResponse, *http.Response, error)

	/*
	PostPromoteChatMember promoteChatMember

	Use this method to promote or demote a user in a supergroup or a channel. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Pass *False* for all boolean parameters to demote a user. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostPromoteChatMemberRequest
	*/
	PostPromoteChatMember(ctx context.Context) ApiPostPromoteChatMemberRequest

	// PostPromoteChatMemberExecute executes the request
	//  @return PromoteChatMemberResponse
	PostPromoteChatMemberExecute(r ApiPostPromoteChatMemberRequest) (*PromoteChatMemberResponse, *http.Response, error)

	/*
	PostReadBusinessMessage readBusinessMessage

	Marks incoming message as read on behalf of a business account. Requires the *can\_read\_messages* business bot right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostReadBusinessMessageRequest
	*/
	PostReadBusinessMessage(ctx context.Context) ApiPostReadBusinessMessageRequest

	// PostReadBusinessMessageExecute executes the request
	//  @return ReadBusinessMessageResponse
	PostReadBusinessMessageExecute(r ApiPostReadBusinessMessageRequest) (*ReadBusinessMessageResponse, *http.Response, error)

	/*
	PostRefundStarPayment refundStarPayment

	Refunds a successful payment in [Telegram Stars](https://t.me/BotNews/90). Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostRefundStarPaymentRequest
	*/
	PostRefundStarPayment(ctx context.Context) ApiPostRefundStarPaymentRequest

	// PostRefundStarPaymentExecute executes the request
	//  @return RefundStarPaymentResponse
	PostRefundStarPaymentExecute(r ApiPostRefundStarPaymentRequest) (*RefundStarPaymentResponse, *http.Response, error)

	/*
	PostRemoveBusinessAccountProfilePhoto removeBusinessAccountProfilePhoto

	Removes the current profile photo of a managed business account. Requires the *can\_edit\_profile\_photo* business bot right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostRemoveBusinessAccountProfilePhotoRequest
	*/
	PostRemoveBusinessAccountProfilePhoto(ctx context.Context) ApiPostRemoveBusinessAccountProfilePhotoRequest

	// PostRemoveBusinessAccountProfilePhotoExecute executes the request
	//  @return RemoveBusinessAccountProfilePhotoResponse
	PostRemoveBusinessAccountProfilePhotoExecute(r ApiPostRemoveBusinessAccountProfilePhotoRequest) (*RemoveBusinessAccountProfilePhotoResponse, *http.Response, error)

	/*
	PostRemoveChatVerification removeChatVerification

	Removes verification from a chat that is currently verified [on behalf of the organization](https://telegram.org/verify#third-party-verification) represented by the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostRemoveChatVerificationRequest
	*/
	PostRemoveChatVerification(ctx context.Context) ApiPostRemoveChatVerificationRequest

	// PostRemoveChatVerificationExecute executes the request
	//  @return RemoveChatVerificationResponse
	PostRemoveChatVerificationExecute(r ApiPostRemoveChatVerificationRequest) (*RemoveChatVerificationResponse, *http.Response, error)

	/*
	PostRemoveUserVerification removeUserVerification

	Removes verification from a user who is currently verified [on behalf of the organization](https://telegram.org/verify#third-party-verification) represented by the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostRemoveUserVerificationRequest
	*/
	PostRemoveUserVerification(ctx context.Context) ApiPostRemoveUserVerificationRequest

	// PostRemoveUserVerificationExecute executes the request
	//  @return RemoveUserVerificationResponse
	PostRemoveUserVerificationExecute(r ApiPostRemoveUserVerificationRequest) (*RemoveUserVerificationResponse, *http.Response, error)

	/*
	PostReopenForumTopic reopenForumTopic

	Use this method to reopen a closed topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights, unless it is the creator of the topic. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostReopenForumTopicRequest
	*/
	PostReopenForumTopic(ctx context.Context) ApiPostReopenForumTopicRequest

	// PostReopenForumTopicExecute executes the request
	//  @return ReopenForumTopicResponse
	PostReopenForumTopicExecute(r ApiPostReopenForumTopicRequest) (*ReopenForumTopicResponse, *http.Response, error)

	/*
	PostReopenGeneralForumTopic reopenGeneralForumTopic

	Use this method to reopen a closed 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. The topic will be automatically unhidden if it was hidden. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostReopenGeneralForumTopicRequest
	*/
	PostReopenGeneralForumTopic(ctx context.Context) ApiPostReopenGeneralForumTopicRequest

	// PostReopenGeneralForumTopicExecute executes the request
	//  @return ReopenGeneralForumTopicResponse
	PostReopenGeneralForumTopicExecute(r ApiPostReopenGeneralForumTopicRequest) (*ReopenGeneralForumTopicResponse, *http.Response, error)

	/*
	PostReplaceStickerInSet replaceStickerInSet

	Use this method to replace an existing sticker in a sticker set with a new one. The method is equivalent to calling [deleteStickerFromSet](https://core.telegram.org/bots/api/#deletestickerfromset), then [addStickerToSet](https://core.telegram.org/bots/api/#addstickertoset), then [setStickerPositionInSet](https://core.telegram.org/bots/api/#setstickerpositioninset). Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostReplaceStickerInSetRequest
	*/
	PostReplaceStickerInSet(ctx context.Context) ApiPostReplaceStickerInSetRequest

	// PostReplaceStickerInSetExecute executes the request
	//  @return ReplaceStickerInSetResponse
	PostReplaceStickerInSetExecute(r ApiPostReplaceStickerInSetRequest) (*ReplaceStickerInSetResponse, *http.Response, error)

	/*
	PostRestrictChatMember restrictChatMember

	Use this method to restrict a user in a supergroup. The bot must be an administrator in the supergroup for this to work and must have the appropriate administrator rights. Pass *True* for all permissions to lift restrictions from a user. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostRestrictChatMemberRequest
	*/
	PostRestrictChatMember(ctx context.Context) ApiPostRestrictChatMemberRequest

	// PostRestrictChatMemberExecute executes the request
	//  @return RestrictChatMemberResponse
	PostRestrictChatMemberExecute(r ApiPostRestrictChatMemberRequest) (*RestrictChatMemberResponse, *http.Response, error)

	/*
	PostRevokeChatInviteLink revokeChatInviteLink

	Use this method to revoke an invite link created by the bot. If the primary link is revoked, a new link is automatically generated. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns the revoked invite link as [ChatInviteLink](https://core.telegram.org/bots/api/#chatinvitelink) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostRevokeChatInviteLinkRequest
	*/
	PostRevokeChatInviteLink(ctx context.Context) ApiPostRevokeChatInviteLinkRequest

	// PostRevokeChatInviteLinkExecute executes the request
	//  @return RevokeChatInviteLinkResponse
	PostRevokeChatInviteLinkExecute(r ApiPostRevokeChatInviteLinkRequest) (*RevokeChatInviteLinkResponse, *http.Response, error)

	/*
	PostSavePreparedInlineMessage savePreparedInlineMessage

	Stores a message that can be sent by a user of a Mini App. Returns a [PreparedInlineMessage](https://core.telegram.org/bots/api/#preparedinlinemessage) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSavePreparedInlineMessageRequest
	*/
	PostSavePreparedInlineMessage(ctx context.Context) ApiPostSavePreparedInlineMessageRequest

	// PostSavePreparedInlineMessageExecute executes the request
	//  @return SavePreparedInlineMessageResponse
	PostSavePreparedInlineMessageExecute(r ApiPostSavePreparedInlineMessageRequest) (*SavePreparedInlineMessageResponse, *http.Response, error)

	/*
	PostSendAnimation sendAnimation

	Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without sound). On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned. Bots can currently send animation files of up to 50 MB in size, this limit may be changed in the future.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSendAnimationRequest
	*/
	PostSendAnimation(ctx context.Context) ApiPostSendAnimationRequest

	// PostSendAnimationExecute executes the request
	//  @return SendAnimationResponse
	PostSendAnimationExecute(r ApiPostSendAnimationRequest) (*SendAnimationResponse, *http.Response, error)

	/*
	PostSendAudio sendAudio

	Use this method to send audio files, if you want Telegram clients to display them in the music player. Your audio must be in the .MP3 or .M4A format. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned. Bots can currently send audio files of up to 50 MB in size, this limit may be changed in the future.

For sending voice messages, use the [sendVoice](https://core.telegram.org/bots/api/#sendvoice) method instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSendAudioRequest
	*/
	PostSendAudio(ctx context.Context) ApiPostSendAudioRequest

	// PostSendAudioExecute executes the request
	//  @return SendAudioResponse
	PostSendAudioExecute(r ApiPostSendAudioRequest) (*SendAudioResponse, *http.Response, error)

	/*
	PostSendChatAction sendChatAction

	Use this method when you need to tell the user that something is happening on the bot's side. The status is set for 5 seconds or less (when a message arrives from your bot, Telegram clients clear its typing status). Returns *True* on success.

Example: The [ImageBot](https://t.me/imagebot) needs some time to process a request and upload the image. Instead of sending a text message along the lines of “Retrieving image, please wait…”, the bot may use [sendChatAction](https://core.telegram.org/bots/api/#sendchataction) with *action* = *upload\_photo*. The user will see a “sending photo” status for the bot.

We only recommend using this method when a response from the bot will take a **noticeable** amount of time to arrive.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSendChatActionRequest
	*/
	PostSendChatAction(ctx context.Context) ApiPostSendChatActionRequest

	// PostSendChatActionExecute executes the request
	//  @return SendChatActionResponse
	PostSendChatActionExecute(r ApiPostSendChatActionRequest) (*SendChatActionResponse, *http.Response, error)

	/*
	PostSendChecklist sendChecklist

	Use this method to send a checklist on behalf of a connected business account. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSendChecklistRequest
	*/
	PostSendChecklist(ctx context.Context) ApiPostSendChecklistRequest

	// PostSendChecklistExecute executes the request
	//  @return SendChecklistResponse
	PostSendChecklistExecute(r ApiPostSendChecklistRequest) (*SendChecklistResponse, *http.Response, error)

	/*
	PostSendContact sendContact

	Use this method to send phone contacts. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSendContactRequest
	*/
	PostSendContact(ctx context.Context) ApiPostSendContactRequest

	// PostSendContactExecute executes the request
	//  @return SendContactResponse
	PostSendContactExecute(r ApiPostSendContactRequest) (*SendContactResponse, *http.Response, error)

	/*
	PostSendDice sendDice

	Use this method to send an animated emoji that will display a random value. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSendDiceRequest
	*/
	PostSendDice(ctx context.Context) ApiPostSendDiceRequest

	// PostSendDiceExecute executes the request
	//  @return SendDiceResponse
	PostSendDiceExecute(r ApiPostSendDiceRequest) (*SendDiceResponse, *http.Response, error)

	/*
	PostSendDocument sendDocument

	Use this method to send general files. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned. Bots can currently send files of any type of up to 50 MB in size, this limit may be changed in the future.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSendDocumentRequest
	*/
	PostSendDocument(ctx context.Context) ApiPostSendDocumentRequest

	// PostSendDocumentExecute executes the request
	//  @return SendDocumentResponse
	PostSendDocumentExecute(r ApiPostSendDocumentRequest) (*SendDocumentResponse, *http.Response, error)

	/*
	PostSendGame sendGame

	Use this method to send a game. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSendGameRequest
	*/
	PostSendGame(ctx context.Context) ApiPostSendGameRequest

	// PostSendGameExecute executes the request
	//  @return SendGameResponse
	PostSendGameExecute(r ApiPostSendGameRequest) (*SendGameResponse, *http.Response, error)

	/*
	PostSendGift sendGift

	Sends a gift to the given user or channel chat. The gift can't be converted to Telegram Stars by the receiver. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSendGiftRequest
	*/
	PostSendGift(ctx context.Context) ApiPostSendGiftRequest

	// PostSendGiftExecute executes the request
	//  @return SendGiftResponse
	PostSendGiftExecute(r ApiPostSendGiftRequest) (*SendGiftResponse, *http.Response, error)

	/*
	PostSendInvoice sendInvoice

	Use this method to send invoices. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSendInvoiceRequest
	*/
	PostSendInvoice(ctx context.Context) ApiPostSendInvoiceRequest

	// PostSendInvoiceExecute executes the request
	//  @return SendInvoiceResponse
	PostSendInvoiceExecute(r ApiPostSendInvoiceRequest) (*SendInvoiceResponse, *http.Response, error)

	/*
	PostSendLocation sendLocation

	Use this method to send point on the map. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSendLocationRequest
	*/
	PostSendLocation(ctx context.Context) ApiPostSendLocationRequest

	// PostSendLocationExecute executes the request
	//  @return SendLocationResponse
	PostSendLocationExecute(r ApiPostSendLocationRequest) (*SendLocationResponse, *http.Response, error)

	/*
	PostSendMediaGroup sendMediaGroup

	Use this method to send a group of photos, videos, documents or audios as an album. Documents and audio files can be only grouped in an album with messages of the same type. On success, an array of [Message](https://core.telegram.org/bots/api/#message) objects that were sent is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSendMediaGroupRequest
	*/
	PostSendMediaGroup(ctx context.Context) ApiPostSendMediaGroupRequest

	// PostSendMediaGroupExecute executes the request
	//  @return SendMediaGroupResponse
	PostSendMediaGroupExecute(r ApiPostSendMediaGroupRequest) (*SendMediaGroupResponse, *http.Response, error)

	/*
	PostSendMessage sendMessage

	Use this method to send text messages. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSendMessageRequest
	*/
	PostSendMessage(ctx context.Context) ApiPostSendMessageRequest

	// PostSendMessageExecute executes the request
	//  @return SendMessageResponse
	PostSendMessageExecute(r ApiPostSendMessageRequest) (*SendMessageResponse, *http.Response, error)

	/*
	PostSendPaidMedia sendPaidMedia

	Use this method to send paid media. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSendPaidMediaRequest
	*/
	PostSendPaidMedia(ctx context.Context) ApiPostSendPaidMediaRequest

	// PostSendPaidMediaExecute executes the request
	//  @return SendPaidMediaResponse
	PostSendPaidMediaExecute(r ApiPostSendPaidMediaRequest) (*SendPaidMediaResponse, *http.Response, error)

	/*
	PostSendPhoto sendPhoto

	Use this method to send photos. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSendPhotoRequest
	*/
	PostSendPhoto(ctx context.Context) ApiPostSendPhotoRequest

	// PostSendPhotoExecute executes the request
	//  @return SendPhotoResponse
	PostSendPhotoExecute(r ApiPostSendPhotoRequest) (*SendPhotoResponse, *http.Response, error)

	/*
	PostSendPoll sendPoll

	Use this method to send a native poll. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSendPollRequest
	*/
	PostSendPoll(ctx context.Context) ApiPostSendPollRequest

	// PostSendPollExecute executes the request
	//  @return SendPollResponse
	PostSendPollExecute(r ApiPostSendPollRequest) (*SendPollResponse, *http.Response, error)

	/*
	PostSendSticker sendSticker

	Use this method to send static .WEBP, [animated](https://telegram.org/blog/animated-stickers) .TGS, or [video](https://telegram.org/blog/video-stickers-better-reactions) .WEBM stickers. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSendStickerRequest
	*/
	PostSendSticker(ctx context.Context) ApiPostSendStickerRequest

	// PostSendStickerExecute executes the request
	//  @return SendStickerResponse
	PostSendStickerExecute(r ApiPostSendStickerRequest) (*SendStickerResponse, *http.Response, error)

	/*
	PostSendVenue sendVenue

	Use this method to send information about a venue. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSendVenueRequest
	*/
	PostSendVenue(ctx context.Context) ApiPostSendVenueRequest

	// PostSendVenueExecute executes the request
	//  @return SendVenueResponse
	PostSendVenueExecute(r ApiPostSendVenueRequest) (*SendVenueResponse, *http.Response, error)

	/*
	PostSendVideo sendVideo

	Use this method to send video files, Telegram clients support MPEG4 videos (other formats may be sent as [Document](https://core.telegram.org/bots/api/#document)). On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned. Bots can currently send video files of up to 50 MB in size, this limit may be changed in the future.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSendVideoRequest
	*/
	PostSendVideo(ctx context.Context) ApiPostSendVideoRequest

	// PostSendVideoExecute executes the request
	//  @return SendVideoResponse
	PostSendVideoExecute(r ApiPostSendVideoRequest) (*SendVideoResponse, *http.Response, error)

	/*
	PostSendVideoNote sendVideoNote

	As of [v.4.0](https://telegram.org/blog/video-messages-and-telescope), Telegram clients support rounded square MPEG4 videos of up to 1 minute long. Use this method to send video messages. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSendVideoNoteRequest
	*/
	PostSendVideoNote(ctx context.Context) ApiPostSendVideoNoteRequest

	// PostSendVideoNoteExecute executes the request
	//  @return SendVideoNoteResponse
	PostSendVideoNoteExecute(r ApiPostSendVideoNoteRequest) (*SendVideoNoteResponse, *http.Response, error)

	/*
	PostSendVoice sendVoice

	Use this method to send audio files, if you want Telegram clients to display the file as a playable voice message. For this to work, your audio must be in an .OGG file encoded with OPUS, or in .MP3 format, or in .M4A format (other formats may be sent as [Audio](https://core.telegram.org/bots/api/#audio) or [Document](https://core.telegram.org/bots/api/#document)). On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned. Bots can currently send voice messages of up to 50 MB in size, this limit may be changed in the future.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSendVoiceRequest
	*/
	PostSendVoice(ctx context.Context) ApiPostSendVoiceRequest

	// PostSendVoiceExecute executes the request
	//  @return SendVoiceResponse
	PostSendVoiceExecute(r ApiPostSendVoiceRequest) (*SendVoiceResponse, *http.Response, error)

	/*
	PostSetBusinessAccountBio setBusinessAccountBio

	Changes the bio of a managed business account. Requires the *can\_change\_bio* business bot right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetBusinessAccountBioRequest
	*/
	PostSetBusinessAccountBio(ctx context.Context) ApiPostSetBusinessAccountBioRequest

	// PostSetBusinessAccountBioExecute executes the request
	//  @return SetBusinessAccountBioResponse
	PostSetBusinessAccountBioExecute(r ApiPostSetBusinessAccountBioRequest) (*SetBusinessAccountBioResponse, *http.Response, error)

	/*
	PostSetBusinessAccountGiftSettings setBusinessAccountGiftSettings

	Changes the privacy settings pertaining to incoming gifts in a managed business account. Requires the *can\_change\_gift\_settings* business bot right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetBusinessAccountGiftSettingsRequest
	*/
	PostSetBusinessAccountGiftSettings(ctx context.Context) ApiPostSetBusinessAccountGiftSettingsRequest

	// PostSetBusinessAccountGiftSettingsExecute executes the request
	//  @return SetBusinessAccountGiftSettingsResponse
	PostSetBusinessAccountGiftSettingsExecute(r ApiPostSetBusinessAccountGiftSettingsRequest) (*SetBusinessAccountGiftSettingsResponse, *http.Response, error)

	/*
	PostSetBusinessAccountName setBusinessAccountName

	Changes the first and last name of a managed business account. Requires the *can\_change\_name* business bot right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetBusinessAccountNameRequest
	*/
	PostSetBusinessAccountName(ctx context.Context) ApiPostSetBusinessAccountNameRequest

	// PostSetBusinessAccountNameExecute executes the request
	//  @return SetBusinessAccountNameResponse
	PostSetBusinessAccountNameExecute(r ApiPostSetBusinessAccountNameRequest) (*SetBusinessAccountNameResponse, *http.Response, error)

	/*
	PostSetBusinessAccountProfilePhoto setBusinessAccountProfilePhoto

	Changes the profile photo of a managed business account. Requires the *can\_edit\_profile\_photo* business bot right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetBusinessAccountProfilePhotoRequest
	*/
	PostSetBusinessAccountProfilePhoto(ctx context.Context) ApiPostSetBusinessAccountProfilePhotoRequest

	// PostSetBusinessAccountProfilePhotoExecute executes the request
	//  @return SetBusinessAccountProfilePhotoResponse
	PostSetBusinessAccountProfilePhotoExecute(r ApiPostSetBusinessAccountProfilePhotoRequest) (*SetBusinessAccountProfilePhotoResponse, *http.Response, error)

	/*
	PostSetBusinessAccountUsername setBusinessAccountUsername

	Changes the username of a managed business account. Requires the *can\_change\_username* business bot right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetBusinessAccountUsernameRequest
	*/
	PostSetBusinessAccountUsername(ctx context.Context) ApiPostSetBusinessAccountUsernameRequest

	// PostSetBusinessAccountUsernameExecute executes the request
	//  @return SetBusinessAccountUsernameResponse
	PostSetBusinessAccountUsernameExecute(r ApiPostSetBusinessAccountUsernameRequest) (*SetBusinessAccountUsernameResponse, *http.Response, error)

	/*
	PostSetChatAdministratorCustomTitle setChatAdministratorCustomTitle

	Use this method to set a custom title for an administrator in a supergroup promoted by the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetChatAdministratorCustomTitleRequest
	*/
	PostSetChatAdministratorCustomTitle(ctx context.Context) ApiPostSetChatAdministratorCustomTitleRequest

	// PostSetChatAdministratorCustomTitleExecute executes the request
	//  @return SetChatAdministratorCustomTitleResponse
	PostSetChatAdministratorCustomTitleExecute(r ApiPostSetChatAdministratorCustomTitleRequest) (*SetChatAdministratorCustomTitleResponse, *http.Response, error)

	/*
	PostSetChatDescription setChatDescription

	Use this method to change the description of a group, a supergroup or a channel. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetChatDescriptionRequest
	*/
	PostSetChatDescription(ctx context.Context) ApiPostSetChatDescriptionRequest

	// PostSetChatDescriptionExecute executes the request
	//  @return SetChatDescriptionResponse
	PostSetChatDescriptionExecute(r ApiPostSetChatDescriptionRequest) (*SetChatDescriptionResponse, *http.Response, error)

	/*
	PostSetChatMenuButton setChatMenuButton

	Use this method to change the bot's menu button in a private chat, or the default menu button. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetChatMenuButtonRequest
	*/
	PostSetChatMenuButton(ctx context.Context) ApiPostSetChatMenuButtonRequest

	// PostSetChatMenuButtonExecute executes the request
	//  @return SetChatMenuButtonResponse
	PostSetChatMenuButtonExecute(r ApiPostSetChatMenuButtonRequest) (*SetChatMenuButtonResponse, *http.Response, error)

	/*
	PostSetChatPermissions setChatPermissions

	Use this method to set default chat permissions for all members. The bot must be an administrator in the group or a supergroup for this to work and must have the *can\_restrict\_members* administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetChatPermissionsRequest
	*/
	PostSetChatPermissions(ctx context.Context) ApiPostSetChatPermissionsRequest

	// PostSetChatPermissionsExecute executes the request
	//  @return SetChatPermissionsResponse
	PostSetChatPermissionsExecute(r ApiPostSetChatPermissionsRequest) (*SetChatPermissionsResponse, *http.Response, error)

	/*
	PostSetChatPhoto setChatPhoto

	Use this method to set a new profile photo for the chat. Photos can't be changed for private chats. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetChatPhotoRequest
	*/
	PostSetChatPhoto(ctx context.Context) ApiPostSetChatPhotoRequest

	// PostSetChatPhotoExecute executes the request
	//  @return SetChatPhotoResponse
	PostSetChatPhotoExecute(r ApiPostSetChatPhotoRequest) (*SetChatPhotoResponse, *http.Response, error)

	/*
	PostSetChatStickerSet setChatStickerSet

	Use this method to set a new group sticker set for a supergroup. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Use the field *can\_set\_sticker\_set* optionally returned in [getChat](https://core.telegram.org/bots/api/#getchat) requests to check if the bot can use this method. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetChatStickerSetRequest
	*/
	PostSetChatStickerSet(ctx context.Context) ApiPostSetChatStickerSetRequest

	// PostSetChatStickerSetExecute executes the request
	//  @return SetChatStickerSetResponse
	PostSetChatStickerSetExecute(r ApiPostSetChatStickerSetRequest) (*SetChatStickerSetResponse, *http.Response, error)

	/*
	PostSetChatTitle setChatTitle

	Use this method to change the title of a chat. Titles can't be changed for private chats. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetChatTitleRequest
	*/
	PostSetChatTitle(ctx context.Context) ApiPostSetChatTitleRequest

	// PostSetChatTitleExecute executes the request
	//  @return SetChatTitleResponse
	PostSetChatTitleExecute(r ApiPostSetChatTitleRequest) (*SetChatTitleResponse, *http.Response, error)

	/*
	PostSetCustomEmojiStickerSetThumbnail setCustomEmojiStickerSetThumbnail

	Use this method to set the thumbnail of a custom emoji sticker set. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetCustomEmojiStickerSetThumbnailRequest
	*/
	PostSetCustomEmojiStickerSetThumbnail(ctx context.Context) ApiPostSetCustomEmojiStickerSetThumbnailRequest

	// PostSetCustomEmojiStickerSetThumbnailExecute executes the request
	//  @return SetCustomEmojiStickerSetThumbnailResponse
	PostSetCustomEmojiStickerSetThumbnailExecute(r ApiPostSetCustomEmojiStickerSetThumbnailRequest) (*SetCustomEmojiStickerSetThumbnailResponse, *http.Response, error)

	/*
	PostSetGameScore setGameScore

	Use this method to set the score of the specified user in a game message. On success, if the message is not an inline message, the [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned. Returns an error, if the new score is not greater than the user's current score in the chat and *force* is *False*.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetGameScoreRequest
	*/
	PostSetGameScore(ctx context.Context) ApiPostSetGameScoreRequest

	// PostSetGameScoreExecute executes the request
	//  @return SetGameScoreResponse
	PostSetGameScoreExecute(r ApiPostSetGameScoreRequest) (*SetGameScoreResponse, *http.Response, error)

	/*
	PostSetMessageReaction setMessageReaction

	Use this method to change the chosen reactions on a message. Service messages of some types can't be reacted to. Automatically forwarded messages from a channel to its discussion group have the same available reactions as messages in the channel. Bots can't use paid reactions. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetMessageReactionRequest
	*/
	PostSetMessageReaction(ctx context.Context) ApiPostSetMessageReactionRequest

	// PostSetMessageReactionExecute executes the request
	//  @return SetMessageReactionResponse
	PostSetMessageReactionExecute(r ApiPostSetMessageReactionRequest) (*SetMessageReactionResponse, *http.Response, error)

	/*
	PostSetMyCommands setMyCommands

	Use this method to change the list of the bot's commands. See [this manual](https://core.telegram.org/bots/features#commands) for more details about bot commands. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetMyCommandsRequest
	*/
	PostSetMyCommands(ctx context.Context) ApiPostSetMyCommandsRequest

	// PostSetMyCommandsExecute executes the request
	//  @return SetMyCommandsResponse
	PostSetMyCommandsExecute(r ApiPostSetMyCommandsRequest) (*SetMyCommandsResponse, *http.Response, error)

	/*
	PostSetMyDefaultAdministratorRights setMyDefaultAdministratorRights

	Use this method to change the default administrator rights requested by the bot when it's added as an administrator to groups or channels. These rights will be suggested to users, but they are free to modify the list before adding the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetMyDefaultAdministratorRightsRequest
	*/
	PostSetMyDefaultAdministratorRights(ctx context.Context) ApiPostSetMyDefaultAdministratorRightsRequest

	// PostSetMyDefaultAdministratorRightsExecute executes the request
	//  @return SetMyDefaultAdministratorRightsResponse
	PostSetMyDefaultAdministratorRightsExecute(r ApiPostSetMyDefaultAdministratorRightsRequest) (*SetMyDefaultAdministratorRightsResponse, *http.Response, error)

	/*
	PostSetMyDescription setMyDescription

	Use this method to change the bot's description, which is shown in the chat with the bot if the chat is empty. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetMyDescriptionRequest
	*/
	PostSetMyDescription(ctx context.Context) ApiPostSetMyDescriptionRequest

	// PostSetMyDescriptionExecute executes the request
	//  @return SetMyDescriptionResponse
	PostSetMyDescriptionExecute(r ApiPostSetMyDescriptionRequest) (*SetMyDescriptionResponse, *http.Response, error)

	/*
	PostSetMyName setMyName

	Use this method to change the bot's name. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetMyNameRequest
	*/
	PostSetMyName(ctx context.Context) ApiPostSetMyNameRequest

	// PostSetMyNameExecute executes the request
	//  @return SetMyNameResponse
	PostSetMyNameExecute(r ApiPostSetMyNameRequest) (*SetMyNameResponse, *http.Response, error)

	/*
	PostSetMyShortDescription setMyShortDescription

	Use this method to change the bot's short description, which is shown on the bot's profile page and is sent together with the link when users share the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetMyShortDescriptionRequest
	*/
	PostSetMyShortDescription(ctx context.Context) ApiPostSetMyShortDescriptionRequest

	// PostSetMyShortDescriptionExecute executes the request
	//  @return SetMyShortDescriptionResponse
	PostSetMyShortDescriptionExecute(r ApiPostSetMyShortDescriptionRequest) (*SetMyShortDescriptionResponse, *http.Response, error)

	/*
	PostSetPassportDataErrors setPassportDataErrors

	Informs a user that some of the Telegram Passport elements they provided contains errors. The user will not be able to re-submit their Passport to you until the errors are fixed (the contents of the field for which you returned the error must change). Returns *True* on success.

Use this if the data submitted by the user doesn't satisfy the standards your service requires for any reason. For example, if a birthday date seems invalid, a submitted document is blurry, a scan shows evidence of tampering, etc. Supply some details in the error message to make sure the user knows how to correct the issues.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetPassportDataErrorsRequest
	*/
	PostSetPassportDataErrors(ctx context.Context) ApiPostSetPassportDataErrorsRequest

	// PostSetPassportDataErrorsExecute executes the request
	//  @return SetPassportDataErrorsResponse
	PostSetPassportDataErrorsExecute(r ApiPostSetPassportDataErrorsRequest) (*SetPassportDataErrorsResponse, *http.Response, error)

	/*
	PostSetStickerEmojiList setStickerEmojiList

	Use this method to change the list of emoji assigned to a regular or custom emoji sticker. The sticker must belong to a sticker set created by the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetStickerEmojiListRequest
	*/
	PostSetStickerEmojiList(ctx context.Context) ApiPostSetStickerEmojiListRequest

	// PostSetStickerEmojiListExecute executes the request
	//  @return SetStickerEmojiListResponse
	PostSetStickerEmojiListExecute(r ApiPostSetStickerEmojiListRequest) (*SetStickerEmojiListResponse, *http.Response, error)

	/*
	PostSetStickerKeywords setStickerKeywords

	Use this method to change search keywords assigned to a regular or custom emoji sticker. The sticker must belong to a sticker set created by the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetStickerKeywordsRequest
	*/
	PostSetStickerKeywords(ctx context.Context) ApiPostSetStickerKeywordsRequest

	// PostSetStickerKeywordsExecute executes the request
	//  @return SetStickerKeywordsResponse
	PostSetStickerKeywordsExecute(r ApiPostSetStickerKeywordsRequest) (*SetStickerKeywordsResponse, *http.Response, error)

	/*
	PostSetStickerMaskPosition setStickerMaskPosition

	Use this method to change the [mask position](https://core.telegram.org/bots/api/#maskposition) of a mask sticker. The sticker must belong to a sticker set that was created by the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetStickerMaskPositionRequest
	*/
	PostSetStickerMaskPosition(ctx context.Context) ApiPostSetStickerMaskPositionRequest

	// PostSetStickerMaskPositionExecute executes the request
	//  @return SetStickerMaskPositionResponse
	PostSetStickerMaskPositionExecute(r ApiPostSetStickerMaskPositionRequest) (*SetStickerMaskPositionResponse, *http.Response, error)

	/*
	PostSetStickerPositionInSet setStickerPositionInSet

	Use this method to move a sticker in a set created by the bot to a specific position. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetStickerPositionInSetRequest
	*/
	PostSetStickerPositionInSet(ctx context.Context) ApiPostSetStickerPositionInSetRequest

	// PostSetStickerPositionInSetExecute executes the request
	//  @return SetStickerPositionInSetResponse
	PostSetStickerPositionInSetExecute(r ApiPostSetStickerPositionInSetRequest) (*SetStickerPositionInSetResponse, *http.Response, error)

	/*
	PostSetStickerSetThumbnail setStickerSetThumbnail

	Use this method to set the thumbnail of a regular or mask sticker set. The format of the thumbnail file must match the format of the stickers in the set. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetStickerSetThumbnailRequest
	*/
	PostSetStickerSetThumbnail(ctx context.Context) ApiPostSetStickerSetThumbnailRequest

	// PostSetStickerSetThumbnailExecute executes the request
	//  @return SetStickerSetThumbnailResponse
	PostSetStickerSetThumbnailExecute(r ApiPostSetStickerSetThumbnailRequest) (*SetStickerSetThumbnailResponse, *http.Response, error)

	/*
	PostSetStickerSetTitle setStickerSetTitle

	Use this method to set the title of a created sticker set. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetStickerSetTitleRequest
	*/
	PostSetStickerSetTitle(ctx context.Context) ApiPostSetStickerSetTitleRequest

	// PostSetStickerSetTitleExecute executes the request
	//  @return SetStickerSetTitleResponse
	PostSetStickerSetTitleExecute(r ApiPostSetStickerSetTitleRequest) (*SetStickerSetTitleResponse, *http.Response, error)

	/*
	PostSetUserEmojiStatus setUserEmojiStatus

	Changes the emoji status for a given user that previously allowed the bot to manage their emoji status via the Mini App method [requestEmojiStatusAccess](https://core.telegram.org/bots/webapps#initializing-mini-apps). Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetUserEmojiStatusRequest
	*/
	PostSetUserEmojiStatus(ctx context.Context) ApiPostSetUserEmojiStatusRequest

	// PostSetUserEmojiStatusExecute executes the request
	//  @return SetUserEmojiStatusResponse
	PostSetUserEmojiStatusExecute(r ApiPostSetUserEmojiStatusRequest) (*SetUserEmojiStatusResponse, *http.Response, error)

	/*
	PostSetWebhook setWebhook

	Use this method to specify a URL and receive incoming updates via an outgoing webhook. Whenever there is an update for the bot, we will send an HTTPS POST request to the specified URL, containing a JSON-serialized [Update](https://core.telegram.org/bots/api/#update). In case of an unsuccessful request (a request with response [HTTP status code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) different from `2XY`), we will repeat the request and give up after a reasonable amount of attempts. Returns *True* on success.

If you'd like to make sure that the webhook was set by you, you can specify secret data in the parameter *secret\_token*. If specified, the request will contain a header “X-Telegram-Bot-Api-Secret-Token” with the secret token as content.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSetWebhookRequest
	*/
	PostSetWebhook(ctx context.Context) ApiPostSetWebhookRequest

	// PostSetWebhookExecute executes the request
	//  @return SetWebhookResponse
	PostSetWebhookExecute(r ApiPostSetWebhookRequest) (*SetWebhookResponse, *http.Response, error)

	/*
	PostStopMessageLiveLocation stopMessageLiveLocation

	Use this method to stop updating a live location message before *live\_period* expires. On success, if the message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostStopMessageLiveLocationRequest
	*/
	PostStopMessageLiveLocation(ctx context.Context) ApiPostStopMessageLiveLocationRequest

	// PostStopMessageLiveLocationExecute executes the request
	//  @return StopMessageLiveLocationResponse
	PostStopMessageLiveLocationExecute(r ApiPostStopMessageLiveLocationRequest) (*StopMessageLiveLocationResponse, *http.Response, error)

	/*
	PostStopPoll stopPoll

	Use this method to stop a poll which was sent by the bot. On success, the stopped [Poll](https://core.telegram.org/bots/api/#poll) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostStopPollRequest
	*/
	PostStopPoll(ctx context.Context) ApiPostStopPollRequest

	// PostStopPollExecute executes the request
	//  @return StopPollResponse
	PostStopPollExecute(r ApiPostStopPollRequest) (*StopPollResponse, *http.Response, error)

	/*
	PostTransferBusinessAccountStars transferBusinessAccountStars

	Transfers Telegram Stars from the business account balance to the bot's balance. Requires the *can\_transfer\_stars* business bot right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostTransferBusinessAccountStarsRequest
	*/
	PostTransferBusinessAccountStars(ctx context.Context) ApiPostTransferBusinessAccountStarsRequest

	// PostTransferBusinessAccountStarsExecute executes the request
	//  @return TransferBusinessAccountStarsResponse
	PostTransferBusinessAccountStarsExecute(r ApiPostTransferBusinessAccountStarsRequest) (*TransferBusinessAccountStarsResponse, *http.Response, error)

	/*
	PostTransferGift transferGift

	Transfers an owned unique gift to another user. Requires the *can\_transfer\_and\_upgrade\_gifts* business bot right. Requires *can\_transfer\_stars* business bot right if the transfer is paid. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostTransferGiftRequest
	*/
	PostTransferGift(ctx context.Context) ApiPostTransferGiftRequest

	// PostTransferGiftExecute executes the request
	//  @return TransferGiftResponse
	PostTransferGiftExecute(r ApiPostTransferGiftRequest) (*TransferGiftResponse, *http.Response, error)

	/*
	PostUnbanChatMember unbanChatMember

	Use this method to unban a previously banned user in a supergroup or channel. The user will **not** return to the group or channel automatically, but will be able to join via link, etc. The bot must be an administrator for this to work. By default, this method guarantees that after the call the user is not a member of the chat, but will be able to join it. So if the user is a member of the chat they will also be **removed** from the chat. If you don't want this, use the parameter *only\_if\_banned*. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUnbanChatMemberRequest
	*/
	PostUnbanChatMember(ctx context.Context) ApiPostUnbanChatMemberRequest

	// PostUnbanChatMemberExecute executes the request
	//  @return UnbanChatMemberResponse
	PostUnbanChatMemberExecute(r ApiPostUnbanChatMemberRequest) (*UnbanChatMemberResponse, *http.Response, error)

	/*
	PostUnbanChatSenderChat unbanChatSenderChat

	Use this method to unban a previously banned channel chat in a supergroup or channel. The bot must be an administrator for this to work and must have the appropriate administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUnbanChatSenderChatRequest
	*/
	PostUnbanChatSenderChat(ctx context.Context) ApiPostUnbanChatSenderChatRequest

	// PostUnbanChatSenderChatExecute executes the request
	//  @return UnbanChatSenderChatResponse
	PostUnbanChatSenderChatExecute(r ApiPostUnbanChatSenderChatRequest) (*UnbanChatSenderChatResponse, *http.Response, error)

	/*
	PostUnhideGeneralForumTopic unhideGeneralForumTopic

	Use this method to unhide the 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUnhideGeneralForumTopicRequest
	*/
	PostUnhideGeneralForumTopic(ctx context.Context) ApiPostUnhideGeneralForumTopicRequest

	// PostUnhideGeneralForumTopicExecute executes the request
	//  @return UnhideGeneralForumTopicResponse
	PostUnhideGeneralForumTopicExecute(r ApiPostUnhideGeneralForumTopicRequest) (*UnhideGeneralForumTopicResponse, *http.Response, error)

	/*
	PostUnpinAllChatMessages unpinAllChatMessages

	Use this method to clear the list of pinned messages in a chat. If the chat is not a private chat, the bot must be an administrator in the chat for this to work and must have the 'can\_pin\_messages' administrator right in a supergroup or 'can\_edit\_messages' administrator right in a channel. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUnpinAllChatMessagesRequest
	*/
	PostUnpinAllChatMessages(ctx context.Context) ApiPostUnpinAllChatMessagesRequest

	// PostUnpinAllChatMessagesExecute executes the request
	//  @return UnpinAllChatMessagesResponse
	PostUnpinAllChatMessagesExecute(r ApiPostUnpinAllChatMessagesRequest) (*UnpinAllChatMessagesResponse, *http.Response, error)

	/*
	PostUnpinAllForumTopicMessages unpinAllForumTopicMessages

	Use this method to clear the list of pinned messages in a forum topic. The bot must be an administrator in the chat for this to work and must have the *can\_pin\_messages* administrator right in the supergroup. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUnpinAllForumTopicMessagesRequest
	*/
	PostUnpinAllForumTopicMessages(ctx context.Context) ApiPostUnpinAllForumTopicMessagesRequest

	// PostUnpinAllForumTopicMessagesExecute executes the request
	//  @return UnpinAllForumTopicMessagesResponse
	PostUnpinAllForumTopicMessagesExecute(r ApiPostUnpinAllForumTopicMessagesRequest) (*UnpinAllForumTopicMessagesResponse, *http.Response, error)

	/*
	PostUnpinAllGeneralForumTopicMessages unpinAllGeneralForumTopicMessages

	Use this method to clear the list of pinned messages in a General forum topic. The bot must be an administrator in the chat for this to work and must have the *can\_pin\_messages* administrator right in the supergroup. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUnpinAllGeneralForumTopicMessagesRequest
	*/
	PostUnpinAllGeneralForumTopicMessages(ctx context.Context) ApiPostUnpinAllGeneralForumTopicMessagesRequest

	// PostUnpinAllGeneralForumTopicMessagesExecute executes the request
	//  @return UnpinAllGeneralForumTopicMessagesResponse
	PostUnpinAllGeneralForumTopicMessagesExecute(r ApiPostUnpinAllGeneralForumTopicMessagesRequest) (*UnpinAllGeneralForumTopicMessagesResponse, *http.Response, error)

	/*
	PostUnpinChatMessage unpinChatMessage

	Use this method to remove a message from the list of pinned messages in a chat. If the chat is not a private chat, the bot must be an administrator in the chat for this to work and must have the 'can\_pin\_messages' administrator right in a supergroup or 'can\_edit\_messages' administrator right in a channel. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUnpinChatMessageRequest
	*/
	PostUnpinChatMessage(ctx context.Context) ApiPostUnpinChatMessageRequest

	// PostUnpinChatMessageExecute executes the request
	//  @return UnpinChatMessageResponse
	PostUnpinChatMessageExecute(r ApiPostUnpinChatMessageRequest) (*UnpinChatMessageResponse, *http.Response, error)

	/*
	PostUpgradeGift upgradeGift

	Upgrades a given regular gift to a unique gift. Requires the *can\_transfer\_and\_upgrade\_gifts* business bot right. Additionally requires the *can\_transfer\_stars* business bot right if the upgrade is paid. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUpgradeGiftRequest
	*/
	PostUpgradeGift(ctx context.Context) ApiPostUpgradeGiftRequest

	// PostUpgradeGiftExecute executes the request
	//  @return UpgradeGiftResponse
	PostUpgradeGiftExecute(r ApiPostUpgradeGiftRequest) (*UpgradeGiftResponse, *http.Response, error)

	/*
	PostUploadStickerFile uploadStickerFile

	Use this method to upload a file with a sticker for later use in the [createNewStickerSet](https://core.telegram.org/bots/api/#createnewstickerset), [addStickerToSet](https://core.telegram.org/bots/api/#addstickertoset), or [replaceStickerInSet](https://core.telegram.org/bots/api/#replacestickerinset) methods (the file can be used multiple times). Returns the uploaded [File](https://core.telegram.org/bots/api/#file) on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUploadStickerFileRequest
	*/
	PostUploadStickerFile(ctx context.Context) ApiPostUploadStickerFileRequest

	// PostUploadStickerFileExecute executes the request
	//  @return UploadStickerFileResponse
	PostUploadStickerFileExecute(r ApiPostUploadStickerFileRequest) (*UploadStickerFileResponse, *http.Response, error)

	/*
	PostVerifyChat verifyChat

	Verifies a chat [on behalf of the organization](https://telegram.org/verify#third-party-verification) which is represented by the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostVerifyChatRequest
	*/
	PostVerifyChat(ctx context.Context) ApiPostVerifyChatRequest

	// PostVerifyChatExecute executes the request
	//  @return VerifyChatResponse
	PostVerifyChatExecute(r ApiPostVerifyChatRequest) (*VerifyChatResponse, *http.Response, error)

	/*
	PostVerifyUser verifyUser

	Verifies a user [on behalf of the organization](https://telegram.org/verify#third-party-verification) which is represented by the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostVerifyUserRequest
	*/
	PostVerifyUser(ctx context.Context) ApiPostVerifyUserRequest

	// PostVerifyUserExecute executes the request
	//  @return VerifyUserResponse
	PostVerifyUserExecute(r ApiPostVerifyUserRequest) (*VerifyUserResponse, *http.Response, error)
}

// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiPostAddStickerToSetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	name *string
	sticker *InputSticker
}

// User identifier of sticker set owner
func (r ApiPostAddStickerToSetRequest) UserId(userId int32) ApiPostAddStickerToSetRequest {
	r.userId = &userId
	return r
}

// Sticker set name
func (r ApiPostAddStickerToSetRequest) Name(name string) ApiPostAddStickerToSetRequest {
	r.name = &name
	return r
}

func (r ApiPostAddStickerToSetRequest) Sticker(sticker InputSticker) ApiPostAddStickerToSetRequest {
	r.sticker = &sticker
	return r
}

func (r ApiPostAddStickerToSetRequest) Execute() (*AddStickerToSetResponse, *http.Response, error) {
	return r.ApiService.PostAddStickerToSetExecute(r)
}

/*
PostAddStickerToSet addStickerToSet

Use this method to add a new sticker to a set created by the bot. Emoji sticker sets can have up to 200 stickers. Other sticker sets can have up to 120 stickers. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostAddStickerToSetRequest
*/
func (a *DefaultAPIService) PostAddStickerToSet(ctx context.Context) ApiPostAddStickerToSetRequest {
	return ApiPostAddStickerToSetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AddStickerToSetResponse
func (a *DefaultAPIService) PostAddStickerToSetExecute(r ApiPostAddStickerToSetRequest) (*AddStickerToSetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AddStickerToSetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostAddStickerToSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addStickerToSet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.sticker == nil {
		return localVarReturnValue, nil, reportError("sticker is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "sticker", r.sticker, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAnswerCallbackQueryRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	callbackQueryId *string
	text *string
	showAlert *bool
	url *string
	cacheTime *int32
}

// Unique identifier for the query to be answered
func (r ApiPostAnswerCallbackQueryRequest) CallbackQueryId(callbackQueryId string) ApiPostAnswerCallbackQueryRequest {
	r.callbackQueryId = &callbackQueryId
	return r
}

// Text of the notification. If not specified, nothing will be shown to the user, 0-200 characters
func (r ApiPostAnswerCallbackQueryRequest) Text(text string) ApiPostAnswerCallbackQueryRequest {
	r.text = &text
	return r
}

// If *True*, an alert will be shown by the client instead of a notification at the top of the chat screen. Defaults to *false*.
func (r ApiPostAnswerCallbackQueryRequest) ShowAlert(showAlert bool) ApiPostAnswerCallbackQueryRequest {
	r.showAlert = &showAlert
	return r
}

// URL that will be opened by the user&#39;s client. If you have created a [Game](https://core.telegram.org/bots/api/#game) and accepted the conditions via [@BotFather](https://t.me/botfather), specify the URL that opens your game - note that this will only work if the query comes from a [*callback\\\\_game*](https://core.telegram.org/bots/api/#inlinekeyboardbutton) button.    Otherwise, you may use links like &#x60;t.me/your_bot?start&#x3D;XXXX&#x60; that open your bot with a parameter.
func (r ApiPostAnswerCallbackQueryRequest) Url(url string) ApiPostAnswerCallbackQueryRequest {
	r.url = &url
	return r
}

// The maximum amount of time in seconds that the result of the callback query may be cached client-side. Telegram apps will support caching starting in version 3.14. Defaults to 0.
func (r ApiPostAnswerCallbackQueryRequest) CacheTime(cacheTime int32) ApiPostAnswerCallbackQueryRequest {
	r.cacheTime = &cacheTime
	return r
}

func (r ApiPostAnswerCallbackQueryRequest) Execute() (*AnswerCallbackQueryResponse, *http.Response, error) {
	return r.ApiService.PostAnswerCallbackQueryExecute(r)
}

/*
PostAnswerCallbackQuery answerCallbackQuery

Use this method to send answers to callback queries sent from [inline keyboards](https://core.telegram.org/bots/features#inline-keyboards). The answer will be displayed to the user as a notification at the top of the chat screen or as an alert. On success, *True* is returned.

Alternatively, the user can be redirected to the specified Game URL. For this option to work, you must first create a game for your bot via [@BotFather](https://t.me/botfather) and accept the terms. Otherwise, you may use links like `t.me/your_bot?start=XXXX` that open your bot with a parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostAnswerCallbackQueryRequest
*/
func (a *DefaultAPIService) PostAnswerCallbackQuery(ctx context.Context) ApiPostAnswerCallbackQueryRequest {
	return ApiPostAnswerCallbackQueryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AnswerCallbackQueryResponse
func (a *DefaultAPIService) PostAnswerCallbackQueryExecute(r ApiPostAnswerCallbackQueryRequest) (*AnswerCallbackQueryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AnswerCallbackQueryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostAnswerCallbackQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/answerCallbackQuery"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.callbackQueryId == nil {
		return localVarReturnValue, nil, reportError("callbackQueryId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "callback_query_id", r.callbackQueryId, "", "")
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "text", r.text, "", "")
	}
	if r.showAlert != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "show_alert", r.showAlert, "", "")
	}
	if r.url != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "url", r.url, "", "")
	}
	if r.cacheTime != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "cache_time", r.cacheTime, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAnswerInlineQueryRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	inlineQueryId *string
	results *[]InlineQueryResult
	cacheTime *int32
	isPersonal *bool
	nextOffset *string
	button *InlineQueryResultsButton
}

// Unique identifier for the answered query
func (r ApiPostAnswerInlineQueryRequest) InlineQueryId(inlineQueryId string) ApiPostAnswerInlineQueryRequest {
	r.inlineQueryId = &inlineQueryId
	return r
}

// A JSON-serialized array of results for the inline query
func (r ApiPostAnswerInlineQueryRequest) Results(results []InlineQueryResult) ApiPostAnswerInlineQueryRequest {
	r.results = &results
	return r
}

// The maximum amount of time in seconds that the result of the inline query may be cached on the server. Defaults to 300.
func (r ApiPostAnswerInlineQueryRequest) CacheTime(cacheTime int32) ApiPostAnswerInlineQueryRequest {
	r.cacheTime = &cacheTime
	return r
}

// Pass *True* if results may be cached on the server side only for the user that sent the query. By default, results may be returned to any user who sends the same query.
func (r ApiPostAnswerInlineQueryRequest) IsPersonal(isPersonal bool) ApiPostAnswerInlineQueryRequest {
	r.isPersonal = &isPersonal
	return r
}

// Pass the offset that a client should send in the next query with the same text to receive more results. Pass an empty string if there are no more results or if you don&#39;t support pagination. Offset length can&#39;t exceed 64 bytes.
func (r ApiPostAnswerInlineQueryRequest) NextOffset(nextOffset string) ApiPostAnswerInlineQueryRequest {
	r.nextOffset = &nextOffset
	return r
}

func (r ApiPostAnswerInlineQueryRequest) Button(button InlineQueryResultsButton) ApiPostAnswerInlineQueryRequest {
	r.button = &button
	return r
}

func (r ApiPostAnswerInlineQueryRequest) Execute() (*AnswerInlineQueryResponse, *http.Response, error) {
	return r.ApiService.PostAnswerInlineQueryExecute(r)
}

/*
PostAnswerInlineQuery answerInlineQuery

Use this method to send answers to an inline query. On success, *True* is returned.  
No more than **50** results per query are allowed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostAnswerInlineQueryRequest
*/
func (a *DefaultAPIService) PostAnswerInlineQuery(ctx context.Context) ApiPostAnswerInlineQueryRequest {
	return ApiPostAnswerInlineQueryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AnswerInlineQueryResponse
func (a *DefaultAPIService) PostAnswerInlineQueryExecute(r ApiPostAnswerInlineQueryRequest) (*AnswerInlineQueryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AnswerInlineQueryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostAnswerInlineQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/answerInlineQuery"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inlineQueryId == nil {
		return localVarReturnValue, nil, reportError("inlineQueryId is required and must be specified")
	}
	if r.results == nil {
		return localVarReturnValue, nil, reportError("results is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "inline_query_id", r.inlineQueryId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "results", r.results, "", "csv")
	if r.cacheTime != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "cache_time", r.cacheTime, "", "")
	}
	if r.isPersonal != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_personal", r.isPersonal, "", "")
	}
	if r.nextOffset != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "next_offset", r.nextOffset, "", "")
	}
	if r.button != nil {
		paramJson, err := parameterToJson(*r.button)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("button", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAnswerPreCheckoutQueryRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	preCheckoutQueryId *string
	ok *bool
	errorMessage *string
}

// Unique identifier for the query to be answered
func (r ApiPostAnswerPreCheckoutQueryRequest) PreCheckoutQueryId(preCheckoutQueryId string) ApiPostAnswerPreCheckoutQueryRequest {
	r.preCheckoutQueryId = &preCheckoutQueryId
	return r
}

// Specify *True* if everything is alright (goods are available, etc.) and the bot is ready to proceed with the order. Use *False* if there are any problems.
func (r ApiPostAnswerPreCheckoutQueryRequest) Ok(ok bool) ApiPostAnswerPreCheckoutQueryRequest {
	r.ok = &ok
	return r
}

// Required if *ok* is *False*. Error message in human readable form that explains the reason for failure to proceed with the checkout (e.g. \\\&quot;Sorry, somebody just bought the last of our amazing black T-shirts while you were busy filling out your payment details. Please choose a different color or garment!\\\&quot;). Telegram will display this message to the user.
func (r ApiPostAnswerPreCheckoutQueryRequest) ErrorMessage(errorMessage string) ApiPostAnswerPreCheckoutQueryRequest {
	r.errorMessage = &errorMessage
	return r
}

func (r ApiPostAnswerPreCheckoutQueryRequest) Execute() (*AnswerPreCheckoutQueryResponse, *http.Response, error) {
	return r.ApiService.PostAnswerPreCheckoutQueryExecute(r)
}

/*
PostAnswerPreCheckoutQuery answerPreCheckoutQuery

Once the user has confirmed their payment and shipping details, the Bot API sends the final confirmation in the form of an [Update](https://core.telegram.org/bots/api/#update) with the field *pre\_checkout\_query*. Use this method to respond to such pre-checkout queries. On success, *True* is returned. **Note:** The Bot API must receive an answer within 10 seconds after the pre-checkout query was sent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostAnswerPreCheckoutQueryRequest
*/
func (a *DefaultAPIService) PostAnswerPreCheckoutQuery(ctx context.Context) ApiPostAnswerPreCheckoutQueryRequest {
	return ApiPostAnswerPreCheckoutQueryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AnswerPreCheckoutQueryResponse
func (a *DefaultAPIService) PostAnswerPreCheckoutQueryExecute(r ApiPostAnswerPreCheckoutQueryRequest) (*AnswerPreCheckoutQueryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AnswerPreCheckoutQueryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostAnswerPreCheckoutQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/answerPreCheckoutQuery"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.preCheckoutQueryId == nil {
		return localVarReturnValue, nil, reportError("preCheckoutQueryId is required and must be specified")
	}
	if r.ok == nil {
		return localVarReturnValue, nil, reportError("ok is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pre_checkout_query_id", r.preCheckoutQueryId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "ok", r.ok, "", "")
	if r.errorMessage != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "error_message", r.errorMessage, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAnswerShippingQueryRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	shippingQueryId *string
	ok *bool
	shippingOptions *[]ShippingOption
	errorMessage *string
}

// Unique identifier for the query to be answered
func (r ApiPostAnswerShippingQueryRequest) ShippingQueryId(shippingQueryId string) ApiPostAnswerShippingQueryRequest {
	r.shippingQueryId = &shippingQueryId
	return r
}

// Pass *True* if delivery to the specified address is possible and *False* if there are any problems (for example, if delivery to the specified address is not possible)
func (r ApiPostAnswerShippingQueryRequest) Ok(ok bool) ApiPostAnswerShippingQueryRequest {
	r.ok = &ok
	return r
}

// Required if *ok* is *True*. A JSON-serialized array of available shipping options.
func (r ApiPostAnswerShippingQueryRequest) ShippingOptions(shippingOptions []ShippingOption) ApiPostAnswerShippingQueryRequest {
	r.shippingOptions = &shippingOptions
	return r
}

// Required if *ok* is *False*. Error message in human readable form that explains why it is impossible to complete the order (e.g. “Sorry, delivery to your desired address is unavailable”). Telegram will display this message to the user.
func (r ApiPostAnswerShippingQueryRequest) ErrorMessage(errorMessage string) ApiPostAnswerShippingQueryRequest {
	r.errorMessage = &errorMessage
	return r
}

func (r ApiPostAnswerShippingQueryRequest) Execute() (*AnswerShippingQueryResponse, *http.Response, error) {
	return r.ApiService.PostAnswerShippingQueryExecute(r)
}

/*
PostAnswerShippingQuery answerShippingQuery

If you sent an invoice requesting a shipping address and the parameter *is\_flexible* was specified, the Bot API will send an [Update](https://core.telegram.org/bots/api/#update) with a *shipping\_query* field to the bot. Use this method to reply to shipping queries. On success, *True* is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostAnswerShippingQueryRequest
*/
func (a *DefaultAPIService) PostAnswerShippingQuery(ctx context.Context) ApiPostAnswerShippingQueryRequest {
	return ApiPostAnswerShippingQueryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AnswerShippingQueryResponse
func (a *DefaultAPIService) PostAnswerShippingQueryExecute(r ApiPostAnswerShippingQueryRequest) (*AnswerShippingQueryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AnswerShippingQueryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostAnswerShippingQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/answerShippingQuery"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shippingQueryId == nil {
		return localVarReturnValue, nil, reportError("shippingQueryId is required and must be specified")
	}
	if r.ok == nil {
		return localVarReturnValue, nil, reportError("ok is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "shipping_query_id", r.shippingQueryId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "ok", r.ok, "", "")
	if r.shippingOptions != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "shipping_options", r.shippingOptions, "", "csv")
	}
	if r.errorMessage != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "error_message", r.errorMessage, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAnswerWebAppQueryRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	webAppQueryId *string
	result *InlineQueryResult
}

// Unique identifier for the query to be answered
func (r ApiPostAnswerWebAppQueryRequest) WebAppQueryId(webAppQueryId string) ApiPostAnswerWebAppQueryRequest {
	r.webAppQueryId = &webAppQueryId
	return r
}

func (r ApiPostAnswerWebAppQueryRequest) Result(result InlineQueryResult) ApiPostAnswerWebAppQueryRequest {
	r.result = &result
	return r
}

func (r ApiPostAnswerWebAppQueryRequest) Execute() (*AnswerWebAppQueryResponse, *http.Response, error) {
	return r.ApiService.PostAnswerWebAppQueryExecute(r)
}

/*
PostAnswerWebAppQuery answerWebAppQuery

Use this method to set the result of an interaction with a [Web App](https://core.telegram.org/bots/webapps) and send a corresponding message on behalf of the user to the chat from which the query originated. On success, a [SentWebAppMessage](https://core.telegram.org/bots/api/#sentwebappmessage) object is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostAnswerWebAppQueryRequest
*/
func (a *DefaultAPIService) PostAnswerWebAppQuery(ctx context.Context) ApiPostAnswerWebAppQueryRequest {
	return ApiPostAnswerWebAppQueryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AnswerWebAppQueryResponse
func (a *DefaultAPIService) PostAnswerWebAppQueryExecute(r ApiPostAnswerWebAppQueryRequest) (*AnswerWebAppQueryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AnswerWebAppQueryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostAnswerWebAppQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/answerWebAppQuery"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.webAppQueryId == nil {
		return localVarReturnValue, nil, reportError("webAppQueryId is required and must be specified")
	}
	if r.result == nil {
		return localVarReturnValue, nil, reportError("result is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "web_app_query_id", r.webAppQueryId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "result", r.result, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostApproveChatJoinRequestRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	userId *int32
}

func (r ApiPostApproveChatJoinRequestRequest) ChatId(chatId SendMessageRequestChatId) ApiPostApproveChatJoinRequestRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the target user
func (r ApiPostApproveChatJoinRequestRequest) UserId(userId int32) ApiPostApproveChatJoinRequestRequest {
	r.userId = &userId
	return r
}

func (r ApiPostApproveChatJoinRequestRequest) Execute() (*ApproveChatJoinRequestResponse, *http.Response, error) {
	return r.ApiService.PostApproveChatJoinRequestExecute(r)
}

/*
PostApproveChatJoinRequest approveChatJoinRequest

Use this method to approve a chat join request. The bot must be an administrator in the chat for this to work and must have the *can\_invite\_users* administrator right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostApproveChatJoinRequestRequest
*/
func (a *DefaultAPIService) PostApproveChatJoinRequest(ctx context.Context) ApiPostApproveChatJoinRequestRequest {
	return ApiPostApproveChatJoinRequestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApproveChatJoinRequestResponse
func (a *DefaultAPIService) PostApproveChatJoinRequestExecute(r ApiPostApproveChatJoinRequestRequest) (*ApproveChatJoinRequestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApproveChatJoinRequestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostApproveChatJoinRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/approveChatJoinRequest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostBanChatMemberRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *BanChatMemberRequestChatId
	userId *int32
	untilDate *int32
	revokeMessages *bool
}

func (r ApiPostBanChatMemberRequest) ChatId(chatId BanChatMemberRequestChatId) ApiPostBanChatMemberRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the target user
func (r ApiPostBanChatMemberRequest) UserId(userId int32) ApiPostBanChatMemberRequest {
	r.userId = &userId
	return r
}

// Date when the user will be unbanned; Unix time. If user is banned for more than 366 days or less than 30 seconds from the current time they are considered to be banned forever. Applied for supergroups and channels only.
func (r ApiPostBanChatMemberRequest) UntilDate(untilDate int32) ApiPostBanChatMemberRequest {
	r.untilDate = &untilDate
	return r
}

// Pass *True* to delete all messages from the chat for the user that is being removed. If *False*, the user will be able to see messages in the group that were sent before the user was removed. Always *True* for supergroups and channels.
func (r ApiPostBanChatMemberRequest) RevokeMessages(revokeMessages bool) ApiPostBanChatMemberRequest {
	r.revokeMessages = &revokeMessages
	return r
}

func (r ApiPostBanChatMemberRequest) Execute() (*BanChatMemberResponse, *http.Response, error) {
	return r.ApiService.PostBanChatMemberExecute(r)
}

/*
PostBanChatMember banChatMember

Use this method to ban a user in a group, a supergroup or a channel. In the case of supergroups and channels, the user will not be able to return to the chat on their own using invite links, etc., unless [unbanned](https://core.telegram.org/bots/api/#unbanchatmember) first. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostBanChatMemberRequest
*/
func (a *DefaultAPIService) PostBanChatMember(ctx context.Context) ApiPostBanChatMemberRequest {
	return ApiPostBanChatMemberRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BanChatMemberResponse
func (a *DefaultAPIService) PostBanChatMemberExecute(r ApiPostBanChatMemberRequest) (*BanChatMemberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BanChatMemberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostBanChatMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/banChatMember"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	if r.untilDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "until_date", r.untilDate, "", "")
	}
	if r.revokeMessages != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "revoke_messages", r.revokeMessages, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostBanChatSenderChatRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	senderChatId *int32
}

func (r ApiPostBanChatSenderChatRequest) ChatId(chatId SendMessageRequestChatId) ApiPostBanChatSenderChatRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the target sender chat
func (r ApiPostBanChatSenderChatRequest) SenderChatId(senderChatId int32) ApiPostBanChatSenderChatRequest {
	r.senderChatId = &senderChatId
	return r
}

func (r ApiPostBanChatSenderChatRequest) Execute() (*BanChatSenderChatResponse, *http.Response, error) {
	return r.ApiService.PostBanChatSenderChatExecute(r)
}

/*
PostBanChatSenderChat banChatSenderChat

Use this method to ban a channel chat in a supergroup or a channel. Until the chat is [unbanned](https://core.telegram.org/bots/api/#unbanchatsenderchat), the owner of the banned chat won't be able to send messages on behalf of **any of their channels**. The bot must be an administrator in the supergroup or channel for this to work and must have the appropriate administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostBanChatSenderChatRequest
*/
func (a *DefaultAPIService) PostBanChatSenderChat(ctx context.Context) ApiPostBanChatSenderChatRequest {
	return ApiPostBanChatSenderChatRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BanChatSenderChatResponse
func (a *DefaultAPIService) PostBanChatSenderChatExecute(r ApiPostBanChatSenderChatRequest) (*BanChatSenderChatResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BanChatSenderChatResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostBanChatSenderChat")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/banChatSenderChat"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.senderChatId == nil {
		return localVarReturnValue, nil, reportError("senderChatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "sender_chat_id", r.senderChatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCloseRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiPostCloseRequest) Execute() (*CloseResponse, *http.Response, error) {
	return r.ApiService.PostCloseExecute(r)
}

/*
PostClose close

Use this method to close the bot instance before moving it from one local server to another. You need to delete the webhook before calling this method to ensure that the bot isn't launched again after server restart. The method will return error 429 in the first 10 minutes after the bot is launched. Returns *True* on success. Requires no parameters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCloseRequest
*/
func (a *DefaultAPIService) PostClose(ctx context.Context) ApiPostCloseRequest {
	return ApiPostCloseRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CloseResponse
func (a *DefaultAPIService) PostCloseExecute(r ApiPostCloseRequest) (*CloseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CloseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostClose")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/close"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCloseForumTopicRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *BotCommandScopeChatChatId
	messageThreadId *int32
}

func (r ApiPostCloseForumTopicRequest) ChatId(chatId BotCommandScopeChatChatId) ApiPostCloseForumTopicRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier for the target message thread of the forum topic
func (r ApiPostCloseForumTopicRequest) MessageThreadId(messageThreadId int32) ApiPostCloseForumTopicRequest {
	r.messageThreadId = &messageThreadId
	return r
}

func (r ApiPostCloseForumTopicRequest) Execute() (*CloseForumTopicResponse, *http.Response, error) {
	return r.ApiService.PostCloseForumTopicExecute(r)
}

/*
PostCloseForumTopic closeForumTopic

Use this method to close an open topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights, unless it is the creator of the topic. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCloseForumTopicRequest
*/
func (a *DefaultAPIService) PostCloseForumTopic(ctx context.Context) ApiPostCloseForumTopicRequest {
	return ApiPostCloseForumTopicRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CloseForumTopicResponse
func (a *DefaultAPIService) PostCloseForumTopicExecute(r ApiPostCloseForumTopicRequest) (*CloseForumTopicResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CloseForumTopicResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostCloseForumTopic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/closeForumTopic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.messageThreadId == nil {
		return localVarReturnValue, nil, reportError("messageThreadId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCloseGeneralForumTopicRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *BotCommandScopeChatChatId
}

func (r ApiPostCloseGeneralForumTopicRequest) ChatId(chatId BotCommandScopeChatChatId) ApiPostCloseGeneralForumTopicRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostCloseGeneralForumTopicRequest) Execute() (*CloseGeneralForumTopicResponse, *http.Response, error) {
	return r.ApiService.PostCloseGeneralForumTopicExecute(r)
}

/*
PostCloseGeneralForumTopic closeGeneralForumTopic

Use this method to close an open 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCloseGeneralForumTopicRequest
*/
func (a *DefaultAPIService) PostCloseGeneralForumTopic(ctx context.Context) ApiPostCloseGeneralForumTopicRequest {
	return ApiPostCloseGeneralForumTopicRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CloseGeneralForumTopicResponse
func (a *DefaultAPIService) PostCloseGeneralForumTopicExecute(r ApiPostCloseGeneralForumTopicRequest) (*CloseGeneralForumTopicResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CloseGeneralForumTopicResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostCloseGeneralForumTopic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/closeGeneralForumTopic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostConvertGiftToStarsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	ownedGiftId *string
}

// Unique identifier of the business connection
func (r ApiPostConvertGiftToStarsRequest) BusinessConnectionId(businessConnectionId string) ApiPostConvertGiftToStarsRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier of the regular gift that should be converted to Telegram Stars
func (r ApiPostConvertGiftToStarsRequest) OwnedGiftId(ownedGiftId string) ApiPostConvertGiftToStarsRequest {
	r.ownedGiftId = &ownedGiftId
	return r
}

func (r ApiPostConvertGiftToStarsRequest) Execute() (*ConvertGiftToStarsResponse, *http.Response, error) {
	return r.ApiService.PostConvertGiftToStarsExecute(r)
}

/*
PostConvertGiftToStars convertGiftToStars

Converts a given regular gift to Telegram Stars. Requires the *can\_convert\_gifts\_to\_stars* business bot right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostConvertGiftToStarsRequest
*/
func (a *DefaultAPIService) PostConvertGiftToStars(ctx context.Context) ApiPostConvertGiftToStarsRequest {
	return ApiPostConvertGiftToStarsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConvertGiftToStarsResponse
func (a *DefaultAPIService) PostConvertGiftToStarsExecute(r ApiPostConvertGiftToStarsRequest) (*ConvertGiftToStarsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConvertGiftToStarsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostConvertGiftToStars")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/convertGiftToStars"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.ownedGiftId == nil {
		return localVarReturnValue, nil, reportError("ownedGiftId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "owned_gift_id", r.ownedGiftId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCopyMessageRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	fromChatId *ForwardMessageRequestFromChatId
	messageId *int32
	messageThreadId *int32
	videoStartTimestamp *int32
	caption *string
	parseMode *string
	captionEntities *[]MessageEntity
	showCaptionAboveMedia *bool
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	replyParameters *ReplyParameters
	replyMarkup *SendMessageRequestReplyMarkup
}

func (r ApiPostCopyMessageRequest) ChatId(chatId SendMessageRequestChatId) ApiPostCopyMessageRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostCopyMessageRequest) FromChatId(fromChatId ForwardMessageRequestFromChatId) ApiPostCopyMessageRequest {
	r.fromChatId = &fromChatId
	return r
}

// Message identifier in the chat specified in *from\\\\_chat\\\\_id*
func (r ApiPostCopyMessageRequest) MessageId(messageId int32) ApiPostCopyMessageRequest {
	r.messageId = &messageId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiPostCopyMessageRequest) MessageThreadId(messageThreadId int32) ApiPostCopyMessageRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// New start timestamp for the copied video in the message
func (r ApiPostCopyMessageRequest) VideoStartTimestamp(videoStartTimestamp int32) ApiPostCopyMessageRequest {
	r.videoStartTimestamp = &videoStartTimestamp
	return r
}

// New caption for media, 0-1024 characters after entities parsing. If not specified, the original caption is kept
func (r ApiPostCopyMessageRequest) Caption(caption string) ApiPostCopyMessageRequest {
	r.caption = &caption
	return r
}

// Mode for parsing entities in the new caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiPostCopyMessageRequest) ParseMode(parseMode string) ApiPostCopyMessageRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in the new caption, which can be specified instead of *parse\\\\_mode*
func (r ApiPostCopyMessageRequest) CaptionEntities(captionEntities []MessageEntity) ApiPostCopyMessageRequest {
	r.captionEntities = &captionEntities
	return r
}

// Pass *True*, if the caption must be shown above the message media. Ignored if a new caption isn&#39;t specified.
func (r ApiPostCopyMessageRequest) ShowCaptionAboveMedia(showCaptionAboveMedia bool) ApiPostCopyMessageRequest {
	r.showCaptionAboveMedia = &showCaptionAboveMedia
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiPostCopyMessageRequest) DisableNotification(disableNotification bool) ApiPostCopyMessageRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiPostCopyMessageRequest) ProtectContent(protectContent bool) ApiPostCopyMessageRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiPostCopyMessageRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiPostCopyMessageRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

func (r ApiPostCopyMessageRequest) ReplyParameters(replyParameters ReplyParameters) ApiPostCopyMessageRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiPostCopyMessageRequest) ReplyMarkup(replyMarkup SendMessageRequestReplyMarkup) ApiPostCopyMessageRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostCopyMessageRequest) Execute() (*CopyMessageResponse, *http.Response, error) {
	return r.ApiService.PostCopyMessageExecute(r)
}

/*
PostCopyMessage copyMessage

Use this method to copy messages of any kind. Service messages, paid media messages, giveaway messages, giveaway winners messages, and invoice messages can't be copied. A quiz [poll](https://core.telegram.org/bots/api/#poll) can be copied only if the value of the field *correct\_option\_id* is known to the bot. The method is analogous to the method [forwardMessage](https://core.telegram.org/bots/api/#forwardmessage), but the copied message doesn't have a link to the original message. Returns the [MessageId](https://core.telegram.org/bots/api/#messageid) of the sent message on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCopyMessageRequest
*/
func (a *DefaultAPIService) PostCopyMessage(ctx context.Context) ApiPostCopyMessageRequest {
	return ApiPostCopyMessageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CopyMessageResponse
func (a *DefaultAPIService) PostCopyMessageExecute(r ApiPostCopyMessageRequest) (*CopyMessageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CopyMessageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostCopyMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/copyMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.fromChatId == nil {
		return localVarReturnValue, nil, reportError("fromChatId is required and must be specified")
	}
	if r.messageId == nil {
		return localVarReturnValue, nil, reportError("messageId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "from_chat_id", r.fromChatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	if r.videoStartTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "video_start_timestamp", r.videoStartTimestamp, "", "")
	}
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption", r.caption, "", "")
	}
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.captionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption_entities", r.captionEntities, "", "csv")
	}
	if r.showCaptionAboveMedia != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "show_caption_above_media", r.showCaptionAboveMedia, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCopyMessagesRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	fromChatId *ForwardMessagesRequestFromChatId
	messageIds *[]int32
	messageThreadId *int32
	disableNotification *bool
	protectContent *bool
	removeCaption *bool
}

func (r ApiPostCopyMessagesRequest) ChatId(chatId SendMessageRequestChatId) ApiPostCopyMessagesRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostCopyMessagesRequest) FromChatId(fromChatId ForwardMessagesRequestFromChatId) ApiPostCopyMessagesRequest {
	r.fromChatId = &fromChatId
	return r
}

// A JSON-serialized list of 1-100 identifiers of messages in the chat *from\\\\_chat\\\\_id* to copy. The identifiers must be specified in a strictly increasing order.
func (r ApiPostCopyMessagesRequest) MessageIds(messageIds []int32) ApiPostCopyMessagesRequest {
	r.messageIds = &messageIds
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiPostCopyMessagesRequest) MessageThreadId(messageThreadId int32) ApiPostCopyMessagesRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Sends the messages [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiPostCopyMessagesRequest) DisableNotification(disableNotification bool) ApiPostCopyMessagesRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent messages from forwarding and saving
func (r ApiPostCopyMessagesRequest) ProtectContent(protectContent bool) ApiPostCopyMessagesRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to copy the messages without their captions
func (r ApiPostCopyMessagesRequest) RemoveCaption(removeCaption bool) ApiPostCopyMessagesRequest {
	r.removeCaption = &removeCaption
	return r
}

func (r ApiPostCopyMessagesRequest) Execute() (*CopyMessagesResponse, *http.Response, error) {
	return r.ApiService.PostCopyMessagesExecute(r)
}

/*
PostCopyMessages copyMessages

Use this method to copy messages of any kind. If some of the specified messages can't be found or copied, they are skipped. Service messages, paid media messages, giveaway messages, giveaway winners messages, and invoice messages can't be copied. A quiz [poll](https://core.telegram.org/bots/api/#poll) can be copied only if the value of the field *correct\_option\_id* is known to the bot. The method is analogous to the method [forwardMessages](https://core.telegram.org/bots/api/#forwardmessages), but the copied messages don't have a link to the original message. Album grouping is kept for copied messages. On success, an array of [MessageId](https://core.telegram.org/bots/api/#messageid) of the sent messages is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCopyMessagesRequest
*/
func (a *DefaultAPIService) PostCopyMessages(ctx context.Context) ApiPostCopyMessagesRequest {
	return ApiPostCopyMessagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CopyMessagesResponse
func (a *DefaultAPIService) PostCopyMessagesExecute(r ApiPostCopyMessagesRequest) (*CopyMessagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CopyMessagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostCopyMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/copyMessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.fromChatId == nil {
		return localVarReturnValue, nil, reportError("fromChatId is required and must be specified")
	}
	if r.messageIds == nil {
		return localVarReturnValue, nil, reportError("messageIds is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "from_chat_id", r.fromChatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_ids", r.messageIds, "", "csv")
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.removeCaption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "remove_caption", r.removeCaption, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCreateChatInviteLinkRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	name *string
	expireDate *int32
	memberLimit *int32
	createsJoinRequest *bool
}

func (r ApiPostCreateChatInviteLinkRequest) ChatId(chatId SendMessageRequestChatId) ApiPostCreateChatInviteLinkRequest {
	r.chatId = &chatId
	return r
}

// Invite link name; 0-32 characters
func (r ApiPostCreateChatInviteLinkRequest) Name(name string) ApiPostCreateChatInviteLinkRequest {
	r.name = &name
	return r
}

// Point in time (Unix timestamp) when the link will expire
func (r ApiPostCreateChatInviteLinkRequest) ExpireDate(expireDate int32) ApiPostCreateChatInviteLinkRequest {
	r.expireDate = &expireDate
	return r
}

// The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999
func (r ApiPostCreateChatInviteLinkRequest) MemberLimit(memberLimit int32) ApiPostCreateChatInviteLinkRequest {
	r.memberLimit = &memberLimit
	return r
}

// *True*, if users joining the chat via the link need to be approved by chat administrators. If *True*, *member\\\\_limit* can&#39;t be specified
func (r ApiPostCreateChatInviteLinkRequest) CreatesJoinRequest(createsJoinRequest bool) ApiPostCreateChatInviteLinkRequest {
	r.createsJoinRequest = &createsJoinRequest
	return r
}

func (r ApiPostCreateChatInviteLinkRequest) Execute() (*CreateChatInviteLinkResponse, *http.Response, error) {
	return r.ApiService.PostCreateChatInviteLinkExecute(r)
}

/*
PostCreateChatInviteLink createChatInviteLink

Use this method to create an additional invite link for a chat. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. The link can be revoked using the method [revokeChatInviteLink](https://core.telegram.org/bots/api/#revokechatinvitelink). Returns the new invite link as [ChatInviteLink](https://core.telegram.org/bots/api/#chatinvitelink) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCreateChatInviteLinkRequest
*/
func (a *DefaultAPIService) PostCreateChatInviteLink(ctx context.Context) ApiPostCreateChatInviteLinkRequest {
	return ApiPostCreateChatInviteLinkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateChatInviteLinkResponse
func (a *DefaultAPIService) PostCreateChatInviteLinkExecute(r ApiPostCreateChatInviteLinkRequest) (*CreateChatInviteLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateChatInviteLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostCreateChatInviteLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/createChatInviteLink"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	}
	if r.expireDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "expire_date", r.expireDate, "", "")
	}
	if r.memberLimit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "member_limit", r.memberLimit, "", "")
	}
	if r.createsJoinRequest != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "creates_join_request", r.createsJoinRequest, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCreateChatSubscriptionInviteLinkRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *CreateChatSubscriptionInviteLinkRequestChatId
	subscriptionPeriod *int32
	subscriptionPrice *int32
	name *string
}

func (r ApiPostCreateChatSubscriptionInviteLinkRequest) ChatId(chatId CreateChatSubscriptionInviteLinkRequestChatId) ApiPostCreateChatSubscriptionInviteLinkRequest {
	r.chatId = &chatId
	return r
}

// The number of seconds the subscription will be active for before the next payment. Currently, it must always be 2592000 (30 days).
func (r ApiPostCreateChatSubscriptionInviteLinkRequest) SubscriptionPeriod(subscriptionPeriod int32) ApiPostCreateChatSubscriptionInviteLinkRequest {
	r.subscriptionPeriod = &subscriptionPeriod
	return r
}

// The amount of Telegram Stars a user must pay initially and after each subsequent subscription period to be a member of the chat; 1-10000
func (r ApiPostCreateChatSubscriptionInviteLinkRequest) SubscriptionPrice(subscriptionPrice int32) ApiPostCreateChatSubscriptionInviteLinkRequest {
	r.subscriptionPrice = &subscriptionPrice
	return r
}

// Invite link name; 0-32 characters
func (r ApiPostCreateChatSubscriptionInviteLinkRequest) Name(name string) ApiPostCreateChatSubscriptionInviteLinkRequest {
	r.name = &name
	return r
}

func (r ApiPostCreateChatSubscriptionInviteLinkRequest) Execute() (*CreateChatSubscriptionInviteLinkResponse, *http.Response, error) {
	return r.ApiService.PostCreateChatSubscriptionInviteLinkExecute(r)
}

/*
PostCreateChatSubscriptionInviteLink createChatSubscriptionInviteLink

Use this method to create a [subscription invite link](https://telegram.org/blog/superchannels-star-reactions-subscriptions#star-subscriptions) for a channel chat. The bot must have the *can\_invite\_users* administrator rights. The link can be edited using the method [editChatSubscriptionInviteLink](https://core.telegram.org/bots/api/#editchatsubscriptioninvitelink) or revoked using the method [revokeChatInviteLink](https://core.telegram.org/bots/api/#revokechatinvitelink). Returns the new invite link as a [ChatInviteLink](https://core.telegram.org/bots/api/#chatinvitelink) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCreateChatSubscriptionInviteLinkRequest
*/
func (a *DefaultAPIService) PostCreateChatSubscriptionInviteLink(ctx context.Context) ApiPostCreateChatSubscriptionInviteLinkRequest {
	return ApiPostCreateChatSubscriptionInviteLinkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateChatSubscriptionInviteLinkResponse
func (a *DefaultAPIService) PostCreateChatSubscriptionInviteLinkExecute(r ApiPostCreateChatSubscriptionInviteLinkRequest) (*CreateChatSubscriptionInviteLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateChatSubscriptionInviteLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostCreateChatSubscriptionInviteLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/createChatSubscriptionInviteLink"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.subscriptionPeriod == nil {
		return localVarReturnValue, nil, reportError("subscriptionPeriod is required and must be specified")
	}
	if r.subscriptionPrice == nil {
		return localVarReturnValue, nil, reportError("subscriptionPrice is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "subscription_period", r.subscriptionPeriod, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "subscription_price", r.subscriptionPrice, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCreateForumTopicRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *BotCommandScopeChatChatId
	name *string
	iconColor *int32
	iconCustomEmojiId *string
}

func (r ApiPostCreateForumTopicRequest) ChatId(chatId BotCommandScopeChatChatId) ApiPostCreateForumTopicRequest {
	r.chatId = &chatId
	return r
}

// Topic name, 1-128 characters
func (r ApiPostCreateForumTopicRequest) Name(name string) ApiPostCreateForumTopicRequest {
	r.name = &name
	return r
}

// Color of the topic icon in RGB format. Currently, must be one of 7322096 (0x6FB9F0), 16766590 (0xFFD67E), 13338331 (0xCB86DB), 9367192 (0x8EEE98), 16749490 (0xFF93B2), or 16478047 (0xFB6F5F)
func (r ApiPostCreateForumTopicRequest) IconColor(iconColor int32) ApiPostCreateForumTopicRequest {
	r.iconColor = &iconColor
	return r
}

// Unique identifier of the custom emoji shown as the topic icon. Use [getForumTopicIconStickers](https://core.telegram.org/bots/api/#getforumtopiciconstickers) to get all allowed custom emoji identifiers.
func (r ApiPostCreateForumTopicRequest) IconCustomEmojiId(iconCustomEmojiId string) ApiPostCreateForumTopicRequest {
	r.iconCustomEmojiId = &iconCustomEmojiId
	return r
}

func (r ApiPostCreateForumTopicRequest) Execute() (*CreateForumTopicResponse, *http.Response, error) {
	return r.ApiService.PostCreateForumTopicExecute(r)
}

/*
PostCreateForumTopic createForumTopic

Use this method to create a topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. Returns information about the created topic as a [ForumTopic](https://core.telegram.org/bots/api/#forumtopic) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCreateForumTopicRequest
*/
func (a *DefaultAPIService) PostCreateForumTopic(ctx context.Context) ApiPostCreateForumTopicRequest {
	return ApiPostCreateForumTopicRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateForumTopicResponse
func (a *DefaultAPIService) PostCreateForumTopicExecute(r ApiPostCreateForumTopicRequest) (*CreateForumTopicResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateForumTopicResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostCreateForumTopic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/createForumTopic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if strlen(*r.name) < 1 {
		return localVarReturnValue, nil, reportError("name must have at least 1 elements")
	}
	if strlen(*r.name) > 128 {
		return localVarReturnValue, nil, reportError("name must have less than 128 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	if r.iconColor != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icon_color", r.iconColor, "", "")
	}
	if r.iconCustomEmojiId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icon_custom_emoji_id", r.iconCustomEmojiId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCreateInvoiceLinkRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	title *string
	description *string
	payload *string
	currency *string
	prices *[]LabeledPrice
	businessConnectionId *string
	providerToken *string
	subscriptionPeriod *int32
	maxTipAmount *int32
	suggestedTipAmounts *[]int32
	providerData *string
	photoUrl *string
	photoSize *int32
	photoWidth *int32
	photoHeight *int32
	needName *bool
	needPhoneNumber *bool
	needEmail *bool
	needShippingAddress *bool
	sendPhoneNumberToProvider *bool
	sendEmailToProvider *bool
	isFlexible *bool
}

// Product name, 1-32 characters
func (r ApiPostCreateInvoiceLinkRequest) Title(title string) ApiPostCreateInvoiceLinkRequest {
	r.title = &title
	return r
}

// Product description, 1-255 characters
func (r ApiPostCreateInvoiceLinkRequest) Description(description string) ApiPostCreateInvoiceLinkRequest {
	r.description = &description
	return r
}

// Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use it for your internal processes.
func (r ApiPostCreateInvoiceLinkRequest) Payload(payload string) ApiPostCreateInvoiceLinkRequest {
	r.payload = &payload
	return r
}

// Three-letter ISO 4217 currency code, see [more on currencies](https://core.telegram.org/bots/payments#supported-currencies). Pass “XTR” for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiPostCreateInvoiceLinkRequest) Currency(currency string) ApiPostCreateInvoiceLinkRequest {
	r.currency = &currency
	return r
}

// Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.). Must contain exactly one item for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiPostCreateInvoiceLinkRequest) Prices(prices []LabeledPrice) ApiPostCreateInvoiceLinkRequest {
	r.prices = &prices
	return r
}

// Unique identifier of the business connection on behalf of which the link will be created. For payments in [Telegram Stars](https://t.me/BotNews/90) only.
func (r ApiPostCreateInvoiceLinkRequest) BusinessConnectionId(businessConnectionId string) ApiPostCreateInvoiceLinkRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Payment provider token, obtained via [@BotFather](https://t.me/botfather). Pass an empty string for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiPostCreateInvoiceLinkRequest) ProviderToken(providerToken string) ApiPostCreateInvoiceLinkRequest {
	r.providerToken = &providerToken
	return r
}

// The number of seconds the subscription will be active for before the next payment. The currency must be set to “XTR” (Telegram Stars) if the parameter is used. Currently, it must always be 2592000 (30 days) if specified. Any number of subscriptions can be active for a given bot at the same time, including multiple concurrent subscriptions from the same user. Subscription price must no exceed 10000 Telegram Stars.
func (r ApiPostCreateInvoiceLinkRequest) SubscriptionPeriod(subscriptionPeriod int32) ApiPostCreateInvoiceLinkRequest {
	r.subscriptionPeriod = &subscriptionPeriod
	return r
}

// The maximum accepted amount for tips in the *smallest units* of the currency (integer, **not** float/double). For example, for a maximum tip of &#x60;US$ 1.45&#x60; pass &#x60;max_tip_amount &#x3D; 145&#x60;. See the *exp* parameter in [currencies.json](https://core.telegram.org/bots/payments/currencies.json), it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0. Not supported for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiPostCreateInvoiceLinkRequest) MaxTipAmount(maxTipAmount int32) ApiPostCreateInvoiceLinkRequest {
	r.maxTipAmount = &maxTipAmount
	return r
}

// A JSON-serialized array of suggested amounts of tips in the *smallest units* of the currency (integer, **not** float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed *max\\\\_tip\\\\_amount*.
func (r ApiPostCreateInvoiceLinkRequest) SuggestedTipAmounts(suggestedTipAmounts []int32) ApiPostCreateInvoiceLinkRequest {
	r.suggestedTipAmounts = &suggestedTipAmounts
	return r
}

// JSON-serialized data about the invoice, which will be shared with the payment provider. A detailed description of required fields should be provided by the payment provider.
func (r ApiPostCreateInvoiceLinkRequest) ProviderData(providerData string) ApiPostCreateInvoiceLinkRequest {
	r.providerData = &providerData
	return r
}

// URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service.
func (r ApiPostCreateInvoiceLinkRequest) PhotoUrl(photoUrl string) ApiPostCreateInvoiceLinkRequest {
	r.photoUrl = &photoUrl
	return r
}

// Photo size in bytes
func (r ApiPostCreateInvoiceLinkRequest) PhotoSize(photoSize int32) ApiPostCreateInvoiceLinkRequest {
	r.photoSize = &photoSize
	return r
}

// Photo width
func (r ApiPostCreateInvoiceLinkRequest) PhotoWidth(photoWidth int32) ApiPostCreateInvoiceLinkRequest {
	r.photoWidth = &photoWidth
	return r
}

// Photo height
func (r ApiPostCreateInvoiceLinkRequest) PhotoHeight(photoHeight int32) ApiPostCreateInvoiceLinkRequest {
	r.photoHeight = &photoHeight
	return r
}

// Pass *True* if you require the user&#39;s full name to complete the order. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiPostCreateInvoiceLinkRequest) NeedName(needName bool) ApiPostCreateInvoiceLinkRequest {
	r.needName = &needName
	return r
}

// Pass *True* if you require the user&#39;s phone number to complete the order. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiPostCreateInvoiceLinkRequest) NeedPhoneNumber(needPhoneNumber bool) ApiPostCreateInvoiceLinkRequest {
	r.needPhoneNumber = &needPhoneNumber
	return r
}

// Pass *True* if you require the user&#39;s email address to complete the order. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiPostCreateInvoiceLinkRequest) NeedEmail(needEmail bool) ApiPostCreateInvoiceLinkRequest {
	r.needEmail = &needEmail
	return r
}

// Pass *True* if you require the user&#39;s shipping address to complete the order. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiPostCreateInvoiceLinkRequest) NeedShippingAddress(needShippingAddress bool) ApiPostCreateInvoiceLinkRequest {
	r.needShippingAddress = &needShippingAddress
	return r
}

// Pass *True* if the user&#39;s phone number should be sent to the provider. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiPostCreateInvoiceLinkRequest) SendPhoneNumberToProvider(sendPhoneNumberToProvider bool) ApiPostCreateInvoiceLinkRequest {
	r.sendPhoneNumberToProvider = &sendPhoneNumberToProvider
	return r
}

// Pass *True* if the user&#39;s email address should be sent to the provider. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiPostCreateInvoiceLinkRequest) SendEmailToProvider(sendEmailToProvider bool) ApiPostCreateInvoiceLinkRequest {
	r.sendEmailToProvider = &sendEmailToProvider
	return r
}

// Pass *True* if the final price depends on the shipping method. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiPostCreateInvoiceLinkRequest) IsFlexible(isFlexible bool) ApiPostCreateInvoiceLinkRequest {
	r.isFlexible = &isFlexible
	return r
}

func (r ApiPostCreateInvoiceLinkRequest) Execute() (*CreateInvoiceLinkResponse, *http.Response, error) {
	return r.ApiService.PostCreateInvoiceLinkExecute(r)
}

/*
PostCreateInvoiceLink createInvoiceLink

Use this method to create a link for an invoice. Returns the created invoice link as *String* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCreateInvoiceLinkRequest
*/
func (a *DefaultAPIService) PostCreateInvoiceLink(ctx context.Context) ApiPostCreateInvoiceLinkRequest {
	return ApiPostCreateInvoiceLinkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateInvoiceLinkResponse
func (a *DefaultAPIService) PostCreateInvoiceLinkExecute(r ApiPostCreateInvoiceLinkRequest) (*CreateInvoiceLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateInvoiceLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostCreateInvoiceLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/createInvoiceLink"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if strlen(*r.title) < 1 {
		return localVarReturnValue, nil, reportError("title must have at least 1 elements")
	}
	if strlen(*r.title) > 32 {
		return localVarReturnValue, nil, reportError("title must have less than 32 elements")
	}
	if r.description == nil {
		return localVarReturnValue, nil, reportError("description is required and must be specified")
	}
	if strlen(*r.description) < 1 {
		return localVarReturnValue, nil, reportError("description must have at least 1 elements")
	}
	if strlen(*r.description) > 255 {
		return localVarReturnValue, nil, reportError("description must have less than 255 elements")
	}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}
	if r.currency == nil {
		return localVarReturnValue, nil, reportError("currency is required and must be specified")
	}
	if r.prices == nil {
		return localVarReturnValue, nil, reportError("prices is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "payload", r.payload, "", "")
	if r.providerToken != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "provider_token", r.providerToken, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "currency", r.currency, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "prices", r.prices, "", "csv")
	if r.subscriptionPeriod != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "subscription_period", r.subscriptionPeriod, "", "")
	}
	if r.maxTipAmount != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "max_tip_amount", r.maxTipAmount, "", "")
	}
	if r.suggestedTipAmounts != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "suggested_tip_amounts", r.suggestedTipAmounts, "", "csv")
	}
	if r.providerData != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "provider_data", r.providerData, "", "")
	}
	if r.photoUrl != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "photo_url", r.photoUrl, "", "")
	}
	if r.photoSize != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "photo_size", r.photoSize, "", "")
	}
	if r.photoWidth != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "photo_width", r.photoWidth, "", "")
	}
	if r.photoHeight != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "photo_height", r.photoHeight, "", "")
	}
	if r.needName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "need_name", r.needName, "", "")
	}
	if r.needPhoneNumber != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "need_phone_number", r.needPhoneNumber, "", "")
	}
	if r.needEmail != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "need_email", r.needEmail, "", "")
	}
	if r.needShippingAddress != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "need_shipping_address", r.needShippingAddress, "", "")
	}
	if r.sendPhoneNumberToProvider != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "send_phone_number_to_provider", r.sendPhoneNumberToProvider, "", "")
	}
	if r.sendEmailToProvider != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "send_email_to_provider", r.sendEmailToProvider, "", "")
	}
	if r.isFlexible != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_flexible", r.isFlexible, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCreateNewStickerSetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	name *string
	title *string
	stickers *[]InputSticker
	stickerType *string
	needsRepainting *bool
}

// User identifier of created sticker set owner
func (r ApiPostCreateNewStickerSetRequest) UserId(userId int32) ApiPostCreateNewStickerSetRequest {
	r.userId = &userId
	return r
}

// Short name of sticker set, to be used in &#x60;t.me/addstickers/&#x60; URLs (e.g., *animals*). Can contain only English letters, digits and underscores. Must begin with a letter, can&#39;t contain consecutive underscores and must end in &#x60;\\\&quot;_by_&lt;bot_username&gt;\\\&quot;&#x60;. &#x60;&lt;bot_username&gt;&#x60; is case insensitive. 1-64 characters.
func (r ApiPostCreateNewStickerSetRequest) Name(name string) ApiPostCreateNewStickerSetRequest {
	r.name = &name
	return r
}

// Sticker set title, 1-64 characters
func (r ApiPostCreateNewStickerSetRequest) Title(title string) ApiPostCreateNewStickerSetRequest {
	r.title = &title
	return r
}

// A JSON-serialized list of 1-50 initial stickers to be added to the sticker set
func (r ApiPostCreateNewStickerSetRequest) Stickers(stickers []InputSticker) ApiPostCreateNewStickerSetRequest {
	r.stickers = &stickers
	return r
}

// Type of stickers in the set, pass “regular”, “mask”, or “custom\\\\_emoji”. By default, a regular sticker set is created.
func (r ApiPostCreateNewStickerSetRequest) StickerType(stickerType string) ApiPostCreateNewStickerSetRequest {
	r.stickerType = &stickerType
	return r
}

// Pass *True* if stickers in the sticker set must be repainted to the color of text when used in messages, the accent color if used as emoji status, white on chat photos, or another appropriate color based on context; for custom emoji sticker sets only
func (r ApiPostCreateNewStickerSetRequest) NeedsRepainting(needsRepainting bool) ApiPostCreateNewStickerSetRequest {
	r.needsRepainting = &needsRepainting
	return r
}

func (r ApiPostCreateNewStickerSetRequest) Execute() (*CreateNewStickerSetResponse, *http.Response, error) {
	return r.ApiService.PostCreateNewStickerSetExecute(r)
}

/*
PostCreateNewStickerSet createNewStickerSet

Use this method to create a new sticker set owned by a user. The bot will be able to edit the sticker set thus created. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCreateNewStickerSetRequest
*/
func (a *DefaultAPIService) PostCreateNewStickerSet(ctx context.Context) ApiPostCreateNewStickerSetRequest {
	return ApiPostCreateNewStickerSetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateNewStickerSetResponse
func (a *DefaultAPIService) PostCreateNewStickerSetExecute(r ApiPostCreateNewStickerSetRequest) (*CreateNewStickerSetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateNewStickerSetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostCreateNewStickerSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/createNewStickerSet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if strlen(*r.name) < 1 {
		return localVarReturnValue, nil, reportError("name must have at least 1 elements")
	}
	if strlen(*r.name) > 64 {
		return localVarReturnValue, nil, reportError("name must have less than 64 elements")
	}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if strlen(*r.title) < 1 {
		return localVarReturnValue, nil, reportError("title must have at least 1 elements")
	}
	if strlen(*r.title) > 64 {
		return localVarReturnValue, nil, reportError("title must have less than 64 elements")
	}
	if r.stickers == nil {
		return localVarReturnValue, nil, reportError("stickers is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "stickers", r.stickers, "", "csv")
	if r.stickerType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "sticker_type", r.stickerType, "", "")
	}
	if r.needsRepainting != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "needs_repainting", r.needsRepainting, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDeclineChatJoinRequestRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	userId *int32
}

func (r ApiPostDeclineChatJoinRequestRequest) ChatId(chatId SendMessageRequestChatId) ApiPostDeclineChatJoinRequestRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the target user
func (r ApiPostDeclineChatJoinRequestRequest) UserId(userId int32) ApiPostDeclineChatJoinRequestRequest {
	r.userId = &userId
	return r
}

func (r ApiPostDeclineChatJoinRequestRequest) Execute() (*DeclineChatJoinRequestResponse, *http.Response, error) {
	return r.ApiService.PostDeclineChatJoinRequestExecute(r)
}

/*
PostDeclineChatJoinRequest declineChatJoinRequest

Use this method to decline a chat join request. The bot must be an administrator in the chat for this to work and must have the *can\_invite\_users* administrator right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostDeclineChatJoinRequestRequest
*/
func (a *DefaultAPIService) PostDeclineChatJoinRequest(ctx context.Context) ApiPostDeclineChatJoinRequestRequest {
	return ApiPostDeclineChatJoinRequestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeclineChatJoinRequestResponse
func (a *DefaultAPIService) PostDeclineChatJoinRequestExecute(r ApiPostDeclineChatJoinRequestRequest) (*DeclineChatJoinRequestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeclineChatJoinRequestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostDeclineChatJoinRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/declineChatJoinRequest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDeleteBusinessMessagesRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	messageIds *[]int32
}

// Unique identifier of the business connection on behalf of which to delete the messages
func (r ApiPostDeleteBusinessMessagesRequest) BusinessConnectionId(businessConnectionId string) ApiPostDeleteBusinessMessagesRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// A JSON-serialized list of 1-100 identifiers of messages to delete. All messages must be from the same chat. See [deleteMessage](https://core.telegram.org/bots/api/#deletemessage) for limitations on which messages can be deleted
func (r ApiPostDeleteBusinessMessagesRequest) MessageIds(messageIds []int32) ApiPostDeleteBusinessMessagesRequest {
	r.messageIds = &messageIds
	return r
}

func (r ApiPostDeleteBusinessMessagesRequest) Execute() (*DeleteBusinessMessagesResponse, *http.Response, error) {
	return r.ApiService.PostDeleteBusinessMessagesExecute(r)
}

/*
PostDeleteBusinessMessages deleteBusinessMessages

Delete messages on behalf of a business account. Requires the *can\_delete\_sent\_messages* business bot right to delete messages sent by the bot itself, or the *can\_delete\_all\_messages* business bot right to delete any message. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostDeleteBusinessMessagesRequest
*/
func (a *DefaultAPIService) PostDeleteBusinessMessages(ctx context.Context) ApiPostDeleteBusinessMessagesRequest {
	return ApiPostDeleteBusinessMessagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteBusinessMessagesResponse
func (a *DefaultAPIService) PostDeleteBusinessMessagesExecute(r ApiPostDeleteBusinessMessagesRequest) (*DeleteBusinessMessagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteBusinessMessagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostDeleteBusinessMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteBusinessMessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.messageIds == nil {
		return localVarReturnValue, nil, reportError("messageIds is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_ids", r.messageIds, "", "csv")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDeleteChatPhotoRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
}

func (r ApiPostDeleteChatPhotoRequest) ChatId(chatId SendMessageRequestChatId) ApiPostDeleteChatPhotoRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostDeleteChatPhotoRequest) Execute() (*DeleteChatPhotoResponse, *http.Response, error) {
	return r.ApiService.PostDeleteChatPhotoExecute(r)
}

/*
PostDeleteChatPhoto deleteChatPhoto

Use this method to delete a chat photo. Photos can't be changed for private chats. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostDeleteChatPhotoRequest
*/
func (a *DefaultAPIService) PostDeleteChatPhoto(ctx context.Context) ApiPostDeleteChatPhotoRequest {
	return ApiPostDeleteChatPhotoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteChatPhotoResponse
func (a *DefaultAPIService) PostDeleteChatPhotoExecute(r ApiPostDeleteChatPhotoRequest) (*DeleteChatPhotoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteChatPhotoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostDeleteChatPhoto")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteChatPhoto"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDeleteChatStickerSetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *BotCommandScopeChatChatId
}

func (r ApiPostDeleteChatStickerSetRequest) ChatId(chatId BotCommandScopeChatChatId) ApiPostDeleteChatStickerSetRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostDeleteChatStickerSetRequest) Execute() (*DeleteChatStickerSetResponse, *http.Response, error) {
	return r.ApiService.PostDeleteChatStickerSetExecute(r)
}

/*
PostDeleteChatStickerSet deleteChatStickerSet

Use this method to delete a group sticker set from a supergroup. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Use the field *can\_set\_sticker\_set* optionally returned in [getChat](https://core.telegram.org/bots/api/#getchat) requests to check if the bot can use this method. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostDeleteChatStickerSetRequest
*/
func (a *DefaultAPIService) PostDeleteChatStickerSet(ctx context.Context) ApiPostDeleteChatStickerSetRequest {
	return ApiPostDeleteChatStickerSetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteChatStickerSetResponse
func (a *DefaultAPIService) PostDeleteChatStickerSetExecute(r ApiPostDeleteChatStickerSetRequest) (*DeleteChatStickerSetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteChatStickerSetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostDeleteChatStickerSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteChatStickerSet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDeleteForumTopicRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *BotCommandScopeChatChatId
	messageThreadId *int32
}

func (r ApiPostDeleteForumTopicRequest) ChatId(chatId BotCommandScopeChatChatId) ApiPostDeleteForumTopicRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier for the target message thread of the forum topic
func (r ApiPostDeleteForumTopicRequest) MessageThreadId(messageThreadId int32) ApiPostDeleteForumTopicRequest {
	r.messageThreadId = &messageThreadId
	return r
}

func (r ApiPostDeleteForumTopicRequest) Execute() (*DeleteForumTopicResponse, *http.Response, error) {
	return r.ApiService.PostDeleteForumTopicExecute(r)
}

/*
PostDeleteForumTopic deleteForumTopic

Use this method to delete a forum topic along with all its messages in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_delete\_messages* administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostDeleteForumTopicRequest
*/
func (a *DefaultAPIService) PostDeleteForumTopic(ctx context.Context) ApiPostDeleteForumTopicRequest {
	return ApiPostDeleteForumTopicRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteForumTopicResponse
func (a *DefaultAPIService) PostDeleteForumTopicExecute(r ApiPostDeleteForumTopicRequest) (*DeleteForumTopicResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteForumTopicResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostDeleteForumTopic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteForumTopic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.messageThreadId == nil {
		return localVarReturnValue, nil, reportError("messageThreadId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDeleteMessageRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	messageId *int32
}

func (r ApiPostDeleteMessageRequest) ChatId(chatId SendMessageRequestChatId) ApiPostDeleteMessageRequest {
	r.chatId = &chatId
	return r
}

// Identifier of the message to delete
func (r ApiPostDeleteMessageRequest) MessageId(messageId int32) ApiPostDeleteMessageRequest {
	r.messageId = &messageId
	return r
}

func (r ApiPostDeleteMessageRequest) Execute() (*DeleteMessageResponse, *http.Response, error) {
	return r.ApiService.PostDeleteMessageExecute(r)
}

/*
PostDeleteMessage deleteMessage

Use this method to delete a message, including service messages, with the following limitations:  
\- A message can only be deleted if it was sent less than 48 hours ago.  
\- Service messages about a supergroup, channel, or forum topic creation can't be deleted.  
\- A dice message in a private chat can only be deleted if it was sent more than 24 hours ago.  
\- Bots can delete outgoing messages in private chats, groups, and supergroups.  
\- Bots can delete incoming messages in private chats.  
\- Bots granted *can\_post\_messages* permissions can delete outgoing messages in channels.  
\- If the bot is an administrator of a group, it can delete any message there.  
\- If the bot has *can\_delete\_messages* permission in a supergroup or a channel, it can delete any message there.  
Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostDeleteMessageRequest
*/
func (a *DefaultAPIService) PostDeleteMessage(ctx context.Context) ApiPostDeleteMessageRequest {
	return ApiPostDeleteMessageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteMessageResponse
func (a *DefaultAPIService) PostDeleteMessageExecute(r ApiPostDeleteMessageRequest) (*DeleteMessageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteMessageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostDeleteMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.messageId == nil {
		return localVarReturnValue, nil, reportError("messageId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDeleteMessagesRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	messageIds *[]int32
}

func (r ApiPostDeleteMessagesRequest) ChatId(chatId SendMessageRequestChatId) ApiPostDeleteMessagesRequest {
	r.chatId = &chatId
	return r
}

// A JSON-serialized list of 1-100 identifiers of messages to delete. See [deleteMessage](https://core.telegram.org/bots/api/#deletemessage) for limitations on which messages can be deleted
func (r ApiPostDeleteMessagesRequest) MessageIds(messageIds []int32) ApiPostDeleteMessagesRequest {
	r.messageIds = &messageIds
	return r
}

func (r ApiPostDeleteMessagesRequest) Execute() (*DeleteMessagesResponse, *http.Response, error) {
	return r.ApiService.PostDeleteMessagesExecute(r)
}

/*
PostDeleteMessages deleteMessages

Use this method to delete multiple messages simultaneously. If some of the specified messages can't be found, they are skipped. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostDeleteMessagesRequest
*/
func (a *DefaultAPIService) PostDeleteMessages(ctx context.Context) ApiPostDeleteMessagesRequest {
	return ApiPostDeleteMessagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteMessagesResponse
func (a *DefaultAPIService) PostDeleteMessagesExecute(r ApiPostDeleteMessagesRequest) (*DeleteMessagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteMessagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostDeleteMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteMessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.messageIds == nil {
		return localVarReturnValue, nil, reportError("messageIds is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_ids", r.messageIds, "", "csv")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDeleteMyCommandsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	scope *BotCommandScope
	languageCode *string
}

func (r ApiPostDeleteMyCommandsRequest) Scope(scope BotCommandScope) ApiPostDeleteMyCommandsRequest {
	r.scope = &scope
	return r
}

// A two-letter ISO 639-1 language code. If empty, commands will be applied to all users from the given scope, for whose language there are no dedicated commands
func (r ApiPostDeleteMyCommandsRequest) LanguageCode(languageCode string) ApiPostDeleteMyCommandsRequest {
	r.languageCode = &languageCode
	return r
}

func (r ApiPostDeleteMyCommandsRequest) Execute() (*DeleteMyCommandsResponse, *http.Response, error) {
	return r.ApiService.PostDeleteMyCommandsExecute(r)
}

/*
PostDeleteMyCommands deleteMyCommands

Use this method to delete the list of the bot's commands for the given scope and user language. After deletion, [higher level commands](https://core.telegram.org/bots/api/#determining-list-of-commands) will be shown to affected users. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostDeleteMyCommandsRequest
*/
func (a *DefaultAPIService) PostDeleteMyCommands(ctx context.Context) ApiPostDeleteMyCommandsRequest {
	return ApiPostDeleteMyCommandsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteMyCommandsResponse
func (a *DefaultAPIService) PostDeleteMyCommandsExecute(r ApiPostDeleteMyCommandsRequest) (*DeleteMyCommandsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteMyCommandsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostDeleteMyCommands")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteMyCommands"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.scope != nil {
		paramJson, err := parameterToJson(*r.scope)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("scope", paramJson)
	}
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "language_code", r.languageCode, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDeleteStickerFromSetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	sticker *string
}

// File identifier of the sticker
func (r ApiPostDeleteStickerFromSetRequest) Sticker(sticker string) ApiPostDeleteStickerFromSetRequest {
	r.sticker = &sticker
	return r
}

func (r ApiPostDeleteStickerFromSetRequest) Execute() (*DeleteStickerFromSetResponse, *http.Response, error) {
	return r.ApiService.PostDeleteStickerFromSetExecute(r)
}

/*
PostDeleteStickerFromSet deleteStickerFromSet

Use this method to delete a sticker from a set created by the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostDeleteStickerFromSetRequest
*/
func (a *DefaultAPIService) PostDeleteStickerFromSet(ctx context.Context) ApiPostDeleteStickerFromSetRequest {
	return ApiPostDeleteStickerFromSetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteStickerFromSetResponse
func (a *DefaultAPIService) PostDeleteStickerFromSetExecute(r ApiPostDeleteStickerFromSetRequest) (*DeleteStickerFromSetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteStickerFromSetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostDeleteStickerFromSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteStickerFromSet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sticker == nil {
		return localVarReturnValue, nil, reportError("sticker is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "sticker", r.sticker, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDeleteStickerSetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	name *string
}

// Sticker set name
func (r ApiPostDeleteStickerSetRequest) Name(name string) ApiPostDeleteStickerSetRequest {
	r.name = &name
	return r
}

func (r ApiPostDeleteStickerSetRequest) Execute() (*DeleteStickerSetResponse, *http.Response, error) {
	return r.ApiService.PostDeleteStickerSetExecute(r)
}

/*
PostDeleteStickerSet deleteStickerSet

Use this method to delete a sticker set that was created by the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostDeleteStickerSetRequest
*/
func (a *DefaultAPIService) PostDeleteStickerSet(ctx context.Context) ApiPostDeleteStickerSetRequest {
	return ApiPostDeleteStickerSetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteStickerSetResponse
func (a *DefaultAPIService) PostDeleteStickerSetExecute(r ApiPostDeleteStickerSetRequest) (*DeleteStickerSetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteStickerSetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostDeleteStickerSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteStickerSet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDeleteStoryRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	storyId *int32
}

// Unique identifier of the business connection
func (r ApiPostDeleteStoryRequest) BusinessConnectionId(businessConnectionId string) ApiPostDeleteStoryRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier of the story to delete
func (r ApiPostDeleteStoryRequest) StoryId(storyId int32) ApiPostDeleteStoryRequest {
	r.storyId = &storyId
	return r
}

func (r ApiPostDeleteStoryRequest) Execute() (*DeleteStoryResponse, *http.Response, error) {
	return r.ApiService.PostDeleteStoryExecute(r)
}

/*
PostDeleteStory deleteStory

Deletes a story previously posted by the bot on behalf of a managed business account. Requires the *can\_manage\_stories* business bot right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostDeleteStoryRequest
*/
func (a *DefaultAPIService) PostDeleteStory(ctx context.Context) ApiPostDeleteStoryRequest {
	return ApiPostDeleteStoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteStoryResponse
func (a *DefaultAPIService) PostDeleteStoryExecute(r ApiPostDeleteStoryRequest) (*DeleteStoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteStoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostDeleteStory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteStory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.storyId == nil {
		return localVarReturnValue, nil, reportError("storyId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "story_id", r.storyId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDeleteWebhookRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	dropPendingUpdates *bool
}

// Pass *True* to drop all pending updates
func (r ApiPostDeleteWebhookRequest) DropPendingUpdates(dropPendingUpdates bool) ApiPostDeleteWebhookRequest {
	r.dropPendingUpdates = &dropPendingUpdates
	return r
}

func (r ApiPostDeleteWebhookRequest) Execute() (*DeleteWebhookResponse, *http.Response, error) {
	return r.ApiService.PostDeleteWebhookExecute(r)
}

/*
PostDeleteWebhook deleteWebhook

Use this method to remove webhook integration if you decide to switch back to [getUpdates](https://core.telegram.org/bots/api/#getupdates). Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostDeleteWebhookRequest
*/
func (a *DefaultAPIService) PostDeleteWebhook(ctx context.Context) ApiPostDeleteWebhookRequest {
	return ApiPostDeleteWebhookRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteWebhookResponse
func (a *DefaultAPIService) PostDeleteWebhookExecute(r ApiPostDeleteWebhookRequest) (*DeleteWebhookResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteWebhookResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostDeleteWebhook")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteWebhook"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.dropPendingUpdates != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "drop_pending_updates", r.dropPendingUpdates, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostEditChatInviteLinkRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	inviteLink *string
	name *string
	expireDate *int32
	memberLimit *int32
	createsJoinRequest *bool
}

func (r ApiPostEditChatInviteLinkRequest) ChatId(chatId SendMessageRequestChatId) ApiPostEditChatInviteLinkRequest {
	r.chatId = &chatId
	return r
}

// The invite link to edit
func (r ApiPostEditChatInviteLinkRequest) InviteLink(inviteLink string) ApiPostEditChatInviteLinkRequest {
	r.inviteLink = &inviteLink
	return r
}

// Invite link name; 0-32 characters
func (r ApiPostEditChatInviteLinkRequest) Name(name string) ApiPostEditChatInviteLinkRequest {
	r.name = &name
	return r
}

// Point in time (Unix timestamp) when the link will expire
func (r ApiPostEditChatInviteLinkRequest) ExpireDate(expireDate int32) ApiPostEditChatInviteLinkRequest {
	r.expireDate = &expireDate
	return r
}

// The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999
func (r ApiPostEditChatInviteLinkRequest) MemberLimit(memberLimit int32) ApiPostEditChatInviteLinkRequest {
	r.memberLimit = &memberLimit
	return r
}

// *True*, if users joining the chat via the link need to be approved by chat administrators. If *True*, *member\\\\_limit* can&#39;t be specified
func (r ApiPostEditChatInviteLinkRequest) CreatesJoinRequest(createsJoinRequest bool) ApiPostEditChatInviteLinkRequest {
	r.createsJoinRequest = &createsJoinRequest
	return r
}

func (r ApiPostEditChatInviteLinkRequest) Execute() (*EditChatInviteLinkResponse, *http.Response, error) {
	return r.ApiService.PostEditChatInviteLinkExecute(r)
}

/*
PostEditChatInviteLink editChatInviteLink

Use this method to edit a non-primary invite link created by the bot. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns the edited invite link as a [ChatInviteLink](https://core.telegram.org/bots/api/#chatinvitelink) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostEditChatInviteLinkRequest
*/
func (a *DefaultAPIService) PostEditChatInviteLink(ctx context.Context) ApiPostEditChatInviteLinkRequest {
	return ApiPostEditChatInviteLinkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EditChatInviteLinkResponse
func (a *DefaultAPIService) PostEditChatInviteLinkExecute(r ApiPostEditChatInviteLinkRequest) (*EditChatInviteLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EditChatInviteLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostEditChatInviteLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editChatInviteLink"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.inviteLink == nil {
		return localVarReturnValue, nil, reportError("inviteLink is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "invite_link", r.inviteLink, "", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	}
	if r.expireDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "expire_date", r.expireDate, "", "")
	}
	if r.memberLimit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "member_limit", r.memberLimit, "", "")
	}
	if r.createsJoinRequest != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "creates_join_request", r.createsJoinRequest, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostEditChatSubscriptionInviteLinkRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	inviteLink *string
	name *string
}

func (r ApiPostEditChatSubscriptionInviteLinkRequest) ChatId(chatId SendMessageRequestChatId) ApiPostEditChatSubscriptionInviteLinkRequest {
	r.chatId = &chatId
	return r
}

// The invite link to edit
func (r ApiPostEditChatSubscriptionInviteLinkRequest) InviteLink(inviteLink string) ApiPostEditChatSubscriptionInviteLinkRequest {
	r.inviteLink = &inviteLink
	return r
}

// Invite link name; 0-32 characters
func (r ApiPostEditChatSubscriptionInviteLinkRequest) Name(name string) ApiPostEditChatSubscriptionInviteLinkRequest {
	r.name = &name
	return r
}

func (r ApiPostEditChatSubscriptionInviteLinkRequest) Execute() (*EditChatSubscriptionInviteLinkResponse, *http.Response, error) {
	return r.ApiService.PostEditChatSubscriptionInviteLinkExecute(r)
}

/*
PostEditChatSubscriptionInviteLink editChatSubscriptionInviteLink

Use this method to edit a subscription invite link created by the bot. The bot must have the *can\_invite\_users* administrator rights. Returns the edited invite link as a [ChatInviteLink](https://core.telegram.org/bots/api/#chatinvitelink) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostEditChatSubscriptionInviteLinkRequest
*/
func (a *DefaultAPIService) PostEditChatSubscriptionInviteLink(ctx context.Context) ApiPostEditChatSubscriptionInviteLinkRequest {
	return ApiPostEditChatSubscriptionInviteLinkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EditChatSubscriptionInviteLinkResponse
func (a *DefaultAPIService) PostEditChatSubscriptionInviteLinkExecute(r ApiPostEditChatSubscriptionInviteLinkRequest) (*EditChatSubscriptionInviteLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EditChatSubscriptionInviteLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostEditChatSubscriptionInviteLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editChatSubscriptionInviteLink"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.inviteLink == nil {
		return localVarReturnValue, nil, reportError("inviteLink is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "invite_link", r.inviteLink, "", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostEditForumTopicRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *BotCommandScopeChatChatId
	messageThreadId *int32
	name *string
	iconCustomEmojiId *string
}

func (r ApiPostEditForumTopicRequest) ChatId(chatId BotCommandScopeChatChatId) ApiPostEditForumTopicRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier for the target message thread of the forum topic
func (r ApiPostEditForumTopicRequest) MessageThreadId(messageThreadId int32) ApiPostEditForumTopicRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// New topic name, 0-128 characters. If not specified or empty, the current name of the topic will be kept
func (r ApiPostEditForumTopicRequest) Name(name string) ApiPostEditForumTopicRequest {
	r.name = &name
	return r
}

// New unique identifier of the custom emoji shown as the topic icon. Use [getForumTopicIconStickers](https://core.telegram.org/bots/api/#getforumtopiciconstickers) to get all allowed custom emoji identifiers. Pass an empty string to remove the icon. If not specified, the current icon will be kept
func (r ApiPostEditForumTopicRequest) IconCustomEmojiId(iconCustomEmojiId string) ApiPostEditForumTopicRequest {
	r.iconCustomEmojiId = &iconCustomEmojiId
	return r
}

func (r ApiPostEditForumTopicRequest) Execute() (*EditForumTopicResponse, *http.Response, error) {
	return r.ApiService.PostEditForumTopicExecute(r)
}

/*
PostEditForumTopic editForumTopic

Use this method to edit name and icon of a topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights, unless it is the creator of the topic. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostEditForumTopicRequest
*/
func (a *DefaultAPIService) PostEditForumTopic(ctx context.Context) ApiPostEditForumTopicRequest {
	return ApiPostEditForumTopicRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EditForumTopicResponse
func (a *DefaultAPIService) PostEditForumTopicExecute(r ApiPostEditForumTopicRequest) (*EditForumTopicResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EditForumTopicResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostEditForumTopic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editForumTopic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.messageThreadId == nil {
		return localVarReturnValue, nil, reportError("messageThreadId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	}
	if r.iconCustomEmojiId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icon_custom_emoji_id", r.iconCustomEmojiId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostEditGeneralForumTopicRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *BotCommandScopeChatChatId
	name *string
}

func (r ApiPostEditGeneralForumTopicRequest) ChatId(chatId BotCommandScopeChatChatId) ApiPostEditGeneralForumTopicRequest {
	r.chatId = &chatId
	return r
}

// New topic name, 1-128 characters
func (r ApiPostEditGeneralForumTopicRequest) Name(name string) ApiPostEditGeneralForumTopicRequest {
	r.name = &name
	return r
}

func (r ApiPostEditGeneralForumTopicRequest) Execute() (*EditGeneralForumTopicResponse, *http.Response, error) {
	return r.ApiService.PostEditGeneralForumTopicExecute(r)
}

/*
PostEditGeneralForumTopic editGeneralForumTopic

Use this method to edit the name of the 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostEditGeneralForumTopicRequest
*/
func (a *DefaultAPIService) PostEditGeneralForumTopic(ctx context.Context) ApiPostEditGeneralForumTopicRequest {
	return ApiPostEditGeneralForumTopicRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EditGeneralForumTopicResponse
func (a *DefaultAPIService) PostEditGeneralForumTopicExecute(r ApiPostEditGeneralForumTopicRequest) (*EditGeneralForumTopicResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EditGeneralForumTopicResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostEditGeneralForumTopic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editGeneralForumTopic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if strlen(*r.name) < 1 {
		return localVarReturnValue, nil, reportError("name must have at least 1 elements")
	}
	if strlen(*r.name) > 128 {
		return localVarReturnValue, nil, reportError("name must have less than 128 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostEditMessageCaptionRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	chatId *EditMessageTextRequestChatId
	messageId *int32
	inlineMessageId *string
	caption *string
	parseMode *string
	captionEntities *[]MessageEntity
	showCaptionAboveMedia *bool
	replyMarkup *InlineKeyboardMarkup
}

// Unique identifier of the business connection on behalf of which the message to be edited was sent
func (r ApiPostEditMessageCaptionRequest) BusinessConnectionId(businessConnectionId string) ApiPostEditMessageCaptionRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

func (r ApiPostEditMessageCaptionRequest) ChatId(chatId EditMessageTextRequestChatId) ApiPostEditMessageCaptionRequest {
	r.chatId = &chatId
	return r
}

// Required if *inline\\\\_message\\\\_id* is not specified. Identifier of the message to edit
func (r ApiPostEditMessageCaptionRequest) MessageId(messageId int32) ApiPostEditMessageCaptionRequest {
	r.messageId = &messageId
	return r
}

// Required if *chat\\\\_id* and *message\\\\_id* are not specified. Identifier of the inline message
func (r ApiPostEditMessageCaptionRequest) InlineMessageId(inlineMessageId string) ApiPostEditMessageCaptionRequest {
	r.inlineMessageId = &inlineMessageId
	return r
}

// New caption of the message, 0-1024 characters after entities parsing
func (r ApiPostEditMessageCaptionRequest) Caption(caption string) ApiPostEditMessageCaptionRequest {
	r.caption = &caption
	return r
}

// Mode for parsing entities in the message caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiPostEditMessageCaptionRequest) ParseMode(parseMode string) ApiPostEditMessageCaptionRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of *parse\\\\_mode*
func (r ApiPostEditMessageCaptionRequest) CaptionEntities(captionEntities []MessageEntity) ApiPostEditMessageCaptionRequest {
	r.captionEntities = &captionEntities
	return r
}

// Pass *True*, if the caption must be shown above the message media. Supported only for animation, photo and video messages.
func (r ApiPostEditMessageCaptionRequest) ShowCaptionAboveMedia(showCaptionAboveMedia bool) ApiPostEditMessageCaptionRequest {
	r.showCaptionAboveMedia = &showCaptionAboveMedia
	return r
}

func (r ApiPostEditMessageCaptionRequest) ReplyMarkup(replyMarkup InlineKeyboardMarkup) ApiPostEditMessageCaptionRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostEditMessageCaptionRequest) Execute() (*EditMessageCaptionResponse, *http.Response, error) {
	return r.ApiService.PostEditMessageCaptionExecute(r)
}

/*
PostEditMessageCaption editMessageCaption

Use this method to edit captions of messages. On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned. Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within **48 hours** from the time they were sent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostEditMessageCaptionRequest
*/
func (a *DefaultAPIService) PostEditMessageCaption(ctx context.Context) ApiPostEditMessageCaptionRequest {
	return ApiPostEditMessageCaptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EditMessageCaptionResponse
func (a *DefaultAPIService) PostEditMessageCaptionExecute(r ApiPostEditMessageCaptionRequest) (*EditMessageCaptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EditMessageCaptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostEditMessageCaption")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editMessageCaption"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	if r.chatId != nil {
		paramJson, err := parameterToJson(*r.chatId)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("chat_id", paramJson)
	}
	if r.messageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	}
	if r.inlineMessageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "inline_message_id", r.inlineMessageId, "", "")
	}
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption", r.caption, "", "")
	}
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.captionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption_entities", r.captionEntities, "", "csv")
	}
	if r.showCaptionAboveMedia != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "show_caption_above_media", r.showCaptionAboveMedia, "", "")
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostEditMessageChecklistRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	chatId *int32
	messageId *int32
	checklist *InputChecklist
	replyMarkup *InlineKeyboardMarkup
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiPostEditMessageChecklistRequest) BusinessConnectionId(businessConnectionId string) ApiPostEditMessageChecklistRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target chat
func (r ApiPostEditMessageChecklistRequest) ChatId(chatId int32) ApiPostEditMessageChecklistRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier for the target message
func (r ApiPostEditMessageChecklistRequest) MessageId(messageId int32) ApiPostEditMessageChecklistRequest {
	r.messageId = &messageId
	return r
}

func (r ApiPostEditMessageChecklistRequest) Checklist(checklist InputChecklist) ApiPostEditMessageChecklistRequest {
	r.checklist = &checklist
	return r
}

func (r ApiPostEditMessageChecklistRequest) ReplyMarkup(replyMarkup InlineKeyboardMarkup) ApiPostEditMessageChecklistRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostEditMessageChecklistRequest) Execute() (*EditMessageChecklistResponse, *http.Response, error) {
	return r.ApiService.PostEditMessageChecklistExecute(r)
}

/*
PostEditMessageChecklist editMessageChecklist

Use this method to edit a checklist on behalf of a connected business account. On success, the edited [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostEditMessageChecklistRequest
*/
func (a *DefaultAPIService) PostEditMessageChecklist(ctx context.Context) ApiPostEditMessageChecklistRequest {
	return ApiPostEditMessageChecklistRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EditMessageChecklistResponse
func (a *DefaultAPIService) PostEditMessageChecklistExecute(r ApiPostEditMessageChecklistRequest) (*EditMessageChecklistResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EditMessageChecklistResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostEditMessageChecklist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editMessageChecklist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.messageId == nil {
		return localVarReturnValue, nil, reportError("messageId is required and must be specified")
	}
	if r.checklist == nil {
		return localVarReturnValue, nil, reportError("checklist is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "checklist", r.checklist, "", "")
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostEditMessageLiveLocationRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	latitude *float32
	longitude *float32
	businessConnectionId *string
	chatId *EditMessageTextRequestChatId
	messageId *int32
	inlineMessageId *string
	livePeriod *int32
	horizontalAccuracy *float32
	heading *int32
	proximityAlertRadius *int32
	replyMarkup *InlineKeyboardMarkup
}

// Latitude of new location
func (r ApiPostEditMessageLiveLocationRequest) Latitude(latitude float32) ApiPostEditMessageLiveLocationRequest {
	r.latitude = &latitude
	return r
}

// Longitude of new location
func (r ApiPostEditMessageLiveLocationRequest) Longitude(longitude float32) ApiPostEditMessageLiveLocationRequest {
	r.longitude = &longitude
	return r
}

// Unique identifier of the business connection on behalf of which the message to be edited was sent
func (r ApiPostEditMessageLiveLocationRequest) BusinessConnectionId(businessConnectionId string) ApiPostEditMessageLiveLocationRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

func (r ApiPostEditMessageLiveLocationRequest) ChatId(chatId EditMessageTextRequestChatId) ApiPostEditMessageLiveLocationRequest {
	r.chatId = &chatId
	return r
}

// Required if *inline\\\\_message\\\\_id* is not specified. Identifier of the message to edit
func (r ApiPostEditMessageLiveLocationRequest) MessageId(messageId int32) ApiPostEditMessageLiveLocationRequest {
	r.messageId = &messageId
	return r
}

// Required if *chat\\\\_id* and *message\\\\_id* are not specified. Identifier of the inline message
func (r ApiPostEditMessageLiveLocationRequest) InlineMessageId(inlineMessageId string) ApiPostEditMessageLiveLocationRequest {
	r.inlineMessageId = &inlineMessageId
	return r
}

// New period in seconds during which the location can be updated, starting from the message send date. If 0x7FFFFFFF is specified, then the location can be updated forever. Otherwise, the new value must not exceed the current *live\\\\_period* by more than a day, and the live location expiration date must remain within the next 90 days. If not specified, then *live\\\\_period* remains unchanged
func (r ApiPostEditMessageLiveLocationRequest) LivePeriod(livePeriod int32) ApiPostEditMessageLiveLocationRequest {
	r.livePeriod = &livePeriod
	return r
}

// The radius of uncertainty for the location, measured in meters; 0-1500
func (r ApiPostEditMessageLiveLocationRequest) HorizontalAccuracy(horizontalAccuracy float32) ApiPostEditMessageLiveLocationRequest {
	r.horizontalAccuracy = &horizontalAccuracy
	return r
}

// Direction in which the user is moving, in degrees. Must be between 1 and 360 if specified.
func (r ApiPostEditMessageLiveLocationRequest) Heading(heading int32) ApiPostEditMessageLiveLocationRequest {
	r.heading = &heading
	return r
}

// The maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified.
func (r ApiPostEditMessageLiveLocationRequest) ProximityAlertRadius(proximityAlertRadius int32) ApiPostEditMessageLiveLocationRequest {
	r.proximityAlertRadius = &proximityAlertRadius
	return r
}

func (r ApiPostEditMessageLiveLocationRequest) ReplyMarkup(replyMarkup InlineKeyboardMarkup) ApiPostEditMessageLiveLocationRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostEditMessageLiveLocationRequest) Execute() (*EditMessageLiveLocationResponse, *http.Response, error) {
	return r.ApiService.PostEditMessageLiveLocationExecute(r)
}

/*
PostEditMessageLiveLocation editMessageLiveLocation

Use this method to edit live location messages. A location can be edited until its *live\_period* expires or editing is explicitly disabled by a call to [stopMessageLiveLocation](https://core.telegram.org/bots/api/#stopmessagelivelocation). On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostEditMessageLiveLocationRequest
*/
func (a *DefaultAPIService) PostEditMessageLiveLocation(ctx context.Context) ApiPostEditMessageLiveLocationRequest {
	return ApiPostEditMessageLiveLocationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EditMessageLiveLocationResponse
func (a *DefaultAPIService) PostEditMessageLiveLocationExecute(r ApiPostEditMessageLiveLocationRequest) (*EditMessageLiveLocationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EditMessageLiveLocationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostEditMessageLiveLocation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editMessageLiveLocation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.latitude == nil {
		return localVarReturnValue, nil, reportError("latitude is required and must be specified")
	}
	if r.longitude == nil {
		return localVarReturnValue, nil, reportError("longitude is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	if r.chatId != nil {
		paramJson, err := parameterToJson(*r.chatId)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("chat_id", paramJson)
	}
	if r.messageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	}
	if r.inlineMessageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "inline_message_id", r.inlineMessageId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "latitude", r.latitude, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "longitude", r.longitude, "", "")
	if r.livePeriod != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "live_period", r.livePeriod, "", "")
	}
	if r.horizontalAccuracy != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "horizontal_accuracy", r.horizontalAccuracy, "", "")
	}
	if r.heading != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "heading", r.heading, "", "")
	}
	if r.proximityAlertRadius != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "proximity_alert_radius", r.proximityAlertRadius, "", "")
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostEditMessageMediaRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	media *InputMedia
	businessConnectionId *string
	chatId *EditMessageTextRequestChatId
	messageId *int32
	inlineMessageId *string
	replyMarkup *InlineKeyboardMarkup
}

func (r ApiPostEditMessageMediaRequest) Media(media InputMedia) ApiPostEditMessageMediaRequest {
	r.media = &media
	return r
}

// Unique identifier of the business connection on behalf of which the message to be edited was sent
func (r ApiPostEditMessageMediaRequest) BusinessConnectionId(businessConnectionId string) ApiPostEditMessageMediaRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

func (r ApiPostEditMessageMediaRequest) ChatId(chatId EditMessageTextRequestChatId) ApiPostEditMessageMediaRequest {
	r.chatId = &chatId
	return r
}

// Required if *inline\\\\_message\\\\_id* is not specified. Identifier of the message to edit
func (r ApiPostEditMessageMediaRequest) MessageId(messageId int32) ApiPostEditMessageMediaRequest {
	r.messageId = &messageId
	return r
}

// Required if *chat\\\\_id* and *message\\\\_id* are not specified. Identifier of the inline message
func (r ApiPostEditMessageMediaRequest) InlineMessageId(inlineMessageId string) ApiPostEditMessageMediaRequest {
	r.inlineMessageId = &inlineMessageId
	return r
}

func (r ApiPostEditMessageMediaRequest) ReplyMarkup(replyMarkup InlineKeyboardMarkup) ApiPostEditMessageMediaRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostEditMessageMediaRequest) Execute() (*EditMessageMediaResponse, *http.Response, error) {
	return r.ApiService.PostEditMessageMediaExecute(r)
}

/*
PostEditMessageMedia editMessageMedia

Use this method to edit animation, audio, document, photo, or video messages, or to add media to text messages. If a message is part of a message album, then it can be edited only to an audio for audio albums, only to a document for document albums and to a photo or a video otherwise. When an inline message is edited, a new file can't be uploaded; use a previously uploaded file via its file\_id or specify a URL. On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned. Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within **48 hours** from the time they were sent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostEditMessageMediaRequest
*/
func (a *DefaultAPIService) PostEditMessageMedia(ctx context.Context) ApiPostEditMessageMediaRequest {
	return ApiPostEditMessageMediaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EditMessageMediaResponse
func (a *DefaultAPIService) PostEditMessageMediaExecute(r ApiPostEditMessageMediaRequest) (*EditMessageMediaResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EditMessageMediaResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostEditMessageMedia")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editMessageMedia"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.media == nil {
		return localVarReturnValue, nil, reportError("media is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	if r.chatId != nil {
		paramJson, err := parameterToJson(*r.chatId)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("chat_id", paramJson)
	}
	if r.messageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	}
	if r.inlineMessageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "inline_message_id", r.inlineMessageId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "media", r.media, "", "")
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostEditMessageReplyMarkupRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	chatId *EditMessageTextRequestChatId
	messageId *int32
	inlineMessageId *string
	replyMarkup *InlineKeyboardMarkup
}

// Unique identifier of the business connection on behalf of which the message to be edited was sent
func (r ApiPostEditMessageReplyMarkupRequest) BusinessConnectionId(businessConnectionId string) ApiPostEditMessageReplyMarkupRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

func (r ApiPostEditMessageReplyMarkupRequest) ChatId(chatId EditMessageTextRequestChatId) ApiPostEditMessageReplyMarkupRequest {
	r.chatId = &chatId
	return r
}

// Required if *inline\\\\_message\\\\_id* is not specified. Identifier of the message to edit
func (r ApiPostEditMessageReplyMarkupRequest) MessageId(messageId int32) ApiPostEditMessageReplyMarkupRequest {
	r.messageId = &messageId
	return r
}

// Required if *chat\\\\_id* and *message\\\\_id* are not specified. Identifier of the inline message
func (r ApiPostEditMessageReplyMarkupRequest) InlineMessageId(inlineMessageId string) ApiPostEditMessageReplyMarkupRequest {
	r.inlineMessageId = &inlineMessageId
	return r
}

func (r ApiPostEditMessageReplyMarkupRequest) ReplyMarkup(replyMarkup InlineKeyboardMarkup) ApiPostEditMessageReplyMarkupRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostEditMessageReplyMarkupRequest) Execute() (*EditMessageReplyMarkupResponse, *http.Response, error) {
	return r.ApiService.PostEditMessageReplyMarkupExecute(r)
}

/*
PostEditMessageReplyMarkup editMessageReplyMarkup

Use this method to edit only the reply markup of messages. On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned. Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within **48 hours** from the time they were sent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostEditMessageReplyMarkupRequest
*/
func (a *DefaultAPIService) PostEditMessageReplyMarkup(ctx context.Context) ApiPostEditMessageReplyMarkupRequest {
	return ApiPostEditMessageReplyMarkupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EditMessageReplyMarkupResponse
func (a *DefaultAPIService) PostEditMessageReplyMarkupExecute(r ApiPostEditMessageReplyMarkupRequest) (*EditMessageReplyMarkupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EditMessageReplyMarkupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostEditMessageReplyMarkup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editMessageReplyMarkup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	if r.chatId != nil {
		paramJson, err := parameterToJson(*r.chatId)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("chat_id", paramJson)
	}
	if r.messageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	}
	if r.inlineMessageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "inline_message_id", r.inlineMessageId, "", "")
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostEditMessageTextRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	text *string
	businessConnectionId *string
	chatId *EditMessageTextRequestChatId
	messageId *int32
	inlineMessageId *string
	parseMode *string
	entities *[]MessageEntity
	linkPreviewOptions *LinkPreviewOptions
	replyMarkup *InlineKeyboardMarkup
}

// New text of the message, 1-4096 characters after entities parsing
func (r ApiPostEditMessageTextRequest) Text(text string) ApiPostEditMessageTextRequest {
	r.text = &text
	return r
}

// Unique identifier of the business connection on behalf of which the message to be edited was sent
func (r ApiPostEditMessageTextRequest) BusinessConnectionId(businessConnectionId string) ApiPostEditMessageTextRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

func (r ApiPostEditMessageTextRequest) ChatId(chatId EditMessageTextRequestChatId) ApiPostEditMessageTextRequest {
	r.chatId = &chatId
	return r
}

// Required if *inline\\\\_message\\\\_id* is not specified. Identifier of the message to edit
func (r ApiPostEditMessageTextRequest) MessageId(messageId int32) ApiPostEditMessageTextRequest {
	r.messageId = &messageId
	return r
}

// Required if *chat\\\\_id* and *message\\\\_id* are not specified. Identifier of the inline message
func (r ApiPostEditMessageTextRequest) InlineMessageId(inlineMessageId string) ApiPostEditMessageTextRequest {
	r.inlineMessageId = &inlineMessageId
	return r
}

// Mode for parsing entities in the message text. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiPostEditMessageTextRequest) ParseMode(parseMode string) ApiPostEditMessageTextRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in message text, which can be specified instead of *parse\\\\_mode*
func (r ApiPostEditMessageTextRequest) Entities(entities []MessageEntity) ApiPostEditMessageTextRequest {
	r.entities = &entities
	return r
}

func (r ApiPostEditMessageTextRequest) LinkPreviewOptions(linkPreviewOptions LinkPreviewOptions) ApiPostEditMessageTextRequest {
	r.linkPreviewOptions = &linkPreviewOptions
	return r
}

func (r ApiPostEditMessageTextRequest) ReplyMarkup(replyMarkup InlineKeyboardMarkup) ApiPostEditMessageTextRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostEditMessageTextRequest) Execute() (*EditMessageTextResponse, *http.Response, error) {
	return r.ApiService.PostEditMessageTextExecute(r)
}

/*
PostEditMessageText editMessageText

Use this method to edit text and [game](https://core.telegram.org/bots/api/#games) messages. On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned. Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within **48 hours** from the time they were sent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostEditMessageTextRequest
*/
func (a *DefaultAPIService) PostEditMessageText(ctx context.Context) ApiPostEditMessageTextRequest {
	return ApiPostEditMessageTextRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EditMessageTextResponse
func (a *DefaultAPIService) PostEditMessageTextExecute(r ApiPostEditMessageTextRequest) (*EditMessageTextResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EditMessageTextResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostEditMessageText")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editMessageText"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}
	if strlen(*r.text) < 1 {
		return localVarReturnValue, nil, reportError("text must have at least 1 elements")
	}
	if strlen(*r.text) > 4096 {
		return localVarReturnValue, nil, reportError("text must have less than 4096 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	if r.chatId != nil {
		paramJson, err := parameterToJson(*r.chatId)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("chat_id", paramJson)
	}
	if r.messageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	}
	if r.inlineMessageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "inline_message_id", r.inlineMessageId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "text", r.text, "", "")
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.entities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "entities", r.entities, "", "csv")
	}
	if r.linkPreviewOptions != nil {
		paramJson, err := parameterToJson(*r.linkPreviewOptions)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("link_preview_options", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostEditStoryRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	storyId *int32
	content *InputStoryContent
	caption *string
	parseMode *string
	captionEntities *[]MessageEntity
	areas *[]StoryArea
}

// Unique identifier of the business connection
func (r ApiPostEditStoryRequest) BusinessConnectionId(businessConnectionId string) ApiPostEditStoryRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier of the story to edit
func (r ApiPostEditStoryRequest) StoryId(storyId int32) ApiPostEditStoryRequest {
	r.storyId = &storyId
	return r
}

func (r ApiPostEditStoryRequest) Content(content InputStoryContent) ApiPostEditStoryRequest {
	r.content = &content
	return r
}

// Caption of the story, 0-2048 characters after entities parsing
func (r ApiPostEditStoryRequest) Caption(caption string) ApiPostEditStoryRequest {
	r.caption = &caption
	return r
}

// Mode for parsing entities in the story caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiPostEditStoryRequest) ParseMode(parseMode string) ApiPostEditStoryRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of *parse\\\\_mode*
func (r ApiPostEditStoryRequest) CaptionEntities(captionEntities []MessageEntity) ApiPostEditStoryRequest {
	r.captionEntities = &captionEntities
	return r
}

// A JSON-serialized list of clickable areas to be shown on the story
func (r ApiPostEditStoryRequest) Areas(areas []StoryArea) ApiPostEditStoryRequest {
	r.areas = &areas
	return r
}

func (r ApiPostEditStoryRequest) Execute() (*EditStoryResponse, *http.Response, error) {
	return r.ApiService.PostEditStoryExecute(r)
}

/*
PostEditStory editStory

Edits a story previously posted by the bot on behalf of a managed business account. Requires the *can\_manage\_stories* business bot right. Returns [Story](https://core.telegram.org/bots/api/#story) on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostEditStoryRequest
*/
func (a *DefaultAPIService) PostEditStory(ctx context.Context) ApiPostEditStoryRequest {
	return ApiPostEditStoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EditStoryResponse
func (a *DefaultAPIService) PostEditStoryExecute(r ApiPostEditStoryRequest) (*EditStoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EditStoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostEditStory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editStory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.storyId == nil {
		return localVarReturnValue, nil, reportError("storyId is required and must be specified")
	}
	if r.content == nil {
		return localVarReturnValue, nil, reportError("content is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "story_id", r.storyId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "content", r.content, "", "")
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption", r.caption, "", "")
	}
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.captionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption_entities", r.captionEntities, "", "csv")
	}
	if r.areas != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "areas", r.areas, "", "csv")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostEditUserStarSubscriptionRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	telegramPaymentChargeId *string
	isCanceled *bool
}

// Identifier of the user whose subscription will be edited
func (r ApiPostEditUserStarSubscriptionRequest) UserId(userId int32) ApiPostEditUserStarSubscriptionRequest {
	r.userId = &userId
	return r
}

// Telegram payment identifier for the subscription
func (r ApiPostEditUserStarSubscriptionRequest) TelegramPaymentChargeId(telegramPaymentChargeId string) ApiPostEditUserStarSubscriptionRequest {
	r.telegramPaymentChargeId = &telegramPaymentChargeId
	return r
}

// Pass *True* to cancel extension of the user subscription; the subscription must be active up to the end of the current subscription period. Pass *False* to allow the user to re-enable a subscription that was previously canceled by the bot.
func (r ApiPostEditUserStarSubscriptionRequest) IsCanceled(isCanceled bool) ApiPostEditUserStarSubscriptionRequest {
	r.isCanceled = &isCanceled
	return r
}

func (r ApiPostEditUserStarSubscriptionRequest) Execute() (*EditUserStarSubscriptionResponse, *http.Response, error) {
	return r.ApiService.PostEditUserStarSubscriptionExecute(r)
}

/*
PostEditUserStarSubscription editUserStarSubscription

Allows the bot to cancel or re-enable extension of a subscription paid in Telegram Stars. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostEditUserStarSubscriptionRequest
*/
func (a *DefaultAPIService) PostEditUserStarSubscription(ctx context.Context) ApiPostEditUserStarSubscriptionRequest {
	return ApiPostEditUserStarSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EditUserStarSubscriptionResponse
func (a *DefaultAPIService) PostEditUserStarSubscriptionExecute(r ApiPostEditUserStarSubscriptionRequest) (*EditUserStarSubscriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EditUserStarSubscriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostEditUserStarSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editUserStarSubscription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.telegramPaymentChargeId == nil {
		return localVarReturnValue, nil, reportError("telegramPaymentChargeId is required and must be specified")
	}
	if r.isCanceled == nil {
		return localVarReturnValue, nil, reportError("isCanceled is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "telegram_payment_charge_id", r.telegramPaymentChargeId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "is_canceled", r.isCanceled, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostExportChatInviteLinkRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
}

func (r ApiPostExportChatInviteLinkRequest) ChatId(chatId SendMessageRequestChatId) ApiPostExportChatInviteLinkRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostExportChatInviteLinkRequest) Execute() (*ExportChatInviteLinkResponse, *http.Response, error) {
	return r.ApiService.PostExportChatInviteLinkExecute(r)
}

/*
PostExportChatInviteLink exportChatInviteLink

Use this method to generate a new primary invite link for a chat; any previously generated primary link is revoked. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns the new invite link as *String* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostExportChatInviteLinkRequest
*/
func (a *DefaultAPIService) PostExportChatInviteLink(ctx context.Context) ApiPostExportChatInviteLinkRequest {
	return ApiPostExportChatInviteLinkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExportChatInviteLinkResponse
func (a *DefaultAPIService) PostExportChatInviteLinkExecute(r ApiPostExportChatInviteLinkRequest) (*ExportChatInviteLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportChatInviteLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostExportChatInviteLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exportChatInviteLink"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostForwardMessageRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	fromChatId *ForwardMessageRequestFromChatId
	messageId *int32
	messageThreadId *int32
	videoStartTimestamp *int32
	disableNotification *bool
	protectContent *bool
}

func (r ApiPostForwardMessageRequest) ChatId(chatId SendMessageRequestChatId) ApiPostForwardMessageRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostForwardMessageRequest) FromChatId(fromChatId ForwardMessageRequestFromChatId) ApiPostForwardMessageRequest {
	r.fromChatId = &fromChatId
	return r
}

// Message identifier in the chat specified in *from\\\\_chat\\\\_id*
func (r ApiPostForwardMessageRequest) MessageId(messageId int32) ApiPostForwardMessageRequest {
	r.messageId = &messageId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiPostForwardMessageRequest) MessageThreadId(messageThreadId int32) ApiPostForwardMessageRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// New start timestamp for the forwarded video in the message
func (r ApiPostForwardMessageRequest) VideoStartTimestamp(videoStartTimestamp int32) ApiPostForwardMessageRequest {
	r.videoStartTimestamp = &videoStartTimestamp
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiPostForwardMessageRequest) DisableNotification(disableNotification bool) ApiPostForwardMessageRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the forwarded message from forwarding and saving
func (r ApiPostForwardMessageRequest) ProtectContent(protectContent bool) ApiPostForwardMessageRequest {
	r.protectContent = &protectContent
	return r
}

func (r ApiPostForwardMessageRequest) Execute() (*ForwardMessageResponse, *http.Response, error) {
	return r.ApiService.PostForwardMessageExecute(r)
}

/*
PostForwardMessage forwardMessage

Use this method to forward messages of any kind. Service messages and messages with protected content can't be forwarded. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostForwardMessageRequest
*/
func (a *DefaultAPIService) PostForwardMessage(ctx context.Context) ApiPostForwardMessageRequest {
	return ApiPostForwardMessageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ForwardMessageResponse
func (a *DefaultAPIService) PostForwardMessageExecute(r ApiPostForwardMessageRequest) (*ForwardMessageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ForwardMessageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostForwardMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forwardMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.fromChatId == nil {
		return localVarReturnValue, nil, reportError("fromChatId is required and must be specified")
	}
	if r.messageId == nil {
		return localVarReturnValue, nil, reportError("messageId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "from_chat_id", r.fromChatId, "", "")
	if r.videoStartTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "video_start_timestamp", r.videoStartTimestamp, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostForwardMessagesRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	fromChatId *ForwardMessagesRequestFromChatId
	messageIds *[]int32
	messageThreadId *int32
	disableNotification *bool
	protectContent *bool
}

func (r ApiPostForwardMessagesRequest) ChatId(chatId SendMessageRequestChatId) ApiPostForwardMessagesRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostForwardMessagesRequest) FromChatId(fromChatId ForwardMessagesRequestFromChatId) ApiPostForwardMessagesRequest {
	r.fromChatId = &fromChatId
	return r
}

// A JSON-serialized list of 1-100 identifiers of messages in the chat *from\\\\_chat\\\\_id* to forward. The identifiers must be specified in a strictly increasing order.
func (r ApiPostForwardMessagesRequest) MessageIds(messageIds []int32) ApiPostForwardMessagesRequest {
	r.messageIds = &messageIds
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiPostForwardMessagesRequest) MessageThreadId(messageThreadId int32) ApiPostForwardMessagesRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Sends the messages [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiPostForwardMessagesRequest) DisableNotification(disableNotification bool) ApiPostForwardMessagesRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the forwarded messages from forwarding and saving
func (r ApiPostForwardMessagesRequest) ProtectContent(protectContent bool) ApiPostForwardMessagesRequest {
	r.protectContent = &protectContent
	return r
}

func (r ApiPostForwardMessagesRequest) Execute() (*ForwardMessagesResponse, *http.Response, error) {
	return r.ApiService.PostForwardMessagesExecute(r)
}

/*
PostForwardMessages forwardMessages

Use this method to forward multiple messages of any kind. If some of the specified messages can't be found or forwarded, they are skipped. Service messages and messages with protected content can't be forwarded. Album grouping is kept for forwarded messages. On success, an array of [MessageId](https://core.telegram.org/bots/api/#messageid) of the sent messages is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostForwardMessagesRequest
*/
func (a *DefaultAPIService) PostForwardMessages(ctx context.Context) ApiPostForwardMessagesRequest {
	return ApiPostForwardMessagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ForwardMessagesResponse
func (a *DefaultAPIService) PostForwardMessagesExecute(r ApiPostForwardMessagesRequest) (*ForwardMessagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ForwardMessagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostForwardMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forwardMessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.fromChatId == nil {
		return localVarReturnValue, nil, reportError("fromChatId is required and must be specified")
	}
	if r.messageIds == nil {
		return localVarReturnValue, nil, reportError("messageIds is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "from_chat_id", r.fromChatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_ids", r.messageIds, "", "csv")
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetAvailableGiftsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiPostGetAvailableGiftsRequest) Execute() (*GetAvailableGiftsResponse, *http.Response, error) {
	return r.ApiService.PostGetAvailableGiftsExecute(r)
}

/*
PostGetAvailableGifts getAvailableGifts

Returns the list of gifts that can be sent by the bot to users and channel chats. Requires no parameters. Returns a [Gifts](https://core.telegram.org/bots/api/#gifts) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetAvailableGiftsRequest
*/
func (a *DefaultAPIService) PostGetAvailableGifts(ctx context.Context) ApiPostGetAvailableGiftsRequest {
	return ApiPostGetAvailableGiftsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAvailableGiftsResponse
func (a *DefaultAPIService) PostGetAvailableGiftsExecute(r ApiPostGetAvailableGiftsRequest) (*GetAvailableGiftsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAvailableGiftsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetAvailableGifts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getAvailableGifts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetBusinessAccountGiftsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	excludeUnsaved *bool
	excludeSaved *bool
	excludeUnlimited *bool
	excludeLimited *bool
	excludeUnique *bool
	sortByPrice *bool
	offset *string
	limit *int32
}

// Unique identifier of the business connection
func (r ApiPostGetBusinessAccountGiftsRequest) BusinessConnectionId(businessConnectionId string) ApiPostGetBusinessAccountGiftsRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Pass *True* to exclude gifts that aren&#39;t saved to the account&#39;s profile page
func (r ApiPostGetBusinessAccountGiftsRequest) ExcludeUnsaved(excludeUnsaved bool) ApiPostGetBusinessAccountGiftsRequest {
	r.excludeUnsaved = &excludeUnsaved
	return r
}

// Pass *True* to exclude gifts that are saved to the account&#39;s profile page
func (r ApiPostGetBusinessAccountGiftsRequest) ExcludeSaved(excludeSaved bool) ApiPostGetBusinessAccountGiftsRequest {
	r.excludeSaved = &excludeSaved
	return r
}

// Pass *True* to exclude gifts that can be purchased an unlimited number of times
func (r ApiPostGetBusinessAccountGiftsRequest) ExcludeUnlimited(excludeUnlimited bool) ApiPostGetBusinessAccountGiftsRequest {
	r.excludeUnlimited = &excludeUnlimited
	return r
}

// Pass *True* to exclude gifts that can be purchased a limited number of times
func (r ApiPostGetBusinessAccountGiftsRequest) ExcludeLimited(excludeLimited bool) ApiPostGetBusinessAccountGiftsRequest {
	r.excludeLimited = &excludeLimited
	return r
}

// Pass *True* to exclude unique gifts
func (r ApiPostGetBusinessAccountGiftsRequest) ExcludeUnique(excludeUnique bool) ApiPostGetBusinessAccountGiftsRequest {
	r.excludeUnique = &excludeUnique
	return r
}

// Pass *True* to sort results by gift price instead of send date. Sorting is applied before pagination.
func (r ApiPostGetBusinessAccountGiftsRequest) SortByPrice(sortByPrice bool) ApiPostGetBusinessAccountGiftsRequest {
	r.sortByPrice = &sortByPrice
	return r
}

// Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
func (r ApiPostGetBusinessAccountGiftsRequest) Offset(offset string) ApiPostGetBusinessAccountGiftsRequest {
	r.offset = &offset
	return r
}

// The maximum number of gifts to be returned; 1-100. Defaults to 100
func (r ApiPostGetBusinessAccountGiftsRequest) Limit(limit int32) ApiPostGetBusinessAccountGiftsRequest {
	r.limit = &limit
	return r
}

func (r ApiPostGetBusinessAccountGiftsRequest) Execute() (*GetBusinessAccountGiftsResponse, *http.Response, error) {
	return r.ApiService.PostGetBusinessAccountGiftsExecute(r)
}

/*
PostGetBusinessAccountGifts getBusinessAccountGifts

Returns the gifts received and owned by a managed business account. Requires the *can\_view\_gifts\_and\_stars* business bot right. Returns [OwnedGifts](https://core.telegram.org/bots/api/#ownedgifts) on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetBusinessAccountGiftsRequest
*/
func (a *DefaultAPIService) PostGetBusinessAccountGifts(ctx context.Context) ApiPostGetBusinessAccountGiftsRequest {
	return ApiPostGetBusinessAccountGiftsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetBusinessAccountGiftsResponse
func (a *DefaultAPIService) PostGetBusinessAccountGiftsExecute(r ApiPostGetBusinessAccountGiftsRequest) (*GetBusinessAccountGiftsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBusinessAccountGiftsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetBusinessAccountGifts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getBusinessAccountGifts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	if r.excludeUnsaved != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "exclude_unsaved", r.excludeUnsaved, "", "")
	}
	if r.excludeSaved != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "exclude_saved", r.excludeSaved, "", "")
	}
	if r.excludeUnlimited != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "exclude_unlimited", r.excludeUnlimited, "", "")
	}
	if r.excludeLimited != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "exclude_limited", r.excludeLimited, "", "")
	}
	if r.excludeUnique != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "exclude_unique", r.excludeUnique, "", "")
	}
	if r.sortByPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "sort_by_price", r.sortByPrice, "", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "offset", r.offset, "", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limit", r.limit, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetBusinessAccountStarBalanceRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
}

// Unique identifier of the business connection
func (r ApiPostGetBusinessAccountStarBalanceRequest) BusinessConnectionId(businessConnectionId string) ApiPostGetBusinessAccountStarBalanceRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

func (r ApiPostGetBusinessAccountStarBalanceRequest) Execute() (*GetBusinessAccountStarBalanceResponse, *http.Response, error) {
	return r.ApiService.PostGetBusinessAccountStarBalanceExecute(r)
}

/*
PostGetBusinessAccountStarBalance getBusinessAccountStarBalance

Returns the amount of Telegram Stars owned by a managed business account. Requires the *can\_view\_gifts\_and\_stars* business bot right. Returns [StarAmount](https://core.telegram.org/bots/api/#staramount) on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetBusinessAccountStarBalanceRequest
*/
func (a *DefaultAPIService) PostGetBusinessAccountStarBalance(ctx context.Context) ApiPostGetBusinessAccountStarBalanceRequest {
	return ApiPostGetBusinessAccountStarBalanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetBusinessAccountStarBalanceResponse
func (a *DefaultAPIService) PostGetBusinessAccountStarBalanceExecute(r ApiPostGetBusinessAccountStarBalanceRequest) (*GetBusinessAccountStarBalanceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBusinessAccountStarBalanceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetBusinessAccountStarBalance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getBusinessAccountStarBalance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetBusinessConnectionRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
}

// Unique identifier of the business connection
func (r ApiPostGetBusinessConnectionRequest) BusinessConnectionId(businessConnectionId string) ApiPostGetBusinessConnectionRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

func (r ApiPostGetBusinessConnectionRequest) Execute() (*GetBusinessConnectionResponse, *http.Response, error) {
	return r.ApiService.PostGetBusinessConnectionExecute(r)
}

/*
PostGetBusinessConnection getBusinessConnection

Use this method to get information about the connection of the bot with a business account. Returns a [BusinessConnection](https://core.telegram.org/bots/api/#businessconnection) object on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetBusinessConnectionRequest
*/
func (a *DefaultAPIService) PostGetBusinessConnection(ctx context.Context) ApiPostGetBusinessConnectionRequest {
	return ApiPostGetBusinessConnectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetBusinessConnectionResponse
func (a *DefaultAPIService) PostGetBusinessConnectionExecute(r ApiPostGetBusinessConnectionRequest) (*GetBusinessConnectionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBusinessConnectionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetBusinessConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getBusinessConnection"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetChatRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *LeaveChatRequestChatId
}

func (r ApiPostGetChatRequest) ChatId(chatId LeaveChatRequestChatId) ApiPostGetChatRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostGetChatRequest) Execute() (*GetChatResponse, *http.Response, error) {
	return r.ApiService.PostGetChatExecute(r)
}

/*
PostGetChat getChat

Use this method to get up-to-date information about the chat. Returns a [ChatFullInfo](https://core.telegram.org/bots/api/#chatfullinfo) object on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetChatRequest
*/
func (a *DefaultAPIService) PostGetChat(ctx context.Context) ApiPostGetChatRequest {
	return ApiPostGetChatRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetChatResponse
func (a *DefaultAPIService) PostGetChatExecute(r ApiPostGetChatRequest) (*GetChatResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetChatResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetChat")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getChat"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetChatAdministratorsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *LeaveChatRequestChatId
}

func (r ApiPostGetChatAdministratorsRequest) ChatId(chatId LeaveChatRequestChatId) ApiPostGetChatAdministratorsRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostGetChatAdministratorsRequest) Execute() (*GetChatAdministratorsResponse, *http.Response, error) {
	return r.ApiService.PostGetChatAdministratorsExecute(r)
}

/*
PostGetChatAdministrators getChatAdministrators

Use this method to get a list of administrators in a chat, which aren't bots. Returns an Array of [ChatMember](https://core.telegram.org/bots/api/#chatmember) objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetChatAdministratorsRequest
*/
func (a *DefaultAPIService) PostGetChatAdministrators(ctx context.Context) ApiPostGetChatAdministratorsRequest {
	return ApiPostGetChatAdministratorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetChatAdministratorsResponse
func (a *DefaultAPIService) PostGetChatAdministratorsExecute(r ApiPostGetChatAdministratorsRequest) (*GetChatAdministratorsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetChatAdministratorsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetChatAdministrators")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getChatAdministrators"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetChatMemberRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *LeaveChatRequestChatId
	userId *int32
}

func (r ApiPostGetChatMemberRequest) ChatId(chatId LeaveChatRequestChatId) ApiPostGetChatMemberRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the target user
func (r ApiPostGetChatMemberRequest) UserId(userId int32) ApiPostGetChatMemberRequest {
	r.userId = &userId
	return r
}

func (r ApiPostGetChatMemberRequest) Execute() (*GetChatMemberResponse, *http.Response, error) {
	return r.ApiService.PostGetChatMemberExecute(r)
}

/*
PostGetChatMember getChatMember

Use this method to get information about a member of a chat. The method is only guaranteed to work for other users if the bot is an administrator in the chat. Returns a [ChatMember](https://core.telegram.org/bots/api/#chatmember) object on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetChatMemberRequest
*/
func (a *DefaultAPIService) PostGetChatMember(ctx context.Context) ApiPostGetChatMemberRequest {
	return ApiPostGetChatMemberRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetChatMemberResponse
func (a *DefaultAPIService) PostGetChatMemberExecute(r ApiPostGetChatMemberRequest) (*GetChatMemberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetChatMemberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetChatMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getChatMember"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetChatMemberCountRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *LeaveChatRequestChatId
}

func (r ApiPostGetChatMemberCountRequest) ChatId(chatId LeaveChatRequestChatId) ApiPostGetChatMemberCountRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostGetChatMemberCountRequest) Execute() (*GetChatMemberCountResponse, *http.Response, error) {
	return r.ApiService.PostGetChatMemberCountExecute(r)
}

/*
PostGetChatMemberCount getChatMemberCount

Use this method to get the number of members in a chat. Returns *Int* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetChatMemberCountRequest
*/
func (a *DefaultAPIService) PostGetChatMemberCount(ctx context.Context) ApiPostGetChatMemberCountRequest {
	return ApiPostGetChatMemberCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetChatMemberCountResponse
func (a *DefaultAPIService) PostGetChatMemberCountExecute(r ApiPostGetChatMemberCountRequest) (*GetChatMemberCountResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetChatMemberCountResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetChatMemberCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getChatMemberCount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetChatMenuButtonRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *int32
}

// Unique identifier for the target private chat. If not specified, default bot&#39;s menu button will be returned
func (r ApiPostGetChatMenuButtonRequest) ChatId(chatId int32) ApiPostGetChatMenuButtonRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostGetChatMenuButtonRequest) Execute() (*GetChatMenuButtonResponse, *http.Response, error) {
	return r.ApiService.PostGetChatMenuButtonExecute(r)
}

/*
PostGetChatMenuButton getChatMenuButton

Use this method to get the current value of the bot's menu button in a private chat, or the default menu button. Returns [MenuButton](https://core.telegram.org/bots/api/#menubutton) on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetChatMenuButtonRequest
*/
func (a *DefaultAPIService) PostGetChatMenuButton(ctx context.Context) ApiPostGetChatMenuButtonRequest {
	return ApiPostGetChatMenuButtonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetChatMenuButtonResponse
func (a *DefaultAPIService) PostGetChatMenuButtonExecute(r ApiPostGetChatMenuButtonRequest) (*GetChatMenuButtonResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetChatMenuButtonResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetChatMenuButton")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getChatMenuButton"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.chatId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetCustomEmojiStickersRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	customEmojiIds *[]string
}

// A JSON-serialized list of custom emoji identifiers. At most 200 custom emoji identifiers can be specified.
func (r ApiPostGetCustomEmojiStickersRequest) CustomEmojiIds(customEmojiIds []string) ApiPostGetCustomEmojiStickersRequest {
	r.customEmojiIds = &customEmojiIds
	return r
}

func (r ApiPostGetCustomEmojiStickersRequest) Execute() (*GetCustomEmojiStickersResponse, *http.Response, error) {
	return r.ApiService.PostGetCustomEmojiStickersExecute(r)
}

/*
PostGetCustomEmojiStickers getCustomEmojiStickers

Use this method to get information about custom emoji stickers by their identifiers. Returns an Array of [Sticker](https://core.telegram.org/bots/api/#sticker) objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetCustomEmojiStickersRequest
*/
func (a *DefaultAPIService) PostGetCustomEmojiStickers(ctx context.Context) ApiPostGetCustomEmojiStickersRequest {
	return ApiPostGetCustomEmojiStickersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCustomEmojiStickersResponse
func (a *DefaultAPIService) PostGetCustomEmojiStickersExecute(r ApiPostGetCustomEmojiStickersRequest) (*GetCustomEmojiStickersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCustomEmojiStickersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetCustomEmojiStickers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getCustomEmojiStickers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.customEmojiIds == nil {
		return localVarReturnValue, nil, reportError("customEmojiIds is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "custom_emoji_ids", r.customEmojiIds, "", "csv")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetFileRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	fileId *string
}

// File identifier to get information about
func (r ApiPostGetFileRequest) FileId(fileId string) ApiPostGetFileRequest {
	r.fileId = &fileId
	return r
}

func (r ApiPostGetFileRequest) Execute() (*GetFileResponse, *http.Response, error) {
	return r.ApiService.PostGetFileExecute(r)
}

/*
PostGetFile getFile

Use this method to get basic information about a file and prepare it for downloading. For the moment, bots can download files of up to 20MB in size. On success, a [File](https://core.telegram.org/bots/api/#file) object is returned. The file can then be downloaded via the link `https://api.telegram.org/file/bot<token>/<file_path>`, where `<file_path>` is taken from the response. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling [getFile](https://core.telegram.org/bots/api/#getfile) again.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetFileRequest
*/
func (a *DefaultAPIService) PostGetFile(ctx context.Context) ApiPostGetFileRequest {
	return ApiPostGetFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetFileResponse
func (a *DefaultAPIService) PostGetFileExecute(r ApiPostGetFileRequest) (*GetFileResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetFileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getFile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileId == nil {
		return localVarReturnValue, nil, reportError("fileId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "file_id", r.fileId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetForumTopicIconStickersRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiPostGetForumTopicIconStickersRequest) Execute() (*GetForumTopicIconStickersResponse, *http.Response, error) {
	return r.ApiService.PostGetForumTopicIconStickersExecute(r)
}

/*
PostGetForumTopicIconStickers getForumTopicIconStickers

Use this method to get custom emoji stickers, which can be used as a forum topic icon by any user. Requires no parameters. Returns an Array of [Sticker](https://core.telegram.org/bots/api/#sticker) objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetForumTopicIconStickersRequest
*/
func (a *DefaultAPIService) PostGetForumTopicIconStickers(ctx context.Context) ApiPostGetForumTopicIconStickersRequest {
	return ApiPostGetForumTopicIconStickersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetForumTopicIconStickersResponse
func (a *DefaultAPIService) PostGetForumTopicIconStickersExecute(r ApiPostGetForumTopicIconStickersRequest) (*GetForumTopicIconStickersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetForumTopicIconStickersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetForumTopicIconStickers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getForumTopicIconStickers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetGameHighScoresRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	chatId *int32
	messageId *int32
	inlineMessageId *string
}

// Target user id
func (r ApiPostGetGameHighScoresRequest) UserId(userId int32) ApiPostGetGameHighScoresRequest {
	r.userId = &userId
	return r
}

// Required if *inline\\\\_message\\\\_id* is not specified. Unique identifier for the target chat
func (r ApiPostGetGameHighScoresRequest) ChatId(chatId int32) ApiPostGetGameHighScoresRequest {
	r.chatId = &chatId
	return r
}

// Required if *inline\\\\_message\\\\_id* is not specified. Identifier of the sent message
func (r ApiPostGetGameHighScoresRequest) MessageId(messageId int32) ApiPostGetGameHighScoresRequest {
	r.messageId = &messageId
	return r
}

// Required if *chat\\\\_id* and *message\\\\_id* are not specified. Identifier of the inline message
func (r ApiPostGetGameHighScoresRequest) InlineMessageId(inlineMessageId string) ApiPostGetGameHighScoresRequest {
	r.inlineMessageId = &inlineMessageId
	return r
}

func (r ApiPostGetGameHighScoresRequest) Execute() (*GetGameHighScoresResponse, *http.Response, error) {
	return r.ApiService.PostGetGameHighScoresExecute(r)
}

/*
PostGetGameHighScores getGameHighScores

Use this method to get data for high score tables. Will return the score of the specified user and several of their neighbors in a game. Returns an Array of [GameHighScore](https://core.telegram.org/bots/api/#gamehighscore) objects.

This method will currently return scores for the target user, plus two of their closest neighbors on each side. Will also return the top three users if the user and their neighbors are not among them. Please note that this behavior is subject to change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetGameHighScoresRequest
*/
func (a *DefaultAPIService) PostGetGameHighScores(ctx context.Context) ApiPostGetGameHighScoresRequest {
	return ApiPostGetGameHighScoresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetGameHighScoresResponse
func (a *DefaultAPIService) PostGetGameHighScoresExecute(r ApiPostGetGameHighScoresRequest) (*GetGameHighScoresResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetGameHighScoresResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetGameHighScores")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getGameHighScores"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	if r.chatId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	}
	if r.messageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	}
	if r.inlineMessageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "inline_message_id", r.inlineMessageId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetMeRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiPostGetMeRequest) Execute() (*GetMeResponse, *http.Response, error) {
	return r.ApiService.PostGetMeExecute(r)
}

/*
PostGetMe getMe

A simple method for testing your bot's authentication token. Requires no parameters. Returns basic information about the bot in form of a [User](https://core.telegram.org/bots/api/#user) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetMeRequest
*/
func (a *DefaultAPIService) PostGetMe(ctx context.Context) ApiPostGetMeRequest {
	return ApiPostGetMeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMeResponse
func (a *DefaultAPIService) PostGetMeExecute(r ApiPostGetMeRequest) (*GetMeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetMe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getMe"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetMyCommandsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	scope *BotCommandScope
	languageCode *string
}

func (r ApiPostGetMyCommandsRequest) Scope(scope BotCommandScope) ApiPostGetMyCommandsRequest {
	r.scope = &scope
	return r
}

// A two-letter ISO 639-1 language code or an empty string
func (r ApiPostGetMyCommandsRequest) LanguageCode(languageCode string) ApiPostGetMyCommandsRequest {
	r.languageCode = &languageCode
	return r
}

func (r ApiPostGetMyCommandsRequest) Execute() (*GetMyCommandsResponse, *http.Response, error) {
	return r.ApiService.PostGetMyCommandsExecute(r)
}

/*
PostGetMyCommands getMyCommands

Use this method to get the current list of the bot's commands for the given scope and user language. Returns an Array of [BotCommand](https://core.telegram.org/bots/api/#botcommand) objects. If commands aren't set, an empty list is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetMyCommandsRequest
*/
func (a *DefaultAPIService) PostGetMyCommands(ctx context.Context) ApiPostGetMyCommandsRequest {
	return ApiPostGetMyCommandsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMyCommandsResponse
func (a *DefaultAPIService) PostGetMyCommandsExecute(r ApiPostGetMyCommandsRequest) (*GetMyCommandsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMyCommandsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetMyCommands")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getMyCommands"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.scope != nil {
		paramJson, err := parameterToJson(*r.scope)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("scope", paramJson)
	}
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "language_code", r.languageCode, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetMyDefaultAdministratorRightsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	forChannels *bool
}

// Pass *True* to get default administrator rights of the bot in channels. Otherwise, default administrator rights of the bot for groups and supergroups will be returned.
func (r ApiPostGetMyDefaultAdministratorRightsRequest) ForChannels(forChannels bool) ApiPostGetMyDefaultAdministratorRightsRequest {
	r.forChannels = &forChannels
	return r
}

func (r ApiPostGetMyDefaultAdministratorRightsRequest) Execute() (*GetMyDefaultAdministratorRightsResponse, *http.Response, error) {
	return r.ApiService.PostGetMyDefaultAdministratorRightsExecute(r)
}

/*
PostGetMyDefaultAdministratorRights getMyDefaultAdministratorRights

Use this method to get the current default administrator rights of the bot. Returns [ChatAdministratorRights](https://core.telegram.org/bots/api/#chatadministratorrights) on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetMyDefaultAdministratorRightsRequest
*/
func (a *DefaultAPIService) PostGetMyDefaultAdministratorRights(ctx context.Context) ApiPostGetMyDefaultAdministratorRightsRequest {
	return ApiPostGetMyDefaultAdministratorRightsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMyDefaultAdministratorRightsResponse
func (a *DefaultAPIService) PostGetMyDefaultAdministratorRightsExecute(r ApiPostGetMyDefaultAdministratorRightsRequest) (*GetMyDefaultAdministratorRightsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMyDefaultAdministratorRightsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetMyDefaultAdministratorRights")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getMyDefaultAdministratorRights"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.forChannels != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "for_channels", r.forChannels, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetMyDescriptionRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	languageCode *string
}

// A two-letter ISO 639-1 language code or an empty string
func (r ApiPostGetMyDescriptionRequest) LanguageCode(languageCode string) ApiPostGetMyDescriptionRequest {
	r.languageCode = &languageCode
	return r
}

func (r ApiPostGetMyDescriptionRequest) Execute() (*GetMyDescriptionResponse, *http.Response, error) {
	return r.ApiService.PostGetMyDescriptionExecute(r)
}

/*
PostGetMyDescription getMyDescription

Use this method to get the current bot description for the given user language. Returns [BotDescription](https://core.telegram.org/bots/api/#botdescription) on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetMyDescriptionRequest
*/
func (a *DefaultAPIService) PostGetMyDescription(ctx context.Context) ApiPostGetMyDescriptionRequest {
	return ApiPostGetMyDescriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMyDescriptionResponse
func (a *DefaultAPIService) PostGetMyDescriptionExecute(r ApiPostGetMyDescriptionRequest) (*GetMyDescriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMyDescriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetMyDescription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getMyDescription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "language_code", r.languageCode, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetMyNameRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	languageCode *string
}

// A two-letter ISO 639-1 language code or an empty string
func (r ApiPostGetMyNameRequest) LanguageCode(languageCode string) ApiPostGetMyNameRequest {
	r.languageCode = &languageCode
	return r
}

func (r ApiPostGetMyNameRequest) Execute() (*GetMyNameResponse, *http.Response, error) {
	return r.ApiService.PostGetMyNameExecute(r)
}

/*
PostGetMyName getMyName

Use this method to get the current bot name for the given user language. Returns [BotName](https://core.telegram.org/bots/api/#botname) on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetMyNameRequest
*/
func (a *DefaultAPIService) PostGetMyName(ctx context.Context) ApiPostGetMyNameRequest {
	return ApiPostGetMyNameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMyNameResponse
func (a *DefaultAPIService) PostGetMyNameExecute(r ApiPostGetMyNameRequest) (*GetMyNameResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMyNameResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetMyName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getMyName"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "language_code", r.languageCode, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetMyShortDescriptionRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	languageCode *string
}

// A two-letter ISO 639-1 language code or an empty string
func (r ApiPostGetMyShortDescriptionRequest) LanguageCode(languageCode string) ApiPostGetMyShortDescriptionRequest {
	r.languageCode = &languageCode
	return r
}

func (r ApiPostGetMyShortDescriptionRequest) Execute() (*GetMyShortDescriptionResponse, *http.Response, error) {
	return r.ApiService.PostGetMyShortDescriptionExecute(r)
}

/*
PostGetMyShortDescription getMyShortDescription

Use this method to get the current bot short description for the given user language. Returns [BotShortDescription](https://core.telegram.org/bots/api/#botshortdescription) on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetMyShortDescriptionRequest
*/
func (a *DefaultAPIService) PostGetMyShortDescription(ctx context.Context) ApiPostGetMyShortDescriptionRequest {
	return ApiPostGetMyShortDescriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMyShortDescriptionResponse
func (a *DefaultAPIService) PostGetMyShortDescriptionExecute(r ApiPostGetMyShortDescriptionRequest) (*GetMyShortDescriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMyShortDescriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetMyShortDescription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getMyShortDescription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "language_code", r.languageCode, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetMyStarBalanceRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiPostGetMyStarBalanceRequest) Execute() (*GetMyStarBalanceResponse, *http.Response, error) {
	return r.ApiService.PostGetMyStarBalanceExecute(r)
}

/*
PostGetMyStarBalance getMyStarBalance

A method to get the current Telegram Stars balance of the bot. Requires no parameters. On success, returns a [StarAmount](https://core.telegram.org/bots/api/#staramount) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetMyStarBalanceRequest
*/
func (a *DefaultAPIService) PostGetMyStarBalance(ctx context.Context) ApiPostGetMyStarBalanceRequest {
	return ApiPostGetMyStarBalanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMyStarBalanceResponse
func (a *DefaultAPIService) PostGetMyStarBalanceExecute(r ApiPostGetMyStarBalanceRequest) (*GetMyStarBalanceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMyStarBalanceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetMyStarBalance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getMyStarBalance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetStarTransactionsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	offset *int32
	limit *int32
}

// Number of transactions to skip in the response
func (r ApiPostGetStarTransactionsRequest) Offset(offset int32) ApiPostGetStarTransactionsRequest {
	r.offset = &offset
	return r
}

// The maximum number of transactions to be retrieved. Values between 1-100 are accepted. Defaults to 100.
func (r ApiPostGetStarTransactionsRequest) Limit(limit int32) ApiPostGetStarTransactionsRequest {
	r.limit = &limit
	return r
}

func (r ApiPostGetStarTransactionsRequest) Execute() (*GetStarTransactionsResponse, *http.Response, error) {
	return r.ApiService.PostGetStarTransactionsExecute(r)
}

/*
PostGetStarTransactions getStarTransactions

Returns the bot's Telegram Star transactions in chronological order. On success, returns a [StarTransactions](https://core.telegram.org/bots/api/#startransactions) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetStarTransactionsRequest
*/
func (a *DefaultAPIService) PostGetStarTransactions(ctx context.Context) ApiPostGetStarTransactionsRequest {
	return ApiPostGetStarTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetStarTransactionsResponse
func (a *DefaultAPIService) PostGetStarTransactionsExecute(r ApiPostGetStarTransactionsRequest) (*GetStarTransactionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetStarTransactionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetStarTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getStarTransactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "offset", r.offset, "", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limit", r.limit, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetStickerSetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	name *string
}

// Name of the sticker set
func (r ApiPostGetStickerSetRequest) Name(name string) ApiPostGetStickerSetRequest {
	r.name = &name
	return r
}

func (r ApiPostGetStickerSetRequest) Execute() (*GetStickerSetResponse, *http.Response, error) {
	return r.ApiService.PostGetStickerSetExecute(r)
}

/*
PostGetStickerSet getStickerSet

Use this method to get a sticker set. On success, a [StickerSet](https://core.telegram.org/bots/api/#stickerset) object is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetStickerSetRequest
*/
func (a *DefaultAPIService) PostGetStickerSet(ctx context.Context) ApiPostGetStickerSetRequest {
	return ApiPostGetStickerSetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetStickerSetResponse
func (a *DefaultAPIService) PostGetStickerSetExecute(r ApiPostGetStickerSetRequest) (*GetStickerSetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetStickerSetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetStickerSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getStickerSet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetUpdatesRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	offset *int32
	limit *int32
	timeout *int32
	allowedUpdates *[]string
}

// Identifier of the first update to be returned. Must be greater by one than the highest among the identifiers of previously received updates. By default, updates starting with the earliest unconfirmed update are returned. An update is considered confirmed as soon as [getUpdates](https://core.telegram.org/bots/api/#getupdates) is called with an *offset* higher than its *update\\\\_id*. The negative offset can be specified to retrieve updates starting from *-offset* update from the end of the updates queue. All previous updates will be forgotten.
func (r ApiPostGetUpdatesRequest) Offset(offset int32) ApiPostGetUpdatesRequest {
	r.offset = &offset
	return r
}

// Limits the number of updates to be retrieved. Values between 1-100 are accepted. Defaults to 100.
func (r ApiPostGetUpdatesRequest) Limit(limit int32) ApiPostGetUpdatesRequest {
	r.limit = &limit
	return r
}

// Timeout in seconds for long polling. Defaults to 0, i.e. usual short polling. Should be positive, short polling should be used for testing purposes only.
func (r ApiPostGetUpdatesRequest) Timeout(timeout int32) ApiPostGetUpdatesRequest {
	r.timeout = &timeout
	return r
}

// A JSON-serialized list of the update types you want your bot to receive. For example, specify &#x60;[\\\&quot;message\\\&quot;, \\\&quot;edited_channel_post\\\&quot;, \\\&quot;callback_query\\\&quot;]&#x60; to only receive updates of these types. See [Update](https://core.telegram.org/bots/api/#update) for a complete list of available update types. Specify an empty list to receive all update types except *chat\\\\_member*, *message\\\\_reaction*, and *message\\\\_reaction\\\\_count* (default). If not specified, the previous setting will be used.    Please note that this parameter doesn&#39;t affect updates created before the call to getUpdates, so unwanted updates may be received for a short period of time.
func (r ApiPostGetUpdatesRequest) AllowedUpdates(allowedUpdates []string) ApiPostGetUpdatesRequest {
	r.allowedUpdates = &allowedUpdates
	return r
}

func (r ApiPostGetUpdatesRequest) Execute() (*GetUpdatesResponse, *http.Response, error) {
	return r.ApiService.PostGetUpdatesExecute(r)
}

/*
PostGetUpdates getUpdates

Use this method to receive incoming updates using long polling ([wiki](https://en.wikipedia.org/wiki/Push_technology#Long_polling)). Returns an Array of [Update](https://core.telegram.org/bots/api/#update) objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetUpdatesRequest
*/
func (a *DefaultAPIService) PostGetUpdates(ctx context.Context) ApiPostGetUpdatesRequest {
	return ApiPostGetUpdatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetUpdatesResponse
func (a *DefaultAPIService) PostGetUpdatesExecute(r ApiPostGetUpdatesRequest) (*GetUpdatesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetUpdatesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetUpdates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getUpdates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "offset", r.offset, "", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limit", r.limit, "", "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeout", r.timeout, "", "")
	}
	if r.allowedUpdates != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allowed_updates", r.allowedUpdates, "", "csv")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetUserChatBoostsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *GetUserChatBoostsRequestChatId
	userId *int32
}

func (r ApiPostGetUserChatBoostsRequest) ChatId(chatId GetUserChatBoostsRequestChatId) ApiPostGetUserChatBoostsRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the target user
func (r ApiPostGetUserChatBoostsRequest) UserId(userId int32) ApiPostGetUserChatBoostsRequest {
	r.userId = &userId
	return r
}

func (r ApiPostGetUserChatBoostsRequest) Execute() (*GetUserChatBoostsResponse, *http.Response, error) {
	return r.ApiService.PostGetUserChatBoostsExecute(r)
}

/*
PostGetUserChatBoosts getUserChatBoosts

Use this method to get the list of boosts added to a chat by a user. Requires administrator rights in the chat. Returns a [UserChatBoosts](https://core.telegram.org/bots/api/#userchatboosts) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetUserChatBoostsRequest
*/
func (a *DefaultAPIService) PostGetUserChatBoosts(ctx context.Context) ApiPostGetUserChatBoostsRequest {
	return ApiPostGetUserChatBoostsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetUserChatBoostsResponse
func (a *DefaultAPIService) PostGetUserChatBoostsExecute(r ApiPostGetUserChatBoostsRequest) (*GetUserChatBoostsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetUserChatBoostsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetUserChatBoosts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getUserChatBoosts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetUserProfilePhotosRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	offset *int32
	limit *int32
}

// Unique identifier of the target user
func (r ApiPostGetUserProfilePhotosRequest) UserId(userId int32) ApiPostGetUserProfilePhotosRequest {
	r.userId = &userId
	return r
}

// Sequential number of the first photo to be returned. By default, all photos are returned.
func (r ApiPostGetUserProfilePhotosRequest) Offset(offset int32) ApiPostGetUserProfilePhotosRequest {
	r.offset = &offset
	return r
}

// Limits the number of photos to be retrieved. Values between 1-100 are accepted. Defaults to 100.
func (r ApiPostGetUserProfilePhotosRequest) Limit(limit int32) ApiPostGetUserProfilePhotosRequest {
	r.limit = &limit
	return r
}

func (r ApiPostGetUserProfilePhotosRequest) Execute() (*GetUserProfilePhotosResponse, *http.Response, error) {
	return r.ApiService.PostGetUserProfilePhotosExecute(r)
}

/*
PostGetUserProfilePhotos getUserProfilePhotos

Use this method to get a list of profile pictures for a user. Returns a [UserProfilePhotos](https://core.telegram.org/bots/api/#userprofilephotos) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetUserProfilePhotosRequest
*/
func (a *DefaultAPIService) PostGetUserProfilePhotos(ctx context.Context) ApiPostGetUserProfilePhotosRequest {
	return ApiPostGetUserProfilePhotosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetUserProfilePhotosResponse
func (a *DefaultAPIService) PostGetUserProfilePhotosExecute(r ApiPostGetUserProfilePhotosRequest) (*GetUserProfilePhotosResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetUserProfilePhotosResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetUserProfilePhotos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getUserProfilePhotos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "offset", r.offset, "", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limit", r.limit, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGetWebhookInfoRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiPostGetWebhookInfoRequest) Execute() (*GetWebhookInfoResponse, *http.Response, error) {
	return r.ApiService.PostGetWebhookInfoExecute(r)
}

/*
PostGetWebhookInfo getWebhookInfo

Use this method to get current webhook status. Requires no parameters. On success, returns a [WebhookInfo](https://core.telegram.org/bots/api/#webhookinfo) object. If the bot is using [getUpdates](https://core.telegram.org/bots/api/#getupdates), will return an object with the *url* field empty.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGetWebhookInfoRequest
*/
func (a *DefaultAPIService) PostGetWebhookInfo(ctx context.Context) ApiPostGetWebhookInfoRequest {
	return ApiPostGetWebhookInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetWebhookInfoResponse
func (a *DefaultAPIService) PostGetWebhookInfoExecute(r ApiPostGetWebhookInfoRequest) (*GetWebhookInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetWebhookInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGetWebhookInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getWebhookInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGiftPremiumSubscriptionRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	monthCount *int32
	starCount *int32
	text *string
	textParseMode *string
	textEntities *[]MessageEntity
}

// Unique identifier of the target user who will receive a Telegram Premium subscription
func (r ApiPostGiftPremiumSubscriptionRequest) UserId(userId int32) ApiPostGiftPremiumSubscriptionRequest {
	r.userId = &userId
	return r
}

// Number of months the Telegram Premium subscription will be active for the user; must be one of 3, 6, or 12
func (r ApiPostGiftPremiumSubscriptionRequest) MonthCount(monthCount int32) ApiPostGiftPremiumSubscriptionRequest {
	r.monthCount = &monthCount
	return r
}

// Number of Telegram Stars to pay for the Telegram Premium subscription; must be 1000 for 3 months, 1500 for 6 months, and 2500 for 12 months
func (r ApiPostGiftPremiumSubscriptionRequest) StarCount(starCount int32) ApiPostGiftPremiumSubscriptionRequest {
	r.starCount = &starCount
	return r
}

// Text that will be shown along with the service message about the subscription; 0-128 characters
func (r ApiPostGiftPremiumSubscriptionRequest) Text(text string) ApiPostGiftPremiumSubscriptionRequest {
	r.text = &text
	return r
}

// Mode for parsing entities in the text. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details. Entities other than “bold”, “italic”, “underline”, “strikethrough”, “spoiler”, and “custom\\\\_emoji” are ignored.
func (r ApiPostGiftPremiumSubscriptionRequest) TextParseMode(textParseMode string) ApiPostGiftPremiumSubscriptionRequest {
	r.textParseMode = &textParseMode
	return r
}

// A JSON-serialized list of special entities that appear in the gift text. It can be specified instead of *text\\\\_parse\\\\_mode*. Entities other than “bold”, “italic”, “underline”, “strikethrough”, “spoiler”, and “custom\\\\_emoji” are ignored.
func (r ApiPostGiftPremiumSubscriptionRequest) TextEntities(textEntities []MessageEntity) ApiPostGiftPremiumSubscriptionRequest {
	r.textEntities = &textEntities
	return r
}

func (r ApiPostGiftPremiumSubscriptionRequest) Execute() (*GiftPremiumSubscriptionResponse, *http.Response, error) {
	return r.ApiService.PostGiftPremiumSubscriptionExecute(r)
}

/*
PostGiftPremiumSubscription giftPremiumSubscription

Gifts a Telegram Premium subscription to the given user. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostGiftPremiumSubscriptionRequest
*/
func (a *DefaultAPIService) PostGiftPremiumSubscription(ctx context.Context) ApiPostGiftPremiumSubscriptionRequest {
	return ApiPostGiftPremiumSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GiftPremiumSubscriptionResponse
func (a *DefaultAPIService) PostGiftPremiumSubscriptionExecute(r ApiPostGiftPremiumSubscriptionRequest) (*GiftPremiumSubscriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GiftPremiumSubscriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostGiftPremiumSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/giftPremiumSubscription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.monthCount == nil {
		return localVarReturnValue, nil, reportError("monthCount is required and must be specified")
	}
	if r.starCount == nil {
		return localVarReturnValue, nil, reportError("starCount is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "month_count", r.monthCount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "star_count", r.starCount, "", "")
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "text", r.text, "", "")
	}
	if r.textParseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "text_parse_mode", r.textParseMode, "", "")
	}
	if r.textEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "text_entities", r.textEntities, "", "csv")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostHideGeneralForumTopicRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *BotCommandScopeChatChatId
}

func (r ApiPostHideGeneralForumTopicRequest) ChatId(chatId BotCommandScopeChatChatId) ApiPostHideGeneralForumTopicRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostHideGeneralForumTopicRequest) Execute() (*HideGeneralForumTopicResponse, *http.Response, error) {
	return r.ApiService.PostHideGeneralForumTopicExecute(r)
}

/*
PostHideGeneralForumTopic hideGeneralForumTopic

Use this method to hide the 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. The topic will be automatically closed if it was open. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostHideGeneralForumTopicRequest
*/
func (a *DefaultAPIService) PostHideGeneralForumTopic(ctx context.Context) ApiPostHideGeneralForumTopicRequest {
	return ApiPostHideGeneralForumTopicRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HideGeneralForumTopicResponse
func (a *DefaultAPIService) PostHideGeneralForumTopicExecute(r ApiPostHideGeneralForumTopicRequest) (*HideGeneralForumTopicResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HideGeneralForumTopicResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostHideGeneralForumTopic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hideGeneralForumTopic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostLeaveChatRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *LeaveChatRequestChatId
}

func (r ApiPostLeaveChatRequest) ChatId(chatId LeaveChatRequestChatId) ApiPostLeaveChatRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostLeaveChatRequest) Execute() (*LeaveChatResponse, *http.Response, error) {
	return r.ApiService.PostLeaveChatExecute(r)
}

/*
PostLeaveChat leaveChat

Use this method for your bot to leave a group, supergroup or channel. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostLeaveChatRequest
*/
func (a *DefaultAPIService) PostLeaveChat(ctx context.Context) ApiPostLeaveChatRequest {
	return ApiPostLeaveChatRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LeaveChatResponse
func (a *DefaultAPIService) PostLeaveChatExecute(r ApiPostLeaveChatRequest) (*LeaveChatResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LeaveChatResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostLeaveChat")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/leaveChat"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostLogOutRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiPostLogOutRequest) Execute() (*LogOutResponse, *http.Response, error) {
	return r.ApiService.PostLogOutExecute(r)
}

/*
PostLogOut logOut

Use this method to log out from the cloud Bot API server before launching the bot locally. You **must** log out the bot before running it locally, otherwise there is no guarantee that the bot will receive updates. After a successful call, you can immediately log in on a local server, but will not be able to log in back to the cloud Bot API server for 10 minutes. Returns *True* on success. Requires no parameters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostLogOutRequest
*/
func (a *DefaultAPIService) PostLogOut(ctx context.Context) ApiPostLogOutRequest {
	return ApiPostLogOutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LogOutResponse
func (a *DefaultAPIService) PostLogOutExecute(r ApiPostLogOutRequest) (*LogOutResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogOutResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostLogOut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/logOut"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostPinChatMessageRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	messageId *int32
	businessConnectionId *string
	disableNotification *bool
}

func (r ApiPostPinChatMessageRequest) ChatId(chatId SendMessageRequestChatId) ApiPostPinChatMessageRequest {
	r.chatId = &chatId
	return r
}

// Identifier of a message to pin
func (r ApiPostPinChatMessageRequest) MessageId(messageId int32) ApiPostPinChatMessageRequest {
	r.messageId = &messageId
	return r
}

// Unique identifier of the business connection on behalf of which the message will be pinned
func (r ApiPostPinChatMessageRequest) BusinessConnectionId(businessConnectionId string) ApiPostPinChatMessageRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Pass *True* if it is not necessary to send a notification to all chat members about the new pinned message. Notifications are always disabled in channels and private chats.
func (r ApiPostPinChatMessageRequest) DisableNotification(disableNotification bool) ApiPostPinChatMessageRequest {
	r.disableNotification = &disableNotification
	return r
}

func (r ApiPostPinChatMessageRequest) Execute() (*PinChatMessageResponse, *http.Response, error) {
	return r.ApiService.PostPinChatMessageExecute(r)
}

/*
PostPinChatMessage pinChatMessage

Use this method to add a message to the list of pinned messages in a chat. If the chat is not a private chat, the bot must be an administrator in the chat for this to work and must have the 'can\_pin\_messages' administrator right in a supergroup or 'can\_edit\_messages' administrator right in a channel. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostPinChatMessageRequest
*/
func (a *DefaultAPIService) PostPinChatMessage(ctx context.Context) ApiPostPinChatMessageRequest {
	return ApiPostPinChatMessageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PinChatMessageResponse
func (a *DefaultAPIService) PostPinChatMessageExecute(r ApiPostPinChatMessageRequest) (*PinChatMessageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PinChatMessageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostPinChatMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pinChatMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.messageId == nil {
		return localVarReturnValue, nil, reportError("messageId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostPostStoryRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	content *InputStoryContent
	activePeriod *int32
	caption *string
	parseMode *string
	captionEntities *[]MessageEntity
	areas *[]StoryArea
	postToChatPage *bool
	protectContent *bool
}

// Unique identifier of the business connection
func (r ApiPostPostStoryRequest) BusinessConnectionId(businessConnectionId string) ApiPostPostStoryRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

func (r ApiPostPostStoryRequest) Content(content InputStoryContent) ApiPostPostStoryRequest {
	r.content = &content
	return r
}

// Period after which the story is moved to the archive, in seconds; must be one of &#x60;6 * 3600&#x60;, &#x60;12 * 3600&#x60;, &#x60;86400&#x60;, or &#x60;2 * 86400&#x60;
func (r ApiPostPostStoryRequest) ActivePeriod(activePeriod int32) ApiPostPostStoryRequest {
	r.activePeriod = &activePeriod
	return r
}

// Caption of the story, 0-2048 characters after entities parsing
func (r ApiPostPostStoryRequest) Caption(caption string) ApiPostPostStoryRequest {
	r.caption = &caption
	return r
}

// Mode for parsing entities in the story caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiPostPostStoryRequest) ParseMode(parseMode string) ApiPostPostStoryRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of *parse\\\\_mode*
func (r ApiPostPostStoryRequest) CaptionEntities(captionEntities []MessageEntity) ApiPostPostStoryRequest {
	r.captionEntities = &captionEntities
	return r
}

// A JSON-serialized list of clickable areas to be shown on the story
func (r ApiPostPostStoryRequest) Areas(areas []StoryArea) ApiPostPostStoryRequest {
	r.areas = &areas
	return r
}

// Pass *True* to keep the story accessible after it expires
func (r ApiPostPostStoryRequest) PostToChatPage(postToChatPage bool) ApiPostPostStoryRequest {
	r.postToChatPage = &postToChatPage
	return r
}

// Pass *True* if the content of the story must be protected from forwarding and screenshotting
func (r ApiPostPostStoryRequest) ProtectContent(protectContent bool) ApiPostPostStoryRequest {
	r.protectContent = &protectContent
	return r
}

func (r ApiPostPostStoryRequest) Execute() (*PostStoryResponse, *http.Response, error) {
	return r.ApiService.PostPostStoryExecute(r)
}

/*
PostPostStory postStory

Posts a story on behalf of a managed business account. Requires the *can\_manage\_stories* business bot right. Returns [Story](https://core.telegram.org/bots/api/#story) on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostPostStoryRequest
*/
func (a *DefaultAPIService) PostPostStory(ctx context.Context) ApiPostPostStoryRequest {
	return ApiPostPostStoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostStoryResponse
func (a *DefaultAPIService) PostPostStoryExecute(r ApiPostPostStoryRequest) (*PostStoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostStoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostPostStory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/postStory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.content == nil {
		return localVarReturnValue, nil, reportError("content is required and must be specified")
	}
	if r.activePeriod == nil {
		return localVarReturnValue, nil, reportError("activePeriod is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "content", r.content, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "active_period", r.activePeriod, "", "")
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption", r.caption, "", "")
	}
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.captionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption_entities", r.captionEntities, "", "csv")
	}
	if r.areas != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "areas", r.areas, "", "csv")
	}
	if r.postToChatPage != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "post_to_chat_page", r.postToChatPage, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostPromoteChatMemberRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	userId *int32
	isAnonymous *bool
	canManageChat *bool
	canDeleteMessages *bool
	canManageVideoChats *bool
	canRestrictMembers *bool
	canPromoteMembers *bool
	canChangeInfo *bool
	canInviteUsers *bool
	canPostStories *bool
	canEditStories *bool
	canDeleteStories *bool
	canPostMessages *bool
	canEditMessages *bool
	canPinMessages *bool
	canManageTopics *bool
}

func (r ApiPostPromoteChatMemberRequest) ChatId(chatId SendMessageRequestChatId) ApiPostPromoteChatMemberRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the target user
func (r ApiPostPromoteChatMemberRequest) UserId(userId int32) ApiPostPromoteChatMemberRequest {
	r.userId = &userId
	return r
}

// Pass *True* if the administrator&#39;s presence in the chat is hidden
func (r ApiPostPromoteChatMemberRequest) IsAnonymous(isAnonymous bool) ApiPostPromoteChatMemberRequest {
	r.isAnonymous = &isAnonymous
	return r
}

// Pass *True* if the administrator can access the chat event log, get boost list, see hidden supergroup and channel members, report spam messages, ignore slow mode, and send messages to the chat without paying Telegram Stars. Implied by any other administrator privilege.
func (r ApiPostPromoteChatMemberRequest) CanManageChat(canManageChat bool) ApiPostPromoteChatMemberRequest {
	r.canManageChat = &canManageChat
	return r
}

// Pass *True* if the administrator can delete messages of other users
func (r ApiPostPromoteChatMemberRequest) CanDeleteMessages(canDeleteMessages bool) ApiPostPromoteChatMemberRequest {
	r.canDeleteMessages = &canDeleteMessages
	return r
}

// Pass *True* if the administrator can manage video chats
func (r ApiPostPromoteChatMemberRequest) CanManageVideoChats(canManageVideoChats bool) ApiPostPromoteChatMemberRequest {
	r.canManageVideoChats = &canManageVideoChats
	return r
}

// Pass *True* if the administrator can restrict, ban or unban chat members, or access supergroup statistics
func (r ApiPostPromoteChatMemberRequest) CanRestrictMembers(canRestrictMembers bool) ApiPostPromoteChatMemberRequest {
	r.canRestrictMembers = &canRestrictMembers
	return r
}

// Pass *True* if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by him)
func (r ApiPostPromoteChatMemberRequest) CanPromoteMembers(canPromoteMembers bool) ApiPostPromoteChatMemberRequest {
	r.canPromoteMembers = &canPromoteMembers
	return r
}

// Pass *True* if the administrator can change chat title, photo and other settings
func (r ApiPostPromoteChatMemberRequest) CanChangeInfo(canChangeInfo bool) ApiPostPromoteChatMemberRequest {
	r.canChangeInfo = &canChangeInfo
	return r
}

// Pass *True* if the administrator can invite new users to the chat
func (r ApiPostPromoteChatMemberRequest) CanInviteUsers(canInviteUsers bool) ApiPostPromoteChatMemberRequest {
	r.canInviteUsers = &canInviteUsers
	return r
}

// Pass *True* if the administrator can post stories to the chat
func (r ApiPostPromoteChatMemberRequest) CanPostStories(canPostStories bool) ApiPostPromoteChatMemberRequest {
	r.canPostStories = &canPostStories
	return r
}

// Pass *True* if the administrator can edit stories posted by other users, post stories to the chat page, pin chat stories, and access the chat&#39;s story archive
func (r ApiPostPromoteChatMemberRequest) CanEditStories(canEditStories bool) ApiPostPromoteChatMemberRequest {
	r.canEditStories = &canEditStories
	return r
}

// Pass *True* if the administrator can delete stories posted by other users
func (r ApiPostPromoteChatMemberRequest) CanDeleteStories(canDeleteStories bool) ApiPostPromoteChatMemberRequest {
	r.canDeleteStories = &canDeleteStories
	return r
}

// Pass *True* if the administrator can post messages in the channel, approve suggested posts, or access channel statistics; for channels only
func (r ApiPostPromoteChatMemberRequest) CanPostMessages(canPostMessages bool) ApiPostPromoteChatMemberRequest {
	r.canPostMessages = &canPostMessages
	return r
}

// Pass *True* if the administrator can edit messages of other users and can pin messages; for channels only
func (r ApiPostPromoteChatMemberRequest) CanEditMessages(canEditMessages bool) ApiPostPromoteChatMemberRequest {
	r.canEditMessages = &canEditMessages
	return r
}

// Pass *True* if the administrator can pin messages; for supergroups only
func (r ApiPostPromoteChatMemberRequest) CanPinMessages(canPinMessages bool) ApiPostPromoteChatMemberRequest {
	r.canPinMessages = &canPinMessages
	return r
}

// Pass *True* if the user is allowed to create, rename, close, and reopen forum topics; for supergroups only
func (r ApiPostPromoteChatMemberRequest) CanManageTopics(canManageTopics bool) ApiPostPromoteChatMemberRequest {
	r.canManageTopics = &canManageTopics
	return r
}

func (r ApiPostPromoteChatMemberRequest) Execute() (*PromoteChatMemberResponse, *http.Response, error) {
	return r.ApiService.PostPromoteChatMemberExecute(r)
}

/*
PostPromoteChatMember promoteChatMember

Use this method to promote or demote a user in a supergroup or a channel. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Pass *False* for all boolean parameters to demote a user. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostPromoteChatMemberRequest
*/
func (a *DefaultAPIService) PostPromoteChatMember(ctx context.Context) ApiPostPromoteChatMemberRequest {
	return ApiPostPromoteChatMemberRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PromoteChatMemberResponse
func (a *DefaultAPIService) PostPromoteChatMemberExecute(r ApiPostPromoteChatMemberRequest) (*PromoteChatMemberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PromoteChatMemberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostPromoteChatMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/promoteChatMember"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	if r.isAnonymous != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_anonymous", r.isAnonymous, "", "")
	}
	if r.canManageChat != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_manage_chat", r.canManageChat, "", "")
	}
	if r.canDeleteMessages != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_delete_messages", r.canDeleteMessages, "", "")
	}
	if r.canManageVideoChats != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_manage_video_chats", r.canManageVideoChats, "", "")
	}
	if r.canRestrictMembers != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_restrict_members", r.canRestrictMembers, "", "")
	}
	if r.canPromoteMembers != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_promote_members", r.canPromoteMembers, "", "")
	}
	if r.canChangeInfo != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_change_info", r.canChangeInfo, "", "")
	}
	if r.canInviteUsers != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_invite_users", r.canInviteUsers, "", "")
	}
	if r.canPostStories != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_post_stories", r.canPostStories, "", "")
	}
	if r.canEditStories != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_edit_stories", r.canEditStories, "", "")
	}
	if r.canDeleteStories != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_delete_stories", r.canDeleteStories, "", "")
	}
	if r.canPostMessages != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_post_messages", r.canPostMessages, "", "")
	}
	if r.canEditMessages != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_edit_messages", r.canEditMessages, "", "")
	}
	if r.canPinMessages != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_pin_messages", r.canPinMessages, "", "")
	}
	if r.canManageTopics != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_manage_topics", r.canManageTopics, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostReadBusinessMessageRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	chatId *int32
	messageId *int32
}

// Unique identifier of the business connection on behalf of which to read the message
func (r ApiPostReadBusinessMessageRequest) BusinessConnectionId(businessConnectionId string) ApiPostReadBusinessMessageRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier of the chat in which the message was received. The chat must have been active in the last 24 hours.
func (r ApiPostReadBusinessMessageRequest) ChatId(chatId int32) ApiPostReadBusinessMessageRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the message to mark as read
func (r ApiPostReadBusinessMessageRequest) MessageId(messageId int32) ApiPostReadBusinessMessageRequest {
	r.messageId = &messageId
	return r
}

func (r ApiPostReadBusinessMessageRequest) Execute() (*ReadBusinessMessageResponse, *http.Response, error) {
	return r.ApiService.PostReadBusinessMessageExecute(r)
}

/*
PostReadBusinessMessage readBusinessMessage

Marks incoming message as read on behalf of a business account. Requires the *can\_read\_messages* business bot right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostReadBusinessMessageRequest
*/
func (a *DefaultAPIService) PostReadBusinessMessage(ctx context.Context) ApiPostReadBusinessMessageRequest {
	return ApiPostReadBusinessMessageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReadBusinessMessageResponse
func (a *DefaultAPIService) PostReadBusinessMessageExecute(r ApiPostReadBusinessMessageRequest) (*ReadBusinessMessageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReadBusinessMessageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostReadBusinessMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/readBusinessMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.messageId == nil {
		return localVarReturnValue, nil, reportError("messageId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRefundStarPaymentRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	telegramPaymentChargeId *string
}

// Identifier of the user whose payment will be refunded
func (r ApiPostRefundStarPaymentRequest) UserId(userId int32) ApiPostRefundStarPaymentRequest {
	r.userId = &userId
	return r
}

// Telegram payment identifier
func (r ApiPostRefundStarPaymentRequest) TelegramPaymentChargeId(telegramPaymentChargeId string) ApiPostRefundStarPaymentRequest {
	r.telegramPaymentChargeId = &telegramPaymentChargeId
	return r
}

func (r ApiPostRefundStarPaymentRequest) Execute() (*RefundStarPaymentResponse, *http.Response, error) {
	return r.ApiService.PostRefundStarPaymentExecute(r)
}

/*
PostRefundStarPayment refundStarPayment

Refunds a successful payment in [Telegram Stars](https://t.me/BotNews/90). Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostRefundStarPaymentRequest
*/
func (a *DefaultAPIService) PostRefundStarPayment(ctx context.Context) ApiPostRefundStarPaymentRequest {
	return ApiPostRefundStarPaymentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RefundStarPaymentResponse
func (a *DefaultAPIService) PostRefundStarPaymentExecute(r ApiPostRefundStarPaymentRequest) (*RefundStarPaymentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RefundStarPaymentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostRefundStarPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/refundStarPayment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.telegramPaymentChargeId == nil {
		return localVarReturnValue, nil, reportError("telegramPaymentChargeId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "telegram_payment_charge_id", r.telegramPaymentChargeId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRemoveBusinessAccountProfilePhotoRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	isPublic *bool
}

// Unique identifier of the business connection
func (r ApiPostRemoveBusinessAccountProfilePhotoRequest) BusinessConnectionId(businessConnectionId string) ApiPostRemoveBusinessAccountProfilePhotoRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Pass *True* to remove the public photo, which is visible even if the main photo is hidden by the business account&#39;s privacy settings. After the main photo is removed, the previous profile photo (if present) becomes the main photo.
func (r ApiPostRemoveBusinessAccountProfilePhotoRequest) IsPublic(isPublic bool) ApiPostRemoveBusinessAccountProfilePhotoRequest {
	r.isPublic = &isPublic
	return r
}

func (r ApiPostRemoveBusinessAccountProfilePhotoRequest) Execute() (*RemoveBusinessAccountProfilePhotoResponse, *http.Response, error) {
	return r.ApiService.PostRemoveBusinessAccountProfilePhotoExecute(r)
}

/*
PostRemoveBusinessAccountProfilePhoto removeBusinessAccountProfilePhoto

Removes the current profile photo of a managed business account. Requires the *can\_edit\_profile\_photo* business bot right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostRemoveBusinessAccountProfilePhotoRequest
*/
func (a *DefaultAPIService) PostRemoveBusinessAccountProfilePhoto(ctx context.Context) ApiPostRemoveBusinessAccountProfilePhotoRequest {
	return ApiPostRemoveBusinessAccountProfilePhotoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RemoveBusinessAccountProfilePhotoResponse
func (a *DefaultAPIService) PostRemoveBusinessAccountProfilePhotoExecute(r ApiPostRemoveBusinessAccountProfilePhotoRequest) (*RemoveBusinessAccountProfilePhotoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RemoveBusinessAccountProfilePhotoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostRemoveBusinessAccountProfilePhoto")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/removeBusinessAccountProfilePhoto"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	if r.isPublic != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_public", r.isPublic, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRemoveChatVerificationRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
}

func (r ApiPostRemoveChatVerificationRequest) ChatId(chatId SendMessageRequestChatId) ApiPostRemoveChatVerificationRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostRemoveChatVerificationRequest) Execute() (*RemoveChatVerificationResponse, *http.Response, error) {
	return r.ApiService.PostRemoveChatVerificationExecute(r)
}

/*
PostRemoveChatVerification removeChatVerification

Removes verification from a chat that is currently verified [on behalf of the organization](https://telegram.org/verify#third-party-verification) represented by the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostRemoveChatVerificationRequest
*/
func (a *DefaultAPIService) PostRemoveChatVerification(ctx context.Context) ApiPostRemoveChatVerificationRequest {
	return ApiPostRemoveChatVerificationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RemoveChatVerificationResponse
func (a *DefaultAPIService) PostRemoveChatVerificationExecute(r ApiPostRemoveChatVerificationRequest) (*RemoveChatVerificationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RemoveChatVerificationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostRemoveChatVerification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/removeChatVerification"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRemoveUserVerificationRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
}

// Unique identifier of the target user
func (r ApiPostRemoveUserVerificationRequest) UserId(userId int32) ApiPostRemoveUserVerificationRequest {
	r.userId = &userId
	return r
}

func (r ApiPostRemoveUserVerificationRequest) Execute() (*RemoveUserVerificationResponse, *http.Response, error) {
	return r.ApiService.PostRemoveUserVerificationExecute(r)
}

/*
PostRemoveUserVerification removeUserVerification

Removes verification from a user who is currently verified [on behalf of the organization](https://telegram.org/verify#third-party-verification) represented by the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostRemoveUserVerificationRequest
*/
func (a *DefaultAPIService) PostRemoveUserVerification(ctx context.Context) ApiPostRemoveUserVerificationRequest {
	return ApiPostRemoveUserVerificationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RemoveUserVerificationResponse
func (a *DefaultAPIService) PostRemoveUserVerificationExecute(r ApiPostRemoveUserVerificationRequest) (*RemoveUserVerificationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RemoveUserVerificationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostRemoveUserVerification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/removeUserVerification"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostReopenForumTopicRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *BotCommandScopeChatChatId
	messageThreadId *int32
}

func (r ApiPostReopenForumTopicRequest) ChatId(chatId BotCommandScopeChatChatId) ApiPostReopenForumTopicRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier for the target message thread of the forum topic
func (r ApiPostReopenForumTopicRequest) MessageThreadId(messageThreadId int32) ApiPostReopenForumTopicRequest {
	r.messageThreadId = &messageThreadId
	return r
}

func (r ApiPostReopenForumTopicRequest) Execute() (*ReopenForumTopicResponse, *http.Response, error) {
	return r.ApiService.PostReopenForumTopicExecute(r)
}

/*
PostReopenForumTopic reopenForumTopic

Use this method to reopen a closed topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights, unless it is the creator of the topic. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostReopenForumTopicRequest
*/
func (a *DefaultAPIService) PostReopenForumTopic(ctx context.Context) ApiPostReopenForumTopicRequest {
	return ApiPostReopenForumTopicRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReopenForumTopicResponse
func (a *DefaultAPIService) PostReopenForumTopicExecute(r ApiPostReopenForumTopicRequest) (*ReopenForumTopicResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReopenForumTopicResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostReopenForumTopic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reopenForumTopic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.messageThreadId == nil {
		return localVarReturnValue, nil, reportError("messageThreadId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostReopenGeneralForumTopicRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *BotCommandScopeChatChatId
}

func (r ApiPostReopenGeneralForumTopicRequest) ChatId(chatId BotCommandScopeChatChatId) ApiPostReopenGeneralForumTopicRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostReopenGeneralForumTopicRequest) Execute() (*ReopenGeneralForumTopicResponse, *http.Response, error) {
	return r.ApiService.PostReopenGeneralForumTopicExecute(r)
}

/*
PostReopenGeneralForumTopic reopenGeneralForumTopic

Use this method to reopen a closed 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. The topic will be automatically unhidden if it was hidden. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostReopenGeneralForumTopicRequest
*/
func (a *DefaultAPIService) PostReopenGeneralForumTopic(ctx context.Context) ApiPostReopenGeneralForumTopicRequest {
	return ApiPostReopenGeneralForumTopicRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReopenGeneralForumTopicResponse
func (a *DefaultAPIService) PostReopenGeneralForumTopicExecute(r ApiPostReopenGeneralForumTopicRequest) (*ReopenGeneralForumTopicResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReopenGeneralForumTopicResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostReopenGeneralForumTopic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reopenGeneralForumTopic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostReplaceStickerInSetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	name *string
	oldSticker *string
	sticker *InputSticker
}

// User identifier of the sticker set owner
func (r ApiPostReplaceStickerInSetRequest) UserId(userId int32) ApiPostReplaceStickerInSetRequest {
	r.userId = &userId
	return r
}

// Sticker set name
func (r ApiPostReplaceStickerInSetRequest) Name(name string) ApiPostReplaceStickerInSetRequest {
	r.name = &name
	return r
}

// File identifier of the replaced sticker
func (r ApiPostReplaceStickerInSetRequest) OldSticker(oldSticker string) ApiPostReplaceStickerInSetRequest {
	r.oldSticker = &oldSticker
	return r
}

func (r ApiPostReplaceStickerInSetRequest) Sticker(sticker InputSticker) ApiPostReplaceStickerInSetRequest {
	r.sticker = &sticker
	return r
}

func (r ApiPostReplaceStickerInSetRequest) Execute() (*ReplaceStickerInSetResponse, *http.Response, error) {
	return r.ApiService.PostReplaceStickerInSetExecute(r)
}

/*
PostReplaceStickerInSet replaceStickerInSet

Use this method to replace an existing sticker in a sticker set with a new one. The method is equivalent to calling [deleteStickerFromSet](https://core.telegram.org/bots/api/#deletestickerfromset), then [addStickerToSet](https://core.telegram.org/bots/api/#addstickertoset), then [setStickerPositionInSet](https://core.telegram.org/bots/api/#setstickerpositioninset). Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostReplaceStickerInSetRequest
*/
func (a *DefaultAPIService) PostReplaceStickerInSet(ctx context.Context) ApiPostReplaceStickerInSetRequest {
	return ApiPostReplaceStickerInSetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReplaceStickerInSetResponse
func (a *DefaultAPIService) PostReplaceStickerInSetExecute(r ApiPostReplaceStickerInSetRequest) (*ReplaceStickerInSetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReplaceStickerInSetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostReplaceStickerInSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/replaceStickerInSet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.oldSticker == nil {
		return localVarReturnValue, nil, reportError("oldSticker is required and must be specified")
	}
	if r.sticker == nil {
		return localVarReturnValue, nil, reportError("sticker is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "old_sticker", r.oldSticker, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "sticker", r.sticker, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRestrictChatMemberRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *BotCommandScopeChatChatId
	userId *int32
	permissions *ChatPermissions
	useIndependentChatPermissions *bool
	untilDate *int32
}

func (r ApiPostRestrictChatMemberRequest) ChatId(chatId BotCommandScopeChatChatId) ApiPostRestrictChatMemberRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the target user
func (r ApiPostRestrictChatMemberRequest) UserId(userId int32) ApiPostRestrictChatMemberRequest {
	r.userId = &userId
	return r
}

func (r ApiPostRestrictChatMemberRequest) Permissions(permissions ChatPermissions) ApiPostRestrictChatMemberRequest {
	r.permissions = &permissions
	return r
}

// Pass *True* if chat permissions are set independently. Otherwise, the *can\\\\_send\\\\_other\\\\_messages* and *can\\\\_add\\\\_web\\\\_page\\\\_previews* permissions will imply the *can\\\\_send\\\\_messages*, *can\\\\_send\\\\_audios*, *can\\\\_send\\\\_documents*, *can\\\\_send\\\\_photos*, *can\\\\_send\\\\_videos*, *can\\\\_send\\\\_video\\\\_notes*, and *can\\\\_send\\\\_voice\\\\_notes* permissions; the *can\\\\_send\\\\_polls* permission will imply the *can\\\\_send\\\\_messages* permission.
func (r ApiPostRestrictChatMemberRequest) UseIndependentChatPermissions(useIndependentChatPermissions bool) ApiPostRestrictChatMemberRequest {
	r.useIndependentChatPermissions = &useIndependentChatPermissions
	return r
}

// Date when restrictions will be lifted for the user; Unix time. If user is restricted for more than 366 days or less than 30 seconds from the current time, they are considered to be restricted forever
func (r ApiPostRestrictChatMemberRequest) UntilDate(untilDate int32) ApiPostRestrictChatMemberRequest {
	r.untilDate = &untilDate
	return r
}

func (r ApiPostRestrictChatMemberRequest) Execute() (*RestrictChatMemberResponse, *http.Response, error) {
	return r.ApiService.PostRestrictChatMemberExecute(r)
}

/*
PostRestrictChatMember restrictChatMember

Use this method to restrict a user in a supergroup. The bot must be an administrator in the supergroup for this to work and must have the appropriate administrator rights. Pass *True* for all permissions to lift restrictions from a user. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostRestrictChatMemberRequest
*/
func (a *DefaultAPIService) PostRestrictChatMember(ctx context.Context) ApiPostRestrictChatMemberRequest {
	return ApiPostRestrictChatMemberRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RestrictChatMemberResponse
func (a *DefaultAPIService) PostRestrictChatMemberExecute(r ApiPostRestrictChatMemberRequest) (*RestrictChatMemberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestrictChatMemberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostRestrictChatMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/restrictChatMember"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.permissions == nil {
		return localVarReturnValue, nil, reportError("permissions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "permissions", r.permissions, "", "")
	if r.useIndependentChatPermissions != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "use_independent_chat_permissions", r.useIndependentChatPermissions, "", "")
	}
	if r.untilDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "until_date", r.untilDate, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRevokeChatInviteLinkRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *RevokeChatInviteLinkRequestChatId
	inviteLink *string
}

func (r ApiPostRevokeChatInviteLinkRequest) ChatId(chatId RevokeChatInviteLinkRequestChatId) ApiPostRevokeChatInviteLinkRequest {
	r.chatId = &chatId
	return r
}

// The invite link to revoke
func (r ApiPostRevokeChatInviteLinkRequest) InviteLink(inviteLink string) ApiPostRevokeChatInviteLinkRequest {
	r.inviteLink = &inviteLink
	return r
}

func (r ApiPostRevokeChatInviteLinkRequest) Execute() (*RevokeChatInviteLinkResponse, *http.Response, error) {
	return r.ApiService.PostRevokeChatInviteLinkExecute(r)
}

/*
PostRevokeChatInviteLink revokeChatInviteLink

Use this method to revoke an invite link created by the bot. If the primary link is revoked, a new link is automatically generated. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns the revoked invite link as [ChatInviteLink](https://core.telegram.org/bots/api/#chatinvitelink) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostRevokeChatInviteLinkRequest
*/
func (a *DefaultAPIService) PostRevokeChatInviteLink(ctx context.Context) ApiPostRevokeChatInviteLinkRequest {
	return ApiPostRevokeChatInviteLinkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RevokeChatInviteLinkResponse
func (a *DefaultAPIService) PostRevokeChatInviteLinkExecute(r ApiPostRevokeChatInviteLinkRequest) (*RevokeChatInviteLinkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RevokeChatInviteLinkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostRevokeChatInviteLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revokeChatInviteLink"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.inviteLink == nil {
		return localVarReturnValue, nil, reportError("inviteLink is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "invite_link", r.inviteLink, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSavePreparedInlineMessageRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	result *InlineQueryResult
	allowUserChats *bool
	allowBotChats *bool
	allowGroupChats *bool
	allowChannelChats *bool
}

// Unique identifier of the target user that can use the prepared message
func (r ApiPostSavePreparedInlineMessageRequest) UserId(userId int32) ApiPostSavePreparedInlineMessageRequest {
	r.userId = &userId
	return r
}

func (r ApiPostSavePreparedInlineMessageRequest) Result(result InlineQueryResult) ApiPostSavePreparedInlineMessageRequest {
	r.result = &result
	return r
}

// Pass *True* if the message can be sent to private chats with users
func (r ApiPostSavePreparedInlineMessageRequest) AllowUserChats(allowUserChats bool) ApiPostSavePreparedInlineMessageRequest {
	r.allowUserChats = &allowUserChats
	return r
}

// Pass *True* if the message can be sent to private chats with bots
func (r ApiPostSavePreparedInlineMessageRequest) AllowBotChats(allowBotChats bool) ApiPostSavePreparedInlineMessageRequest {
	r.allowBotChats = &allowBotChats
	return r
}

// Pass *True* if the message can be sent to group and supergroup chats
func (r ApiPostSavePreparedInlineMessageRequest) AllowGroupChats(allowGroupChats bool) ApiPostSavePreparedInlineMessageRequest {
	r.allowGroupChats = &allowGroupChats
	return r
}

// Pass *True* if the message can be sent to channel chats
func (r ApiPostSavePreparedInlineMessageRequest) AllowChannelChats(allowChannelChats bool) ApiPostSavePreparedInlineMessageRequest {
	r.allowChannelChats = &allowChannelChats
	return r
}

func (r ApiPostSavePreparedInlineMessageRequest) Execute() (*SavePreparedInlineMessageResponse, *http.Response, error) {
	return r.ApiService.PostSavePreparedInlineMessageExecute(r)
}

/*
PostSavePreparedInlineMessage savePreparedInlineMessage

Stores a message that can be sent by a user of a Mini App. Returns a [PreparedInlineMessage](https://core.telegram.org/bots/api/#preparedinlinemessage) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSavePreparedInlineMessageRequest
*/
func (a *DefaultAPIService) PostSavePreparedInlineMessage(ctx context.Context) ApiPostSavePreparedInlineMessageRequest {
	return ApiPostSavePreparedInlineMessageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SavePreparedInlineMessageResponse
func (a *DefaultAPIService) PostSavePreparedInlineMessageExecute(r ApiPostSavePreparedInlineMessageRequest) (*SavePreparedInlineMessageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SavePreparedInlineMessageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSavePreparedInlineMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/savePreparedInlineMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.result == nil {
		return localVarReturnValue, nil, reportError("result is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "result", r.result, "", "")
	if r.allowUserChats != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_user_chats", r.allowUserChats, "", "")
	}
	if r.allowBotChats != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_bot_chats", r.allowBotChats, "", "")
	}
	if r.allowGroupChats != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_group_chats", r.allowGroupChats, "", "")
	}
	if r.allowChannelChats != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_channel_chats", r.allowChannelChats, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSendAnimationRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	animation *string
	businessConnectionId *string
	messageThreadId *int32
	duration *int32
	width *int32
	height *int32
	thumbnail *string
	caption *string
	parseMode *string
	captionEntities *[]MessageEntity
	showCaptionAboveMedia *bool
	hasSpoiler *bool
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessageRequestReplyMarkup
}

func (r ApiPostSendAnimationRequest) ChatId(chatId SendMessageRequestChatId) ApiPostSendAnimationRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostSendAnimationRequest) Animation(animation string) ApiPostSendAnimationRequest {
	r.animation = &animation
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiPostSendAnimationRequest) BusinessConnectionId(businessConnectionId string) ApiPostSendAnimationRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiPostSendAnimationRequest) MessageThreadId(messageThreadId int32) ApiPostSendAnimationRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Duration of sent animation in seconds
func (r ApiPostSendAnimationRequest) Duration(duration int32) ApiPostSendAnimationRequest {
	r.duration = &duration
	return r
}

// Animation width
func (r ApiPostSendAnimationRequest) Width(width int32) ApiPostSendAnimationRequest {
	r.width = &width
	return r
}

// Animation height
func (r ApiPostSendAnimationRequest) Height(height int32) ApiPostSendAnimationRequest {
	r.height = &height
	return r
}

func (r ApiPostSendAnimationRequest) Thumbnail(thumbnail string) ApiPostSendAnimationRequest {
	r.thumbnail = &thumbnail
	return r
}

// Animation caption (may also be used when resending animation by *file\\\\_id*), 0-1024 characters after entities parsing
func (r ApiPostSendAnimationRequest) Caption(caption string) ApiPostSendAnimationRequest {
	r.caption = &caption
	return r
}

// Mode for parsing entities in the animation caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiPostSendAnimationRequest) ParseMode(parseMode string) ApiPostSendAnimationRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of *parse\\\\_mode*
func (r ApiPostSendAnimationRequest) CaptionEntities(captionEntities []MessageEntity) ApiPostSendAnimationRequest {
	r.captionEntities = &captionEntities
	return r
}

// Pass *True*, if the caption must be shown above the message media
func (r ApiPostSendAnimationRequest) ShowCaptionAboveMedia(showCaptionAboveMedia bool) ApiPostSendAnimationRequest {
	r.showCaptionAboveMedia = &showCaptionAboveMedia
	return r
}

// Pass *True* if the animation needs to be covered with a spoiler animation
func (r ApiPostSendAnimationRequest) HasSpoiler(hasSpoiler bool) ApiPostSendAnimationRequest {
	r.hasSpoiler = &hasSpoiler
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiPostSendAnimationRequest) DisableNotification(disableNotification bool) ApiPostSendAnimationRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiPostSendAnimationRequest) ProtectContent(protectContent bool) ApiPostSendAnimationRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiPostSendAnimationRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiPostSendAnimationRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiPostSendAnimationRequest) MessageEffectId(messageEffectId string) ApiPostSendAnimationRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiPostSendAnimationRequest) ReplyParameters(replyParameters ReplyParameters) ApiPostSendAnimationRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiPostSendAnimationRequest) ReplyMarkup(replyMarkup SendMessageRequestReplyMarkup) ApiPostSendAnimationRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostSendAnimationRequest) Execute() (*SendAnimationResponse, *http.Response, error) {
	return r.ApiService.PostSendAnimationExecute(r)
}

/*
PostSendAnimation sendAnimation

Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without sound). On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned. Bots can currently send animation files of up to 50 MB in size, this limit may be changed in the future.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSendAnimationRequest
*/
func (a *DefaultAPIService) PostSendAnimation(ctx context.Context) ApiPostSendAnimationRequest {
	return ApiPostSendAnimationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendAnimationResponse
func (a *DefaultAPIService) PostSendAnimationExecute(r ApiPostSendAnimationRequest) (*SendAnimationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendAnimationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSendAnimation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendAnimation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.animation == nil {
		return localVarReturnValue, nil, reportError("animation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "animation", r.animation, "", "")
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "duration", r.duration, "", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "width", r.width, "", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "height", r.height, "", "")
	}
	if r.thumbnail != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "thumbnail", r.thumbnail, "", "")
	}
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption", r.caption, "", "")
	}
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.captionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption_entities", r.captionEntities, "", "csv")
	}
	if r.showCaptionAboveMedia != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "show_caption_above_media", r.showCaptionAboveMedia, "", "")
	}
	if r.hasSpoiler != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "has_spoiler", r.hasSpoiler, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSendAudioRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	audio *string
	businessConnectionId *string
	messageThreadId *int32
	caption *string
	parseMode *string
	captionEntities *[]MessageEntity
	duration *int32
	performer *string
	title *string
	thumbnail *string
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessageRequestReplyMarkup
}

func (r ApiPostSendAudioRequest) ChatId(chatId SendMessageRequestChatId) ApiPostSendAudioRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostSendAudioRequest) Audio(audio string) ApiPostSendAudioRequest {
	r.audio = &audio
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiPostSendAudioRequest) BusinessConnectionId(businessConnectionId string) ApiPostSendAudioRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiPostSendAudioRequest) MessageThreadId(messageThreadId int32) ApiPostSendAudioRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Audio caption, 0-1024 characters after entities parsing
func (r ApiPostSendAudioRequest) Caption(caption string) ApiPostSendAudioRequest {
	r.caption = &caption
	return r
}

// Mode for parsing entities in the audio caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiPostSendAudioRequest) ParseMode(parseMode string) ApiPostSendAudioRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of *parse\\\\_mode*
func (r ApiPostSendAudioRequest) CaptionEntities(captionEntities []MessageEntity) ApiPostSendAudioRequest {
	r.captionEntities = &captionEntities
	return r
}

// Duration of the audio in seconds
func (r ApiPostSendAudioRequest) Duration(duration int32) ApiPostSendAudioRequest {
	r.duration = &duration
	return r
}

// Performer
func (r ApiPostSendAudioRequest) Performer(performer string) ApiPostSendAudioRequest {
	r.performer = &performer
	return r
}

// Track name
func (r ApiPostSendAudioRequest) Title(title string) ApiPostSendAudioRequest {
	r.title = &title
	return r
}

func (r ApiPostSendAudioRequest) Thumbnail(thumbnail string) ApiPostSendAudioRequest {
	r.thumbnail = &thumbnail
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiPostSendAudioRequest) DisableNotification(disableNotification bool) ApiPostSendAudioRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiPostSendAudioRequest) ProtectContent(protectContent bool) ApiPostSendAudioRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiPostSendAudioRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiPostSendAudioRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiPostSendAudioRequest) MessageEffectId(messageEffectId string) ApiPostSendAudioRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiPostSendAudioRequest) ReplyParameters(replyParameters ReplyParameters) ApiPostSendAudioRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiPostSendAudioRequest) ReplyMarkup(replyMarkup SendMessageRequestReplyMarkup) ApiPostSendAudioRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostSendAudioRequest) Execute() (*SendAudioResponse, *http.Response, error) {
	return r.ApiService.PostSendAudioExecute(r)
}

/*
PostSendAudio sendAudio

Use this method to send audio files, if you want Telegram clients to display them in the music player. Your audio must be in the .MP3 or .M4A format. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned. Bots can currently send audio files of up to 50 MB in size, this limit may be changed in the future.

For sending voice messages, use the [sendVoice](https://core.telegram.org/bots/api/#sendvoice) method instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSendAudioRequest
*/
func (a *DefaultAPIService) PostSendAudio(ctx context.Context) ApiPostSendAudioRequest {
	return ApiPostSendAudioRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendAudioResponse
func (a *DefaultAPIService) PostSendAudioExecute(r ApiPostSendAudioRequest) (*SendAudioResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendAudioResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSendAudio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendAudio"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.audio == nil {
		return localVarReturnValue, nil, reportError("audio is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "audio", r.audio, "", "")
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption", r.caption, "", "")
	}
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.captionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption_entities", r.captionEntities, "", "csv")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "duration", r.duration, "", "")
	}
	if r.performer != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "performer", r.performer, "", "")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "", "")
	}
	if r.thumbnail != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "thumbnail", r.thumbnail, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSendChatActionRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	action *string
	businessConnectionId *string
	messageThreadId *int32
}

func (r ApiPostSendChatActionRequest) ChatId(chatId SendMessageRequestChatId) ApiPostSendChatActionRequest {
	r.chatId = &chatId
	return r
}

// Type of action to broadcast. Choose one, depending on what the user is about to receive: *typing* for [text messages](https://core.telegram.org/bots/api/#sendmessage), *upload\\\\_photo* for [photos](https://core.telegram.org/bots/api/#sendphoto), *record\\\\_video* or *upload\\\\_video* for [videos](https://core.telegram.org/bots/api/#sendvideo), *record\\\\_voice* or *upload\\\\_voice* for [voice notes](https://core.telegram.org/bots/api/#sendvoice), *upload\\\\_document* for [general files](https://core.telegram.org/bots/api/#senddocument), *choose\\\\_sticker* for [stickers](https://core.telegram.org/bots/api/#sendsticker), *find\\\\_location* for [location data](https://core.telegram.org/bots/api/#sendlocation), *record\\\\_video\\\\_note* or *upload\\\\_video\\\\_note* for [video notes](https://core.telegram.org/bots/api/#sendvideonote).
func (r ApiPostSendChatActionRequest) Action(action string) ApiPostSendChatActionRequest {
	r.action = &action
	return r
}

// Unique identifier of the business connection on behalf of which the action will be sent
func (r ApiPostSendChatActionRequest) BusinessConnectionId(businessConnectionId string) ApiPostSendChatActionRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread; for supergroups only
func (r ApiPostSendChatActionRequest) MessageThreadId(messageThreadId int32) ApiPostSendChatActionRequest {
	r.messageThreadId = &messageThreadId
	return r
}

func (r ApiPostSendChatActionRequest) Execute() (*SendChatActionResponse, *http.Response, error) {
	return r.ApiService.PostSendChatActionExecute(r)
}

/*
PostSendChatAction sendChatAction

Use this method when you need to tell the user that something is happening on the bot's side. The status is set for 5 seconds or less (when a message arrives from your bot, Telegram clients clear its typing status). Returns *True* on success.

Example: The [ImageBot](https://t.me/imagebot) needs some time to process a request and upload the image. Instead of sending a text message along the lines of “Retrieving image, please wait…”, the bot may use [sendChatAction](https://core.telegram.org/bots/api/#sendchataction) with *action* = *upload\_photo*. The user will see a “sending photo” status for the bot.

We only recommend using this method when a response from the bot will take a **noticeable** amount of time to arrive.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSendChatActionRequest
*/
func (a *DefaultAPIService) PostSendChatAction(ctx context.Context) ApiPostSendChatActionRequest {
	return ApiPostSendChatActionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendChatActionResponse
func (a *DefaultAPIService) PostSendChatActionExecute(r ApiPostSendChatActionRequest) (*SendChatActionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendChatActionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSendChatAction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendChatAction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.action == nil {
		return localVarReturnValue, nil, reportError("action is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "action", r.action, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSendChecklistRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	chatId *int32
	checklist *InputChecklist
	disableNotification *bool
	protectContent *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *InlineKeyboardMarkup
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiPostSendChecklistRequest) BusinessConnectionId(businessConnectionId string) ApiPostSendChecklistRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target chat
func (r ApiPostSendChecklistRequest) ChatId(chatId int32) ApiPostSendChecklistRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostSendChecklistRequest) Checklist(checklist InputChecklist) ApiPostSendChecklistRequest {
	r.checklist = &checklist
	return r
}

// Sends the message silently. Users will receive a notification with no sound.
func (r ApiPostSendChecklistRequest) DisableNotification(disableNotification bool) ApiPostSendChecklistRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiPostSendChecklistRequest) ProtectContent(protectContent bool) ApiPostSendChecklistRequest {
	r.protectContent = &protectContent
	return r
}

// Unique identifier of the message effect to be added to the message
func (r ApiPostSendChecklistRequest) MessageEffectId(messageEffectId string) ApiPostSendChecklistRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiPostSendChecklistRequest) ReplyParameters(replyParameters ReplyParameters) ApiPostSendChecklistRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiPostSendChecklistRequest) ReplyMarkup(replyMarkup InlineKeyboardMarkup) ApiPostSendChecklistRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostSendChecklistRequest) Execute() (*SendChecklistResponse, *http.Response, error) {
	return r.ApiService.PostSendChecklistExecute(r)
}

/*
PostSendChecklist sendChecklist

Use this method to send a checklist on behalf of a connected business account. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSendChecklistRequest
*/
func (a *DefaultAPIService) PostSendChecklist(ctx context.Context) ApiPostSendChecklistRequest {
	return ApiPostSendChecklistRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendChecklistResponse
func (a *DefaultAPIService) PostSendChecklistExecute(r ApiPostSendChecklistRequest) (*SendChecklistResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendChecklistResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSendChecklist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendChecklist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.checklist == nil {
		return localVarReturnValue, nil, reportError("checklist is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "checklist", r.checklist, "", "")
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSendContactRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	phoneNumber *string
	firstName *string
	businessConnectionId *string
	messageThreadId *int32
	lastName *string
	vcard *string
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessageRequestReplyMarkup
}

func (r ApiPostSendContactRequest) ChatId(chatId SendMessageRequestChatId) ApiPostSendContactRequest {
	r.chatId = &chatId
	return r
}

// Contact&#39;s phone number
func (r ApiPostSendContactRequest) PhoneNumber(phoneNumber string) ApiPostSendContactRequest {
	r.phoneNumber = &phoneNumber
	return r
}

// Contact&#39;s first name
func (r ApiPostSendContactRequest) FirstName(firstName string) ApiPostSendContactRequest {
	r.firstName = &firstName
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiPostSendContactRequest) BusinessConnectionId(businessConnectionId string) ApiPostSendContactRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiPostSendContactRequest) MessageThreadId(messageThreadId int32) ApiPostSendContactRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Contact&#39;s last name
func (r ApiPostSendContactRequest) LastName(lastName string) ApiPostSendContactRequest {
	r.lastName = &lastName
	return r
}

// Additional data about the contact in the form of a [vCard](https://en.wikipedia.org/wiki/VCard), 0-2048 bytes
func (r ApiPostSendContactRequest) Vcard(vcard string) ApiPostSendContactRequest {
	r.vcard = &vcard
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiPostSendContactRequest) DisableNotification(disableNotification bool) ApiPostSendContactRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiPostSendContactRequest) ProtectContent(protectContent bool) ApiPostSendContactRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiPostSendContactRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiPostSendContactRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiPostSendContactRequest) MessageEffectId(messageEffectId string) ApiPostSendContactRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiPostSendContactRequest) ReplyParameters(replyParameters ReplyParameters) ApiPostSendContactRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiPostSendContactRequest) ReplyMarkup(replyMarkup SendMessageRequestReplyMarkup) ApiPostSendContactRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostSendContactRequest) Execute() (*SendContactResponse, *http.Response, error) {
	return r.ApiService.PostSendContactExecute(r)
}

/*
PostSendContact sendContact

Use this method to send phone contacts. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSendContactRequest
*/
func (a *DefaultAPIService) PostSendContact(ctx context.Context) ApiPostSendContactRequest {
	return ApiPostSendContactRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendContactResponse
func (a *DefaultAPIService) PostSendContactExecute(r ApiPostSendContactRequest) (*SendContactResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendContactResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSendContact")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendContact"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.phoneNumber == nil {
		return localVarReturnValue, nil, reportError("phoneNumber is required and must be specified")
	}
	if r.firstName == nil {
		return localVarReturnValue, nil, reportError("firstName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "phone_number", r.phoneNumber, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "first_name", r.firstName, "", "")
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "last_name", r.lastName, "", "")
	}
	if r.vcard != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "vcard", r.vcard, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSendDiceRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	businessConnectionId *string
	messageThreadId *int32
	emoji *string
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessageRequestReplyMarkup
}

func (r ApiPostSendDiceRequest) ChatId(chatId SendMessageRequestChatId) ApiPostSendDiceRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiPostSendDiceRequest) BusinessConnectionId(businessConnectionId string) ApiPostSendDiceRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiPostSendDiceRequest) MessageThreadId(messageThreadId int32) ApiPostSendDiceRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Emoji on which the dice throw animation is based. Currently, must be one of “🎲”, “🎯”, “🏀”, “⚽”, “🎳”, or “🎰”. Dice can have values 1-6 for “🎲”, “🎯” and “🎳”, values 1-5 for “🏀” and “⚽”, and values 1-64 for “🎰”. Defaults to “🎲”
func (r ApiPostSendDiceRequest) Emoji(emoji string) ApiPostSendDiceRequest {
	r.emoji = &emoji
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiPostSendDiceRequest) DisableNotification(disableNotification bool) ApiPostSendDiceRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding
func (r ApiPostSendDiceRequest) ProtectContent(protectContent bool) ApiPostSendDiceRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiPostSendDiceRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiPostSendDiceRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiPostSendDiceRequest) MessageEffectId(messageEffectId string) ApiPostSendDiceRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiPostSendDiceRequest) ReplyParameters(replyParameters ReplyParameters) ApiPostSendDiceRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiPostSendDiceRequest) ReplyMarkup(replyMarkup SendMessageRequestReplyMarkup) ApiPostSendDiceRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostSendDiceRequest) Execute() (*SendDiceResponse, *http.Response, error) {
	return r.ApiService.PostSendDiceExecute(r)
}

/*
PostSendDice sendDice

Use this method to send an animated emoji that will display a random value. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSendDiceRequest
*/
func (a *DefaultAPIService) PostSendDice(ctx context.Context) ApiPostSendDiceRequest {
	return ApiPostSendDiceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendDiceResponse
func (a *DefaultAPIService) PostSendDiceExecute(r ApiPostSendDiceRequest) (*SendDiceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendDiceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSendDice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendDice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	if r.emoji != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "emoji", r.emoji, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSendDocumentRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	document *string
	businessConnectionId *string
	messageThreadId *int32
	thumbnail *string
	caption *string
	parseMode *string
	captionEntities *[]MessageEntity
	disableContentTypeDetection *bool
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessageRequestReplyMarkup
}

func (r ApiPostSendDocumentRequest) ChatId(chatId SendMessageRequestChatId) ApiPostSendDocumentRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostSendDocumentRequest) Document(document string) ApiPostSendDocumentRequest {
	r.document = &document
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiPostSendDocumentRequest) BusinessConnectionId(businessConnectionId string) ApiPostSendDocumentRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiPostSendDocumentRequest) MessageThreadId(messageThreadId int32) ApiPostSendDocumentRequest {
	r.messageThreadId = &messageThreadId
	return r
}

func (r ApiPostSendDocumentRequest) Thumbnail(thumbnail string) ApiPostSendDocumentRequest {
	r.thumbnail = &thumbnail
	return r
}

// Document caption (may also be used when resending documents by *file\\\\_id*), 0-1024 characters after entities parsing
func (r ApiPostSendDocumentRequest) Caption(caption string) ApiPostSendDocumentRequest {
	r.caption = &caption
	return r
}

// Mode for parsing entities in the document caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiPostSendDocumentRequest) ParseMode(parseMode string) ApiPostSendDocumentRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of *parse\\\\_mode*
func (r ApiPostSendDocumentRequest) CaptionEntities(captionEntities []MessageEntity) ApiPostSendDocumentRequest {
	r.captionEntities = &captionEntities
	return r
}

// Disables automatic server-side content type detection for files uploaded using multipart/form-data
func (r ApiPostSendDocumentRequest) DisableContentTypeDetection(disableContentTypeDetection bool) ApiPostSendDocumentRequest {
	r.disableContentTypeDetection = &disableContentTypeDetection
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiPostSendDocumentRequest) DisableNotification(disableNotification bool) ApiPostSendDocumentRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiPostSendDocumentRequest) ProtectContent(protectContent bool) ApiPostSendDocumentRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiPostSendDocumentRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiPostSendDocumentRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiPostSendDocumentRequest) MessageEffectId(messageEffectId string) ApiPostSendDocumentRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiPostSendDocumentRequest) ReplyParameters(replyParameters ReplyParameters) ApiPostSendDocumentRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiPostSendDocumentRequest) ReplyMarkup(replyMarkup SendMessageRequestReplyMarkup) ApiPostSendDocumentRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostSendDocumentRequest) Execute() (*SendDocumentResponse, *http.Response, error) {
	return r.ApiService.PostSendDocumentExecute(r)
}

/*
PostSendDocument sendDocument

Use this method to send general files. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned. Bots can currently send files of any type of up to 50 MB in size, this limit may be changed in the future.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSendDocumentRequest
*/
func (a *DefaultAPIService) PostSendDocument(ctx context.Context) ApiPostSendDocumentRequest {
	return ApiPostSendDocumentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendDocumentResponse
func (a *DefaultAPIService) PostSendDocumentExecute(r ApiPostSendDocumentRequest) (*SendDocumentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendDocumentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSendDocument")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendDocument"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.document == nil {
		return localVarReturnValue, nil, reportError("document is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "document", r.document, "", "")
	if r.thumbnail != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "thumbnail", r.thumbnail, "", "")
	}
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption", r.caption, "", "")
	}
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.captionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption_entities", r.captionEntities, "", "csv")
	}
	if r.disableContentTypeDetection != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_content_type_detection", r.disableContentTypeDetection, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSendGameRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *int32
	gameShortName *string
	businessConnectionId *string
	messageThreadId *int32
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *InlineKeyboardMarkup
}

// Unique identifier for the target chat
func (r ApiPostSendGameRequest) ChatId(chatId int32) ApiPostSendGameRequest {
	r.chatId = &chatId
	return r
}

// Short name of the game, serves as the unique identifier for the game. Set up your games via [@BotFather](https://t.me/botfather).
func (r ApiPostSendGameRequest) GameShortName(gameShortName string) ApiPostSendGameRequest {
	r.gameShortName = &gameShortName
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiPostSendGameRequest) BusinessConnectionId(businessConnectionId string) ApiPostSendGameRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiPostSendGameRequest) MessageThreadId(messageThreadId int32) ApiPostSendGameRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiPostSendGameRequest) DisableNotification(disableNotification bool) ApiPostSendGameRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiPostSendGameRequest) ProtectContent(protectContent bool) ApiPostSendGameRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiPostSendGameRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiPostSendGameRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiPostSendGameRequest) MessageEffectId(messageEffectId string) ApiPostSendGameRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiPostSendGameRequest) ReplyParameters(replyParameters ReplyParameters) ApiPostSendGameRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiPostSendGameRequest) ReplyMarkup(replyMarkup InlineKeyboardMarkup) ApiPostSendGameRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostSendGameRequest) Execute() (*SendGameResponse, *http.Response, error) {
	return r.ApiService.PostSendGameExecute(r)
}

/*
PostSendGame sendGame

Use this method to send a game. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSendGameRequest
*/
func (a *DefaultAPIService) PostSendGame(ctx context.Context) ApiPostSendGameRequest {
	return ApiPostSendGameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendGameResponse
func (a *DefaultAPIService) PostSendGameExecute(r ApiPostSendGameRequest) (*SendGameResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendGameResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSendGame")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendGame"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.gameShortName == nil {
		return localVarReturnValue, nil, reportError("gameShortName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "game_short_name", r.gameShortName, "", "")
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSendGiftRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	giftId *string
	userId *int32
	chatId *SendGiftRequestChatId
	payForUpgrade *bool
	text *string
	textParseMode *string
	textEntities *[]MessageEntity
}

// Identifier of the gift
func (r ApiPostSendGiftRequest) GiftId(giftId string) ApiPostSendGiftRequest {
	r.giftId = &giftId
	return r
}

// Required if *chat\\\\_id* is not specified. Unique identifier of the target user who will receive the gift.
func (r ApiPostSendGiftRequest) UserId(userId int32) ApiPostSendGiftRequest {
	r.userId = &userId
	return r
}

func (r ApiPostSendGiftRequest) ChatId(chatId SendGiftRequestChatId) ApiPostSendGiftRequest {
	r.chatId = &chatId
	return r
}

// Pass *True* to pay for the gift upgrade from the bot&#39;s balance, thereby making the upgrade free for the receiver
func (r ApiPostSendGiftRequest) PayForUpgrade(payForUpgrade bool) ApiPostSendGiftRequest {
	r.payForUpgrade = &payForUpgrade
	return r
}

// Text that will be shown along with the gift; 0-128 characters
func (r ApiPostSendGiftRequest) Text(text string) ApiPostSendGiftRequest {
	r.text = &text
	return r
}

// Mode for parsing entities in the text. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details. Entities other than “bold”, “italic”, “underline”, “strikethrough”, “spoiler”, and “custom\\\\_emoji” are ignored.
func (r ApiPostSendGiftRequest) TextParseMode(textParseMode string) ApiPostSendGiftRequest {
	r.textParseMode = &textParseMode
	return r
}

// A JSON-serialized list of special entities that appear in the gift text. It can be specified instead of *text\\\\_parse\\\\_mode*. Entities other than “bold”, “italic”, “underline”, “strikethrough”, “spoiler”, and “custom\\\\_emoji” are ignored.
func (r ApiPostSendGiftRequest) TextEntities(textEntities []MessageEntity) ApiPostSendGiftRequest {
	r.textEntities = &textEntities
	return r
}

func (r ApiPostSendGiftRequest) Execute() (*SendGiftResponse, *http.Response, error) {
	return r.ApiService.PostSendGiftExecute(r)
}

/*
PostSendGift sendGift

Sends a gift to the given user or channel chat. The gift can't be converted to Telegram Stars by the receiver. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSendGiftRequest
*/
func (a *DefaultAPIService) PostSendGift(ctx context.Context) ApiPostSendGiftRequest {
	return ApiPostSendGiftRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendGiftResponse
func (a *DefaultAPIService) PostSendGiftExecute(r ApiPostSendGiftRequest) (*SendGiftResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendGiftResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSendGift")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendGift"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.giftId == nil {
		return localVarReturnValue, nil, reportError("giftId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	}
	if r.chatId != nil {
		paramJson, err := parameterToJson(*r.chatId)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("chat_id", paramJson)
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "gift_id", r.giftId, "", "")
	if r.payForUpgrade != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pay_for_upgrade", r.payForUpgrade, "", "")
	}
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "text", r.text, "", "")
	}
	if r.textParseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "text_parse_mode", r.textParseMode, "", "")
	}
	if r.textEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "text_entities", r.textEntities, "", "csv")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSendInvoiceRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	title *string
	description *string
	payload *string
	currency *string
	prices *[]LabeledPrice
	messageThreadId *int32
	providerToken *string
	maxTipAmount *int32
	suggestedTipAmounts *[]int32
	startParameter *string
	providerData *string
	photoUrl *string
	photoSize *int32
	photoWidth *int32
	photoHeight *int32
	needName *bool
	needPhoneNumber *bool
	needEmail *bool
	needShippingAddress *bool
	sendPhoneNumberToProvider *bool
	sendEmailToProvider *bool
	isFlexible *bool
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *InlineKeyboardMarkup
}

func (r ApiPostSendInvoiceRequest) ChatId(chatId SendMessageRequestChatId) ApiPostSendInvoiceRequest {
	r.chatId = &chatId
	return r
}

// Product name, 1-32 characters
func (r ApiPostSendInvoiceRequest) Title(title string) ApiPostSendInvoiceRequest {
	r.title = &title
	return r
}

// Product description, 1-255 characters
func (r ApiPostSendInvoiceRequest) Description(description string) ApiPostSendInvoiceRequest {
	r.description = &description
	return r
}

// Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use it for your internal processes.
func (r ApiPostSendInvoiceRequest) Payload(payload string) ApiPostSendInvoiceRequest {
	r.payload = &payload
	return r
}

// Three-letter ISO 4217 currency code, see [more on currencies](https://core.telegram.org/bots/payments#supported-currencies). Pass “XTR” for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiPostSendInvoiceRequest) Currency(currency string) ApiPostSendInvoiceRequest {
	r.currency = &currency
	return r
}

// Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.). Must contain exactly one item for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiPostSendInvoiceRequest) Prices(prices []LabeledPrice) ApiPostSendInvoiceRequest {
	r.prices = &prices
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiPostSendInvoiceRequest) MessageThreadId(messageThreadId int32) ApiPostSendInvoiceRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Payment provider token, obtained via [@BotFather](https://t.me/botfather). Pass an empty string for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiPostSendInvoiceRequest) ProviderToken(providerToken string) ApiPostSendInvoiceRequest {
	r.providerToken = &providerToken
	return r
}

// The maximum accepted amount for tips in the *smallest units* of the currency (integer, **not** float/double). For example, for a maximum tip of &#x60;US$ 1.45&#x60; pass &#x60;max_tip_amount &#x3D; 145&#x60;. See the *exp* parameter in [currencies.json](https://core.telegram.org/bots/payments/currencies.json), it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0. Not supported for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiPostSendInvoiceRequest) MaxTipAmount(maxTipAmount int32) ApiPostSendInvoiceRequest {
	r.maxTipAmount = &maxTipAmount
	return r
}

// A JSON-serialized array of suggested amounts of tips in the *smallest units* of the currency (integer, **not** float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed *max\\\\_tip\\\\_amount*.
func (r ApiPostSendInvoiceRequest) SuggestedTipAmounts(suggestedTipAmounts []int32) ApiPostSendInvoiceRequest {
	r.suggestedTipAmounts = &suggestedTipAmounts
	return r
}

// Unique deep-linking parameter. If left empty, **forwarded copies** of the sent message will have a *Pay* button, allowing multiple users to pay directly from the forwarded message, using the same invoice. If non-empty, forwarded copies of the sent message will have a *URL* button with a deep link to the bot (instead of a *Pay* button), with the value used as the start parameter
func (r ApiPostSendInvoiceRequest) StartParameter(startParameter string) ApiPostSendInvoiceRequest {
	r.startParameter = &startParameter
	return r
}

// JSON-serialized data about the invoice, which will be shared with the payment provider. A detailed description of required fields should be provided by the payment provider.
func (r ApiPostSendInvoiceRequest) ProviderData(providerData string) ApiPostSendInvoiceRequest {
	r.providerData = &providerData
	return r
}

// URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service. People like it better when they see what they are paying for.
func (r ApiPostSendInvoiceRequest) PhotoUrl(photoUrl string) ApiPostSendInvoiceRequest {
	r.photoUrl = &photoUrl
	return r
}

// Photo size in bytes
func (r ApiPostSendInvoiceRequest) PhotoSize(photoSize int32) ApiPostSendInvoiceRequest {
	r.photoSize = &photoSize
	return r
}

// Photo width
func (r ApiPostSendInvoiceRequest) PhotoWidth(photoWidth int32) ApiPostSendInvoiceRequest {
	r.photoWidth = &photoWidth
	return r
}

// Photo height
func (r ApiPostSendInvoiceRequest) PhotoHeight(photoHeight int32) ApiPostSendInvoiceRequest {
	r.photoHeight = &photoHeight
	return r
}

// Pass *True* if you require the user&#39;s full name to complete the order. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiPostSendInvoiceRequest) NeedName(needName bool) ApiPostSendInvoiceRequest {
	r.needName = &needName
	return r
}

// Pass *True* if you require the user&#39;s phone number to complete the order. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiPostSendInvoiceRequest) NeedPhoneNumber(needPhoneNumber bool) ApiPostSendInvoiceRequest {
	r.needPhoneNumber = &needPhoneNumber
	return r
}

// Pass *True* if you require the user&#39;s email address to complete the order. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiPostSendInvoiceRequest) NeedEmail(needEmail bool) ApiPostSendInvoiceRequest {
	r.needEmail = &needEmail
	return r
}

// Pass *True* if you require the user&#39;s shipping address to complete the order. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiPostSendInvoiceRequest) NeedShippingAddress(needShippingAddress bool) ApiPostSendInvoiceRequest {
	r.needShippingAddress = &needShippingAddress
	return r
}

// Pass *True* if the user&#39;s phone number should be sent to the provider. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiPostSendInvoiceRequest) SendPhoneNumberToProvider(sendPhoneNumberToProvider bool) ApiPostSendInvoiceRequest {
	r.sendPhoneNumberToProvider = &sendPhoneNumberToProvider
	return r
}

// Pass *True* if the user&#39;s email address should be sent to the provider. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiPostSendInvoiceRequest) SendEmailToProvider(sendEmailToProvider bool) ApiPostSendInvoiceRequest {
	r.sendEmailToProvider = &sendEmailToProvider
	return r
}

// Pass *True* if the final price depends on the shipping method. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiPostSendInvoiceRequest) IsFlexible(isFlexible bool) ApiPostSendInvoiceRequest {
	r.isFlexible = &isFlexible
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiPostSendInvoiceRequest) DisableNotification(disableNotification bool) ApiPostSendInvoiceRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiPostSendInvoiceRequest) ProtectContent(protectContent bool) ApiPostSendInvoiceRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiPostSendInvoiceRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiPostSendInvoiceRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiPostSendInvoiceRequest) MessageEffectId(messageEffectId string) ApiPostSendInvoiceRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiPostSendInvoiceRequest) ReplyParameters(replyParameters ReplyParameters) ApiPostSendInvoiceRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiPostSendInvoiceRequest) ReplyMarkup(replyMarkup InlineKeyboardMarkup) ApiPostSendInvoiceRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostSendInvoiceRequest) Execute() (*SendInvoiceResponse, *http.Response, error) {
	return r.ApiService.PostSendInvoiceExecute(r)
}

/*
PostSendInvoice sendInvoice

Use this method to send invoices. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSendInvoiceRequest
*/
func (a *DefaultAPIService) PostSendInvoice(ctx context.Context) ApiPostSendInvoiceRequest {
	return ApiPostSendInvoiceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendInvoiceResponse
func (a *DefaultAPIService) PostSendInvoiceExecute(r ApiPostSendInvoiceRequest) (*SendInvoiceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendInvoiceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSendInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendInvoice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if strlen(*r.title) < 1 {
		return localVarReturnValue, nil, reportError("title must have at least 1 elements")
	}
	if strlen(*r.title) > 32 {
		return localVarReturnValue, nil, reportError("title must have less than 32 elements")
	}
	if r.description == nil {
		return localVarReturnValue, nil, reportError("description is required and must be specified")
	}
	if strlen(*r.description) < 1 {
		return localVarReturnValue, nil, reportError("description must have at least 1 elements")
	}
	if strlen(*r.description) > 255 {
		return localVarReturnValue, nil, reportError("description must have less than 255 elements")
	}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}
	if r.currency == nil {
		return localVarReturnValue, nil, reportError("currency is required and must be specified")
	}
	if r.prices == nil {
		return localVarReturnValue, nil, reportError("prices is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "payload", r.payload, "", "")
	if r.providerToken != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "provider_token", r.providerToken, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "currency", r.currency, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "prices", r.prices, "", "csv")
	if r.maxTipAmount != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "max_tip_amount", r.maxTipAmount, "", "")
	}
	if r.suggestedTipAmounts != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "suggested_tip_amounts", r.suggestedTipAmounts, "", "csv")
	}
	if r.startParameter != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "start_parameter", r.startParameter, "", "")
	}
	if r.providerData != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "provider_data", r.providerData, "", "")
	}
	if r.photoUrl != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "photo_url", r.photoUrl, "", "")
	}
	if r.photoSize != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "photo_size", r.photoSize, "", "")
	}
	if r.photoWidth != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "photo_width", r.photoWidth, "", "")
	}
	if r.photoHeight != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "photo_height", r.photoHeight, "", "")
	}
	if r.needName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "need_name", r.needName, "", "")
	}
	if r.needPhoneNumber != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "need_phone_number", r.needPhoneNumber, "", "")
	}
	if r.needEmail != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "need_email", r.needEmail, "", "")
	}
	if r.needShippingAddress != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "need_shipping_address", r.needShippingAddress, "", "")
	}
	if r.sendPhoneNumberToProvider != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "send_phone_number_to_provider", r.sendPhoneNumberToProvider, "", "")
	}
	if r.sendEmailToProvider != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "send_email_to_provider", r.sendEmailToProvider, "", "")
	}
	if r.isFlexible != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_flexible", r.isFlexible, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSendLocationRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	latitude *float32
	longitude *float32
	businessConnectionId *string
	messageThreadId *int32
	horizontalAccuracy *float32
	livePeriod *int32
	heading *int32
	proximityAlertRadius *int32
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessageRequestReplyMarkup
}

func (r ApiPostSendLocationRequest) ChatId(chatId SendMessageRequestChatId) ApiPostSendLocationRequest {
	r.chatId = &chatId
	return r
}

// Latitude of the location
func (r ApiPostSendLocationRequest) Latitude(latitude float32) ApiPostSendLocationRequest {
	r.latitude = &latitude
	return r
}

// Longitude of the location
func (r ApiPostSendLocationRequest) Longitude(longitude float32) ApiPostSendLocationRequest {
	r.longitude = &longitude
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiPostSendLocationRequest) BusinessConnectionId(businessConnectionId string) ApiPostSendLocationRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiPostSendLocationRequest) MessageThreadId(messageThreadId int32) ApiPostSendLocationRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// The radius of uncertainty for the location, measured in meters; 0-1500
func (r ApiPostSendLocationRequest) HorizontalAccuracy(horizontalAccuracy float32) ApiPostSendLocationRequest {
	r.horizontalAccuracy = &horizontalAccuracy
	return r
}

// Period in seconds during which the location will be updated (see [Live Locations](https://telegram.org/blog/live-locations), should be between 60 and 86400, or 0x7FFFFFFF for live locations that can be edited indefinitely.
func (r ApiPostSendLocationRequest) LivePeriod(livePeriod int32) ApiPostSendLocationRequest {
	r.livePeriod = &livePeriod
	return r
}

// For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified.
func (r ApiPostSendLocationRequest) Heading(heading int32) ApiPostSendLocationRequest {
	r.heading = &heading
	return r
}

// For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified.
func (r ApiPostSendLocationRequest) ProximityAlertRadius(proximityAlertRadius int32) ApiPostSendLocationRequest {
	r.proximityAlertRadius = &proximityAlertRadius
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiPostSendLocationRequest) DisableNotification(disableNotification bool) ApiPostSendLocationRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiPostSendLocationRequest) ProtectContent(protectContent bool) ApiPostSendLocationRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiPostSendLocationRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiPostSendLocationRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiPostSendLocationRequest) MessageEffectId(messageEffectId string) ApiPostSendLocationRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiPostSendLocationRequest) ReplyParameters(replyParameters ReplyParameters) ApiPostSendLocationRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiPostSendLocationRequest) ReplyMarkup(replyMarkup SendMessageRequestReplyMarkup) ApiPostSendLocationRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostSendLocationRequest) Execute() (*SendLocationResponse, *http.Response, error) {
	return r.ApiService.PostSendLocationExecute(r)
}

/*
PostSendLocation sendLocation

Use this method to send point on the map. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSendLocationRequest
*/
func (a *DefaultAPIService) PostSendLocation(ctx context.Context) ApiPostSendLocationRequest {
	return ApiPostSendLocationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendLocationResponse
func (a *DefaultAPIService) PostSendLocationExecute(r ApiPostSendLocationRequest) (*SendLocationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendLocationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSendLocation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendLocation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.latitude == nil {
		return localVarReturnValue, nil, reportError("latitude is required and must be specified")
	}
	if r.longitude == nil {
		return localVarReturnValue, nil, reportError("longitude is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "latitude", r.latitude, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "longitude", r.longitude, "", "")
	if r.horizontalAccuracy != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "horizontal_accuracy", r.horizontalAccuracy, "", "")
	}
	if r.livePeriod != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "live_period", r.livePeriod, "", "")
	}
	if r.heading != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "heading", r.heading, "", "")
	}
	if r.proximityAlertRadius != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "proximity_alert_radius", r.proximityAlertRadius, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSendMediaGroupRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	media *[]SendMediaGroupRequestMediaInner
	businessConnectionId *string
	messageThreadId *int32
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
}

func (r ApiPostSendMediaGroupRequest) ChatId(chatId SendMessageRequestChatId) ApiPostSendMediaGroupRequest {
	r.chatId = &chatId
	return r
}

// A JSON-serialized array describing messages to be sent, must include 2-10 items
func (r ApiPostSendMediaGroupRequest) Media(media []SendMediaGroupRequestMediaInner) ApiPostSendMediaGroupRequest {
	r.media = &media
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiPostSendMediaGroupRequest) BusinessConnectionId(businessConnectionId string) ApiPostSendMediaGroupRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiPostSendMediaGroupRequest) MessageThreadId(messageThreadId int32) ApiPostSendMediaGroupRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Sends messages [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiPostSendMediaGroupRequest) DisableNotification(disableNotification bool) ApiPostSendMediaGroupRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent messages from forwarding and saving
func (r ApiPostSendMediaGroupRequest) ProtectContent(protectContent bool) ApiPostSendMediaGroupRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiPostSendMediaGroupRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiPostSendMediaGroupRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiPostSendMediaGroupRequest) MessageEffectId(messageEffectId string) ApiPostSendMediaGroupRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiPostSendMediaGroupRequest) ReplyParameters(replyParameters ReplyParameters) ApiPostSendMediaGroupRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiPostSendMediaGroupRequest) Execute() (*SendMediaGroupResponse, *http.Response, error) {
	return r.ApiService.PostSendMediaGroupExecute(r)
}

/*
PostSendMediaGroup sendMediaGroup

Use this method to send a group of photos, videos, documents or audios as an album. Documents and audio files can be only grouped in an album with messages of the same type. On success, an array of [Message](https://core.telegram.org/bots/api/#message) objects that were sent is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSendMediaGroupRequest
*/
func (a *DefaultAPIService) PostSendMediaGroup(ctx context.Context) ApiPostSendMediaGroupRequest {
	return ApiPostSendMediaGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendMediaGroupResponse
func (a *DefaultAPIService) PostSendMediaGroupExecute(r ApiPostSendMediaGroupRequest) (*SendMediaGroupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendMediaGroupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSendMediaGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendMediaGroup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.media == nil {
		return localVarReturnValue, nil, reportError("media is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "media", r.media, "", "csv")
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSendMessageRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	text *string
	businessConnectionId *string
	messageThreadId *int32
	parseMode *string
	entities *[]MessageEntity
	linkPreviewOptions *LinkPreviewOptions
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessageRequestReplyMarkup
}

func (r ApiPostSendMessageRequest) ChatId(chatId SendMessageRequestChatId) ApiPostSendMessageRequest {
	r.chatId = &chatId
	return r
}

// Text of the message to be sent, 1-4096 characters after entities parsing
func (r ApiPostSendMessageRequest) Text(text string) ApiPostSendMessageRequest {
	r.text = &text
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiPostSendMessageRequest) BusinessConnectionId(businessConnectionId string) ApiPostSendMessageRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiPostSendMessageRequest) MessageThreadId(messageThreadId int32) ApiPostSendMessageRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Mode for parsing entities in the message text. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiPostSendMessageRequest) ParseMode(parseMode string) ApiPostSendMessageRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in message text, which can be specified instead of *parse\\\\_mode*
func (r ApiPostSendMessageRequest) Entities(entities []MessageEntity) ApiPostSendMessageRequest {
	r.entities = &entities
	return r
}

func (r ApiPostSendMessageRequest) LinkPreviewOptions(linkPreviewOptions LinkPreviewOptions) ApiPostSendMessageRequest {
	r.linkPreviewOptions = &linkPreviewOptions
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiPostSendMessageRequest) DisableNotification(disableNotification bool) ApiPostSendMessageRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiPostSendMessageRequest) ProtectContent(protectContent bool) ApiPostSendMessageRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiPostSendMessageRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiPostSendMessageRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiPostSendMessageRequest) MessageEffectId(messageEffectId string) ApiPostSendMessageRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiPostSendMessageRequest) ReplyParameters(replyParameters ReplyParameters) ApiPostSendMessageRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiPostSendMessageRequest) ReplyMarkup(replyMarkup SendMessageRequestReplyMarkup) ApiPostSendMessageRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostSendMessageRequest) Execute() (*SendMessageResponse, *http.Response, error) {
	return r.ApiService.PostSendMessageExecute(r)
}

/*
PostSendMessage sendMessage

Use this method to send text messages. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSendMessageRequest
*/
func (a *DefaultAPIService) PostSendMessage(ctx context.Context) ApiPostSendMessageRequest {
	return ApiPostSendMessageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendMessageResponse
func (a *DefaultAPIService) PostSendMessageExecute(r ApiPostSendMessageRequest) (*SendMessageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendMessageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSendMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}
	if strlen(*r.text) < 1 {
		return localVarReturnValue, nil, reportError("text must have at least 1 elements")
	}
	if strlen(*r.text) > 4096 {
		return localVarReturnValue, nil, reportError("text must have less than 4096 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "text", r.text, "", "")
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.entities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "entities", r.entities, "", "csv")
	}
	if r.linkPreviewOptions != nil {
		paramJson, err := parameterToJson(*r.linkPreviewOptions)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("link_preview_options", paramJson)
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSendPaidMediaRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendPaidMediaRequestChatId
	starCount *int32
	media *[]InputPaidMedia
	businessConnectionId *string
	payload *string
	caption *string
	parseMode *string
	captionEntities *[]MessageEntity
	showCaptionAboveMedia *bool
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	replyParameters *ReplyParameters
	replyMarkup *SendMessageRequestReplyMarkup
}

func (r ApiPostSendPaidMediaRequest) ChatId(chatId SendPaidMediaRequestChatId) ApiPostSendPaidMediaRequest {
	r.chatId = &chatId
	return r
}

// The number of Telegram Stars that must be paid to buy access to the media; 1-10000
func (r ApiPostSendPaidMediaRequest) StarCount(starCount int32) ApiPostSendPaidMediaRequest {
	r.starCount = &starCount
	return r
}

// A JSON-serialized array describing the media to be sent; up to 10 items
func (r ApiPostSendPaidMediaRequest) Media(media []InputPaidMedia) ApiPostSendPaidMediaRequest {
	r.media = &media
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiPostSendPaidMediaRequest) BusinessConnectionId(businessConnectionId string) ApiPostSendPaidMediaRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Bot-defined paid media payload, 0-128 bytes. This will not be displayed to the user, use it for your internal processes.
func (r ApiPostSendPaidMediaRequest) Payload(payload string) ApiPostSendPaidMediaRequest {
	r.payload = &payload
	return r
}

// Media caption, 0-1024 characters after entities parsing
func (r ApiPostSendPaidMediaRequest) Caption(caption string) ApiPostSendPaidMediaRequest {
	r.caption = &caption
	return r
}

// Mode for parsing entities in the media caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiPostSendPaidMediaRequest) ParseMode(parseMode string) ApiPostSendPaidMediaRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of *parse\\\\_mode*
func (r ApiPostSendPaidMediaRequest) CaptionEntities(captionEntities []MessageEntity) ApiPostSendPaidMediaRequest {
	r.captionEntities = &captionEntities
	return r
}

// Pass *True*, if the caption must be shown above the message media
func (r ApiPostSendPaidMediaRequest) ShowCaptionAboveMedia(showCaptionAboveMedia bool) ApiPostSendPaidMediaRequest {
	r.showCaptionAboveMedia = &showCaptionAboveMedia
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiPostSendPaidMediaRequest) DisableNotification(disableNotification bool) ApiPostSendPaidMediaRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiPostSendPaidMediaRequest) ProtectContent(protectContent bool) ApiPostSendPaidMediaRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiPostSendPaidMediaRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiPostSendPaidMediaRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

func (r ApiPostSendPaidMediaRequest) ReplyParameters(replyParameters ReplyParameters) ApiPostSendPaidMediaRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiPostSendPaidMediaRequest) ReplyMarkup(replyMarkup SendMessageRequestReplyMarkup) ApiPostSendPaidMediaRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostSendPaidMediaRequest) Execute() (*SendPaidMediaResponse, *http.Response, error) {
	return r.ApiService.PostSendPaidMediaExecute(r)
}

/*
PostSendPaidMedia sendPaidMedia

Use this method to send paid media. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSendPaidMediaRequest
*/
func (a *DefaultAPIService) PostSendPaidMedia(ctx context.Context) ApiPostSendPaidMediaRequest {
	return ApiPostSendPaidMediaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendPaidMediaResponse
func (a *DefaultAPIService) PostSendPaidMediaExecute(r ApiPostSendPaidMediaRequest) (*SendPaidMediaResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendPaidMediaResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSendPaidMedia")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendPaidMedia"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.starCount == nil {
		return localVarReturnValue, nil, reportError("starCount is required and must be specified")
	}
	if r.media == nil {
		return localVarReturnValue, nil, reportError("media is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "star_count", r.starCount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "media", r.media, "", "csv")
	if r.payload != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "payload", r.payload, "", "")
	}
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption", r.caption, "", "")
	}
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.captionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption_entities", r.captionEntities, "", "csv")
	}
	if r.showCaptionAboveMedia != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "show_caption_above_media", r.showCaptionAboveMedia, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSendPhotoRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	photo *string
	businessConnectionId *string
	messageThreadId *int32
	caption *string
	parseMode *string
	captionEntities *[]MessageEntity
	showCaptionAboveMedia *bool
	hasSpoiler *bool
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessageRequestReplyMarkup
}

func (r ApiPostSendPhotoRequest) ChatId(chatId SendMessageRequestChatId) ApiPostSendPhotoRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostSendPhotoRequest) Photo(photo string) ApiPostSendPhotoRequest {
	r.photo = &photo
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiPostSendPhotoRequest) BusinessConnectionId(businessConnectionId string) ApiPostSendPhotoRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiPostSendPhotoRequest) MessageThreadId(messageThreadId int32) ApiPostSendPhotoRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Photo caption (may also be used when resending photos by *file\\\\_id*), 0-1024 characters after entities parsing
func (r ApiPostSendPhotoRequest) Caption(caption string) ApiPostSendPhotoRequest {
	r.caption = &caption
	return r
}

// Mode for parsing entities in the photo caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiPostSendPhotoRequest) ParseMode(parseMode string) ApiPostSendPhotoRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of *parse\\\\_mode*
func (r ApiPostSendPhotoRequest) CaptionEntities(captionEntities []MessageEntity) ApiPostSendPhotoRequest {
	r.captionEntities = &captionEntities
	return r
}

// Pass *True*, if the caption must be shown above the message media
func (r ApiPostSendPhotoRequest) ShowCaptionAboveMedia(showCaptionAboveMedia bool) ApiPostSendPhotoRequest {
	r.showCaptionAboveMedia = &showCaptionAboveMedia
	return r
}

// Pass *True* if the photo needs to be covered with a spoiler animation
func (r ApiPostSendPhotoRequest) HasSpoiler(hasSpoiler bool) ApiPostSendPhotoRequest {
	r.hasSpoiler = &hasSpoiler
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiPostSendPhotoRequest) DisableNotification(disableNotification bool) ApiPostSendPhotoRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiPostSendPhotoRequest) ProtectContent(protectContent bool) ApiPostSendPhotoRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiPostSendPhotoRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiPostSendPhotoRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiPostSendPhotoRequest) MessageEffectId(messageEffectId string) ApiPostSendPhotoRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiPostSendPhotoRequest) ReplyParameters(replyParameters ReplyParameters) ApiPostSendPhotoRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiPostSendPhotoRequest) ReplyMarkup(replyMarkup SendMessageRequestReplyMarkup) ApiPostSendPhotoRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostSendPhotoRequest) Execute() (*SendPhotoResponse, *http.Response, error) {
	return r.ApiService.PostSendPhotoExecute(r)
}

/*
PostSendPhoto sendPhoto

Use this method to send photos. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSendPhotoRequest
*/
func (a *DefaultAPIService) PostSendPhoto(ctx context.Context) ApiPostSendPhotoRequest {
	return ApiPostSendPhotoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendPhotoResponse
func (a *DefaultAPIService) PostSendPhotoExecute(r ApiPostSendPhotoRequest) (*SendPhotoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendPhotoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSendPhoto")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendPhoto"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.photo == nil {
		return localVarReturnValue, nil, reportError("photo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "photo", r.photo, "", "")
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption", r.caption, "", "")
	}
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.captionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption_entities", r.captionEntities, "", "csv")
	}
	if r.showCaptionAboveMedia != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "show_caption_above_media", r.showCaptionAboveMedia, "", "")
	}
	if r.hasSpoiler != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "has_spoiler", r.hasSpoiler, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSendPollRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	question *string
	options *[]InputPollOption
	businessConnectionId *string
	messageThreadId *int32
	questionParseMode *string
	questionEntities *[]MessageEntity
	isAnonymous *bool
	type_ *string
	allowsMultipleAnswers *bool
	correctOptionId *int32
	explanation *string
	explanationParseMode *string
	explanationEntities *[]MessageEntity
	openPeriod *int32
	closeDate *int32
	isClosed *bool
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessageRequestReplyMarkup
}

func (r ApiPostSendPollRequest) ChatId(chatId SendMessageRequestChatId) ApiPostSendPollRequest {
	r.chatId = &chatId
	return r
}

// Poll question, 1-300 characters
func (r ApiPostSendPollRequest) Question(question string) ApiPostSendPollRequest {
	r.question = &question
	return r
}

// A JSON-serialized list of 2-12 answer options
func (r ApiPostSendPollRequest) Options(options []InputPollOption) ApiPostSendPollRequest {
	r.options = &options
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiPostSendPollRequest) BusinessConnectionId(businessConnectionId string) ApiPostSendPollRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiPostSendPollRequest) MessageThreadId(messageThreadId int32) ApiPostSendPollRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Mode for parsing entities in the question. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details. Currently, only custom emoji entities are allowed
func (r ApiPostSendPollRequest) QuestionParseMode(questionParseMode string) ApiPostSendPollRequest {
	r.questionParseMode = &questionParseMode
	return r
}

// A JSON-serialized list of special entities that appear in the poll question. It can be specified instead of *question\\\\_parse\\\\_mode*
func (r ApiPostSendPollRequest) QuestionEntities(questionEntities []MessageEntity) ApiPostSendPollRequest {
	r.questionEntities = &questionEntities
	return r
}

// *True*, if the poll needs to be anonymous, defaults to *True*
func (r ApiPostSendPollRequest) IsAnonymous(isAnonymous bool) ApiPostSendPollRequest {
	r.isAnonymous = &isAnonymous
	return r
}

// Poll type, “quiz” or “regular”, defaults to “regular”
func (r ApiPostSendPollRequest) Type_(type_ string) ApiPostSendPollRequest {
	r.type_ = &type_
	return r
}

// *True*, if the poll allows multiple answers, ignored for polls in quiz mode, defaults to *False*
func (r ApiPostSendPollRequest) AllowsMultipleAnswers(allowsMultipleAnswers bool) ApiPostSendPollRequest {
	r.allowsMultipleAnswers = &allowsMultipleAnswers
	return r
}

// 0-based identifier of the correct answer option, required for polls in quiz mode
func (r ApiPostSendPollRequest) CorrectOptionId(correctOptionId int32) ApiPostSendPollRequest {
	r.correctOptionId = &correctOptionId
	return r
}

// Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a quiz-style poll, 0-200 characters with at most 2 line feeds after entities parsing
func (r ApiPostSendPollRequest) Explanation(explanation string) ApiPostSendPollRequest {
	r.explanation = &explanation
	return r
}

// Mode for parsing entities in the explanation. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiPostSendPollRequest) ExplanationParseMode(explanationParseMode string) ApiPostSendPollRequest {
	r.explanationParseMode = &explanationParseMode
	return r
}

// A JSON-serialized list of special entities that appear in the poll explanation. It can be specified instead of *explanation\\\\_parse\\\\_mode*
func (r ApiPostSendPollRequest) ExplanationEntities(explanationEntities []MessageEntity) ApiPostSendPollRequest {
	r.explanationEntities = &explanationEntities
	return r
}

// Amount of time in seconds the poll will be active after creation, 5-600. Can&#39;t be used together with *close\\\\_date*.
func (r ApiPostSendPollRequest) OpenPeriod(openPeriod int32) ApiPostSendPollRequest {
	r.openPeriod = &openPeriod
	return r
}

// Point in time (Unix timestamp) when the poll will be automatically closed. Must be at least 5 and no more than 600 seconds in the future. Can&#39;t be used together with *open\\\\_period*.
func (r ApiPostSendPollRequest) CloseDate(closeDate int32) ApiPostSendPollRequest {
	r.closeDate = &closeDate
	return r
}

// Pass *True* if the poll needs to be immediately closed. This can be useful for poll preview.
func (r ApiPostSendPollRequest) IsClosed(isClosed bool) ApiPostSendPollRequest {
	r.isClosed = &isClosed
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiPostSendPollRequest) DisableNotification(disableNotification bool) ApiPostSendPollRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiPostSendPollRequest) ProtectContent(protectContent bool) ApiPostSendPollRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiPostSendPollRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiPostSendPollRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiPostSendPollRequest) MessageEffectId(messageEffectId string) ApiPostSendPollRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiPostSendPollRequest) ReplyParameters(replyParameters ReplyParameters) ApiPostSendPollRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiPostSendPollRequest) ReplyMarkup(replyMarkup SendMessageRequestReplyMarkup) ApiPostSendPollRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostSendPollRequest) Execute() (*SendPollResponse, *http.Response, error) {
	return r.ApiService.PostSendPollExecute(r)
}

/*
PostSendPoll sendPoll

Use this method to send a native poll. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSendPollRequest
*/
func (a *DefaultAPIService) PostSendPoll(ctx context.Context) ApiPostSendPollRequest {
	return ApiPostSendPollRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendPollResponse
func (a *DefaultAPIService) PostSendPollExecute(r ApiPostSendPollRequest) (*SendPollResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendPollResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSendPoll")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendPoll"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.question == nil {
		return localVarReturnValue, nil, reportError("question is required and must be specified")
	}
	if strlen(*r.question) < 1 {
		return localVarReturnValue, nil, reportError("question must have at least 1 elements")
	}
	if strlen(*r.question) > 300 {
		return localVarReturnValue, nil, reportError("question must have less than 300 elements")
	}
	if r.options == nil {
		return localVarReturnValue, nil, reportError("options is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "question", r.question, "", "")
	if r.questionParseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "question_parse_mode", r.questionParseMode, "", "")
	}
	if r.questionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "question_entities", r.questionEntities, "", "csv")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "options", r.options, "", "csv")
	if r.isAnonymous != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_anonymous", r.isAnonymous, "", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	}
	if r.allowsMultipleAnswers != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allows_multiple_answers", r.allowsMultipleAnswers, "", "")
	}
	if r.correctOptionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "correct_option_id", r.correctOptionId, "", "")
	}
	if r.explanation != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "explanation", r.explanation, "", "")
	}
	if r.explanationParseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "explanation_parse_mode", r.explanationParseMode, "", "")
	}
	if r.explanationEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "explanation_entities", r.explanationEntities, "", "csv")
	}
	if r.openPeriod != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "open_period", r.openPeriod, "", "")
	}
	if r.closeDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "close_date", r.closeDate, "", "")
	}
	if r.isClosed != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_closed", r.isClosed, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSendStickerRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	sticker *string
	businessConnectionId *string
	messageThreadId *int32
	emoji *string
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessageRequestReplyMarkup
}

func (r ApiPostSendStickerRequest) ChatId(chatId SendMessageRequestChatId) ApiPostSendStickerRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostSendStickerRequest) Sticker(sticker string) ApiPostSendStickerRequest {
	r.sticker = &sticker
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiPostSendStickerRequest) BusinessConnectionId(businessConnectionId string) ApiPostSendStickerRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiPostSendStickerRequest) MessageThreadId(messageThreadId int32) ApiPostSendStickerRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Emoji associated with the sticker; only for just uploaded stickers
func (r ApiPostSendStickerRequest) Emoji(emoji string) ApiPostSendStickerRequest {
	r.emoji = &emoji
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiPostSendStickerRequest) DisableNotification(disableNotification bool) ApiPostSendStickerRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiPostSendStickerRequest) ProtectContent(protectContent bool) ApiPostSendStickerRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiPostSendStickerRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiPostSendStickerRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiPostSendStickerRequest) MessageEffectId(messageEffectId string) ApiPostSendStickerRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiPostSendStickerRequest) ReplyParameters(replyParameters ReplyParameters) ApiPostSendStickerRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiPostSendStickerRequest) ReplyMarkup(replyMarkup SendMessageRequestReplyMarkup) ApiPostSendStickerRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostSendStickerRequest) Execute() (*SendStickerResponse, *http.Response, error) {
	return r.ApiService.PostSendStickerExecute(r)
}

/*
PostSendSticker sendSticker

Use this method to send static .WEBP, [animated](https://telegram.org/blog/animated-stickers) .TGS, or [video](https://telegram.org/blog/video-stickers-better-reactions) .WEBM stickers. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSendStickerRequest
*/
func (a *DefaultAPIService) PostSendSticker(ctx context.Context) ApiPostSendStickerRequest {
	return ApiPostSendStickerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendStickerResponse
func (a *DefaultAPIService) PostSendStickerExecute(r ApiPostSendStickerRequest) (*SendStickerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendStickerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSendSticker")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendSticker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.sticker == nil {
		return localVarReturnValue, nil, reportError("sticker is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "sticker", r.sticker, "", "")
	if r.emoji != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "emoji", r.emoji, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSendVenueRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	latitude *float32
	longitude *float32
	title *string
	address *string
	businessConnectionId *string
	messageThreadId *int32
	foursquareId *string
	foursquareType *string
	googlePlaceId *string
	googlePlaceType *string
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessageRequestReplyMarkup
}

func (r ApiPostSendVenueRequest) ChatId(chatId SendMessageRequestChatId) ApiPostSendVenueRequest {
	r.chatId = &chatId
	return r
}

// Latitude of the venue
func (r ApiPostSendVenueRequest) Latitude(latitude float32) ApiPostSendVenueRequest {
	r.latitude = &latitude
	return r
}

// Longitude of the venue
func (r ApiPostSendVenueRequest) Longitude(longitude float32) ApiPostSendVenueRequest {
	r.longitude = &longitude
	return r
}

// Name of the venue
func (r ApiPostSendVenueRequest) Title(title string) ApiPostSendVenueRequest {
	r.title = &title
	return r
}

// Address of the venue
func (r ApiPostSendVenueRequest) Address(address string) ApiPostSendVenueRequest {
	r.address = &address
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiPostSendVenueRequest) BusinessConnectionId(businessConnectionId string) ApiPostSendVenueRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiPostSendVenueRequest) MessageThreadId(messageThreadId int32) ApiPostSendVenueRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Foursquare identifier of the venue
func (r ApiPostSendVenueRequest) FoursquareId(foursquareId string) ApiPostSendVenueRequest {
	r.foursquareId = &foursquareId
	return r
}

// Foursquare type of the venue, if known. (For example, “arts\\\\_entertainment/default”, “arts\\\\_entertainment/aquarium” or “food/icecream”.)
func (r ApiPostSendVenueRequest) FoursquareType(foursquareType string) ApiPostSendVenueRequest {
	r.foursquareType = &foursquareType
	return r
}

// Google Places identifier of the venue
func (r ApiPostSendVenueRequest) GooglePlaceId(googlePlaceId string) ApiPostSendVenueRequest {
	r.googlePlaceId = &googlePlaceId
	return r
}

// Google Places type of the venue. (See [supported types](https://developers.google.com/places/web-service/supported_types).)
func (r ApiPostSendVenueRequest) GooglePlaceType(googlePlaceType string) ApiPostSendVenueRequest {
	r.googlePlaceType = &googlePlaceType
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiPostSendVenueRequest) DisableNotification(disableNotification bool) ApiPostSendVenueRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiPostSendVenueRequest) ProtectContent(protectContent bool) ApiPostSendVenueRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiPostSendVenueRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiPostSendVenueRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiPostSendVenueRequest) MessageEffectId(messageEffectId string) ApiPostSendVenueRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiPostSendVenueRequest) ReplyParameters(replyParameters ReplyParameters) ApiPostSendVenueRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiPostSendVenueRequest) ReplyMarkup(replyMarkup SendMessageRequestReplyMarkup) ApiPostSendVenueRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostSendVenueRequest) Execute() (*SendVenueResponse, *http.Response, error) {
	return r.ApiService.PostSendVenueExecute(r)
}

/*
PostSendVenue sendVenue

Use this method to send information about a venue. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSendVenueRequest
*/
func (a *DefaultAPIService) PostSendVenue(ctx context.Context) ApiPostSendVenueRequest {
	return ApiPostSendVenueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendVenueResponse
func (a *DefaultAPIService) PostSendVenueExecute(r ApiPostSendVenueRequest) (*SendVenueResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendVenueResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSendVenue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendVenue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.latitude == nil {
		return localVarReturnValue, nil, reportError("latitude is required and must be specified")
	}
	if r.longitude == nil {
		return localVarReturnValue, nil, reportError("longitude is required and must be specified")
	}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if r.address == nil {
		return localVarReturnValue, nil, reportError("address is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "latitude", r.latitude, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "longitude", r.longitude, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "address", r.address, "", "")
	if r.foursquareId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "foursquare_id", r.foursquareId, "", "")
	}
	if r.foursquareType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "foursquare_type", r.foursquareType, "", "")
	}
	if r.googlePlaceId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "google_place_id", r.googlePlaceId, "", "")
	}
	if r.googlePlaceType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "google_place_type", r.googlePlaceType, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSendVideoRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	video *string
	businessConnectionId *string
	messageThreadId *int32
	duration *int32
	width *int32
	height *int32
	thumbnail *string
	cover *string
	startTimestamp *int32
	caption *string
	parseMode *string
	captionEntities *[]MessageEntity
	showCaptionAboveMedia *bool
	hasSpoiler *bool
	supportsStreaming *bool
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessageRequestReplyMarkup
}

func (r ApiPostSendVideoRequest) ChatId(chatId SendMessageRequestChatId) ApiPostSendVideoRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostSendVideoRequest) Video(video string) ApiPostSendVideoRequest {
	r.video = &video
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiPostSendVideoRequest) BusinessConnectionId(businessConnectionId string) ApiPostSendVideoRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiPostSendVideoRequest) MessageThreadId(messageThreadId int32) ApiPostSendVideoRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Duration of sent video in seconds
func (r ApiPostSendVideoRequest) Duration(duration int32) ApiPostSendVideoRequest {
	r.duration = &duration
	return r
}

// Video width
func (r ApiPostSendVideoRequest) Width(width int32) ApiPostSendVideoRequest {
	r.width = &width
	return r
}

// Video height
func (r ApiPostSendVideoRequest) Height(height int32) ApiPostSendVideoRequest {
	r.height = &height
	return r
}

func (r ApiPostSendVideoRequest) Thumbnail(thumbnail string) ApiPostSendVideoRequest {
	r.thumbnail = &thumbnail
	return r
}

func (r ApiPostSendVideoRequest) Cover(cover string) ApiPostSendVideoRequest {
	r.cover = &cover
	return r
}

// Start timestamp for the video in the message
func (r ApiPostSendVideoRequest) StartTimestamp(startTimestamp int32) ApiPostSendVideoRequest {
	r.startTimestamp = &startTimestamp
	return r
}

// Video caption (may also be used when resending videos by *file\\\\_id*), 0-1024 characters after entities parsing
func (r ApiPostSendVideoRequest) Caption(caption string) ApiPostSendVideoRequest {
	r.caption = &caption
	return r
}

// Mode for parsing entities in the video caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiPostSendVideoRequest) ParseMode(parseMode string) ApiPostSendVideoRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of *parse\\\\_mode*
func (r ApiPostSendVideoRequest) CaptionEntities(captionEntities []MessageEntity) ApiPostSendVideoRequest {
	r.captionEntities = &captionEntities
	return r
}

// Pass *True*, if the caption must be shown above the message media
func (r ApiPostSendVideoRequest) ShowCaptionAboveMedia(showCaptionAboveMedia bool) ApiPostSendVideoRequest {
	r.showCaptionAboveMedia = &showCaptionAboveMedia
	return r
}

// Pass *True* if the video needs to be covered with a spoiler animation
func (r ApiPostSendVideoRequest) HasSpoiler(hasSpoiler bool) ApiPostSendVideoRequest {
	r.hasSpoiler = &hasSpoiler
	return r
}

// Pass *True* if the uploaded video is suitable for streaming
func (r ApiPostSendVideoRequest) SupportsStreaming(supportsStreaming bool) ApiPostSendVideoRequest {
	r.supportsStreaming = &supportsStreaming
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiPostSendVideoRequest) DisableNotification(disableNotification bool) ApiPostSendVideoRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiPostSendVideoRequest) ProtectContent(protectContent bool) ApiPostSendVideoRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiPostSendVideoRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiPostSendVideoRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiPostSendVideoRequest) MessageEffectId(messageEffectId string) ApiPostSendVideoRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiPostSendVideoRequest) ReplyParameters(replyParameters ReplyParameters) ApiPostSendVideoRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiPostSendVideoRequest) ReplyMarkup(replyMarkup SendMessageRequestReplyMarkup) ApiPostSendVideoRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostSendVideoRequest) Execute() (*SendVideoResponse, *http.Response, error) {
	return r.ApiService.PostSendVideoExecute(r)
}

/*
PostSendVideo sendVideo

Use this method to send video files, Telegram clients support MPEG4 videos (other formats may be sent as [Document](https://core.telegram.org/bots/api/#document)). On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned. Bots can currently send video files of up to 50 MB in size, this limit may be changed in the future.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSendVideoRequest
*/
func (a *DefaultAPIService) PostSendVideo(ctx context.Context) ApiPostSendVideoRequest {
	return ApiPostSendVideoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendVideoResponse
func (a *DefaultAPIService) PostSendVideoExecute(r ApiPostSendVideoRequest) (*SendVideoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendVideoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSendVideo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendVideo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.video == nil {
		return localVarReturnValue, nil, reportError("video is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "video", r.video, "", "")
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "duration", r.duration, "", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "width", r.width, "", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "height", r.height, "", "")
	}
	if r.thumbnail != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "thumbnail", r.thumbnail, "", "")
	}
	if r.cover != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "cover", r.cover, "", "")
	}
	if r.startTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "start_timestamp", r.startTimestamp, "", "")
	}
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption", r.caption, "", "")
	}
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.captionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption_entities", r.captionEntities, "", "csv")
	}
	if r.showCaptionAboveMedia != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "show_caption_above_media", r.showCaptionAboveMedia, "", "")
	}
	if r.hasSpoiler != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "has_spoiler", r.hasSpoiler, "", "")
	}
	if r.supportsStreaming != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "supports_streaming", r.supportsStreaming, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSendVideoNoteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	videoNote *string
	businessConnectionId *string
	messageThreadId *int32
	duration *int32
	length *int32
	thumbnail *string
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessageRequestReplyMarkup
}

func (r ApiPostSendVideoNoteRequest) ChatId(chatId SendMessageRequestChatId) ApiPostSendVideoNoteRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostSendVideoNoteRequest) VideoNote(videoNote string) ApiPostSendVideoNoteRequest {
	r.videoNote = &videoNote
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiPostSendVideoNoteRequest) BusinessConnectionId(businessConnectionId string) ApiPostSendVideoNoteRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiPostSendVideoNoteRequest) MessageThreadId(messageThreadId int32) ApiPostSendVideoNoteRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Duration of sent video in seconds
func (r ApiPostSendVideoNoteRequest) Duration(duration int32) ApiPostSendVideoNoteRequest {
	r.duration = &duration
	return r
}

// Video width and height, i.e. diameter of the video message
func (r ApiPostSendVideoNoteRequest) Length(length int32) ApiPostSendVideoNoteRequest {
	r.length = &length
	return r
}

func (r ApiPostSendVideoNoteRequest) Thumbnail(thumbnail string) ApiPostSendVideoNoteRequest {
	r.thumbnail = &thumbnail
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiPostSendVideoNoteRequest) DisableNotification(disableNotification bool) ApiPostSendVideoNoteRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiPostSendVideoNoteRequest) ProtectContent(protectContent bool) ApiPostSendVideoNoteRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiPostSendVideoNoteRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiPostSendVideoNoteRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiPostSendVideoNoteRequest) MessageEffectId(messageEffectId string) ApiPostSendVideoNoteRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiPostSendVideoNoteRequest) ReplyParameters(replyParameters ReplyParameters) ApiPostSendVideoNoteRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiPostSendVideoNoteRequest) ReplyMarkup(replyMarkup SendMessageRequestReplyMarkup) ApiPostSendVideoNoteRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostSendVideoNoteRequest) Execute() (*SendVideoNoteResponse, *http.Response, error) {
	return r.ApiService.PostSendVideoNoteExecute(r)
}

/*
PostSendVideoNote sendVideoNote

As of [v.4.0](https://telegram.org/blog/video-messages-and-telescope), Telegram clients support rounded square MPEG4 videos of up to 1 minute long. Use this method to send video messages. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSendVideoNoteRequest
*/
func (a *DefaultAPIService) PostSendVideoNote(ctx context.Context) ApiPostSendVideoNoteRequest {
	return ApiPostSendVideoNoteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendVideoNoteResponse
func (a *DefaultAPIService) PostSendVideoNoteExecute(r ApiPostSendVideoNoteRequest) (*SendVideoNoteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendVideoNoteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSendVideoNote")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendVideoNote"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.videoNote == nil {
		return localVarReturnValue, nil, reportError("videoNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "video_note", r.videoNote, "", "")
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "duration", r.duration, "", "")
	}
	if r.length != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "length", r.length, "", "")
	}
	if r.thumbnail != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "thumbnail", r.thumbnail, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSendVoiceRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	voice *string
	businessConnectionId *string
	messageThreadId *int32
	caption *string
	parseMode *string
	captionEntities *[]MessageEntity
	duration *int32
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessageRequestReplyMarkup
}

func (r ApiPostSendVoiceRequest) ChatId(chatId SendMessageRequestChatId) ApiPostSendVoiceRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostSendVoiceRequest) Voice(voice string) ApiPostSendVoiceRequest {
	r.voice = &voice
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiPostSendVoiceRequest) BusinessConnectionId(businessConnectionId string) ApiPostSendVoiceRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiPostSendVoiceRequest) MessageThreadId(messageThreadId int32) ApiPostSendVoiceRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Voice message caption, 0-1024 characters after entities parsing
func (r ApiPostSendVoiceRequest) Caption(caption string) ApiPostSendVoiceRequest {
	r.caption = &caption
	return r
}

// Mode for parsing entities in the voice message caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiPostSendVoiceRequest) ParseMode(parseMode string) ApiPostSendVoiceRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of *parse\\\\_mode*
func (r ApiPostSendVoiceRequest) CaptionEntities(captionEntities []MessageEntity) ApiPostSendVoiceRequest {
	r.captionEntities = &captionEntities
	return r
}

// Duration of the voice message in seconds
func (r ApiPostSendVoiceRequest) Duration(duration int32) ApiPostSendVoiceRequest {
	r.duration = &duration
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiPostSendVoiceRequest) DisableNotification(disableNotification bool) ApiPostSendVoiceRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiPostSendVoiceRequest) ProtectContent(protectContent bool) ApiPostSendVoiceRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiPostSendVoiceRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiPostSendVoiceRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiPostSendVoiceRequest) MessageEffectId(messageEffectId string) ApiPostSendVoiceRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiPostSendVoiceRequest) ReplyParameters(replyParameters ReplyParameters) ApiPostSendVoiceRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiPostSendVoiceRequest) ReplyMarkup(replyMarkup SendMessageRequestReplyMarkup) ApiPostSendVoiceRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostSendVoiceRequest) Execute() (*SendVoiceResponse, *http.Response, error) {
	return r.ApiService.PostSendVoiceExecute(r)
}

/*
PostSendVoice sendVoice

Use this method to send audio files, if you want Telegram clients to display the file as a playable voice message. For this to work, your audio must be in an .OGG file encoded with OPUS, or in .MP3 format, or in .M4A format (other formats may be sent as [Audio](https://core.telegram.org/bots/api/#audio) or [Document](https://core.telegram.org/bots/api/#document)). On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned. Bots can currently send voice messages of up to 50 MB in size, this limit may be changed in the future.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSendVoiceRequest
*/
func (a *DefaultAPIService) PostSendVoice(ctx context.Context) ApiPostSendVoiceRequest {
	return ApiPostSendVoiceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendVoiceResponse
func (a *DefaultAPIService) PostSendVoiceExecute(r ApiPostSendVoiceRequest) (*SendVoiceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendVoiceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSendVoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendVoice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.voice == nil {
		return localVarReturnValue, nil, reportError("voice is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "voice", r.voice, "", "")
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption", r.caption, "", "")
	}
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.captionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption_entities", r.captionEntities, "", "csv")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "duration", r.duration, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetBusinessAccountBioRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	bio *string
}

// Unique identifier of the business connection
func (r ApiPostSetBusinessAccountBioRequest) BusinessConnectionId(businessConnectionId string) ApiPostSetBusinessAccountBioRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// The new value of the bio for the business account; 0-140 characters
func (r ApiPostSetBusinessAccountBioRequest) Bio(bio string) ApiPostSetBusinessAccountBioRequest {
	r.bio = &bio
	return r
}

func (r ApiPostSetBusinessAccountBioRequest) Execute() (*SetBusinessAccountBioResponse, *http.Response, error) {
	return r.ApiService.PostSetBusinessAccountBioExecute(r)
}

/*
PostSetBusinessAccountBio setBusinessAccountBio

Changes the bio of a managed business account. Requires the *can\_change\_bio* business bot right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetBusinessAccountBioRequest
*/
func (a *DefaultAPIService) PostSetBusinessAccountBio(ctx context.Context) ApiPostSetBusinessAccountBioRequest {
	return ApiPostSetBusinessAccountBioRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetBusinessAccountBioResponse
func (a *DefaultAPIService) PostSetBusinessAccountBioExecute(r ApiPostSetBusinessAccountBioRequest) (*SetBusinessAccountBioResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetBusinessAccountBioResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetBusinessAccountBio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setBusinessAccountBio"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	if r.bio != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "bio", r.bio, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetBusinessAccountGiftSettingsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	showGiftButton *bool
	acceptedGiftTypes *AcceptedGiftTypes
}

// Unique identifier of the business connection
func (r ApiPostSetBusinessAccountGiftSettingsRequest) BusinessConnectionId(businessConnectionId string) ApiPostSetBusinessAccountGiftSettingsRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Pass *True*, if a button for sending a gift to the user or by the business account must always be shown in the input field
func (r ApiPostSetBusinessAccountGiftSettingsRequest) ShowGiftButton(showGiftButton bool) ApiPostSetBusinessAccountGiftSettingsRequest {
	r.showGiftButton = &showGiftButton
	return r
}

func (r ApiPostSetBusinessAccountGiftSettingsRequest) AcceptedGiftTypes(acceptedGiftTypes AcceptedGiftTypes) ApiPostSetBusinessAccountGiftSettingsRequest {
	r.acceptedGiftTypes = &acceptedGiftTypes
	return r
}

func (r ApiPostSetBusinessAccountGiftSettingsRequest) Execute() (*SetBusinessAccountGiftSettingsResponse, *http.Response, error) {
	return r.ApiService.PostSetBusinessAccountGiftSettingsExecute(r)
}

/*
PostSetBusinessAccountGiftSettings setBusinessAccountGiftSettings

Changes the privacy settings pertaining to incoming gifts in a managed business account. Requires the *can\_change\_gift\_settings* business bot right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetBusinessAccountGiftSettingsRequest
*/
func (a *DefaultAPIService) PostSetBusinessAccountGiftSettings(ctx context.Context) ApiPostSetBusinessAccountGiftSettingsRequest {
	return ApiPostSetBusinessAccountGiftSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetBusinessAccountGiftSettingsResponse
func (a *DefaultAPIService) PostSetBusinessAccountGiftSettingsExecute(r ApiPostSetBusinessAccountGiftSettingsRequest) (*SetBusinessAccountGiftSettingsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetBusinessAccountGiftSettingsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetBusinessAccountGiftSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setBusinessAccountGiftSettings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.showGiftButton == nil {
		return localVarReturnValue, nil, reportError("showGiftButton is required and must be specified")
	}
	if r.acceptedGiftTypes == nil {
		return localVarReturnValue, nil, reportError("acceptedGiftTypes is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "show_gift_button", r.showGiftButton, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "accepted_gift_types", r.acceptedGiftTypes, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetBusinessAccountNameRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	firstName *string
	lastName *string
}

// Unique identifier of the business connection
func (r ApiPostSetBusinessAccountNameRequest) BusinessConnectionId(businessConnectionId string) ApiPostSetBusinessAccountNameRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// The new value of the first name for the business account; 1-64 characters
func (r ApiPostSetBusinessAccountNameRequest) FirstName(firstName string) ApiPostSetBusinessAccountNameRequest {
	r.firstName = &firstName
	return r
}

// The new value of the last name for the business account; 0-64 characters
func (r ApiPostSetBusinessAccountNameRequest) LastName(lastName string) ApiPostSetBusinessAccountNameRequest {
	r.lastName = &lastName
	return r
}

func (r ApiPostSetBusinessAccountNameRequest) Execute() (*SetBusinessAccountNameResponse, *http.Response, error) {
	return r.ApiService.PostSetBusinessAccountNameExecute(r)
}

/*
PostSetBusinessAccountName setBusinessAccountName

Changes the first and last name of a managed business account. Requires the *can\_change\_name* business bot right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetBusinessAccountNameRequest
*/
func (a *DefaultAPIService) PostSetBusinessAccountName(ctx context.Context) ApiPostSetBusinessAccountNameRequest {
	return ApiPostSetBusinessAccountNameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetBusinessAccountNameResponse
func (a *DefaultAPIService) PostSetBusinessAccountNameExecute(r ApiPostSetBusinessAccountNameRequest) (*SetBusinessAccountNameResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetBusinessAccountNameResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetBusinessAccountName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setBusinessAccountName"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.firstName == nil {
		return localVarReturnValue, nil, reportError("firstName is required and must be specified")
	}
	if strlen(*r.firstName) < 1 {
		return localVarReturnValue, nil, reportError("firstName must have at least 1 elements")
	}
	if strlen(*r.firstName) > 64 {
		return localVarReturnValue, nil, reportError("firstName must have less than 64 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "first_name", r.firstName, "", "")
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "last_name", r.lastName, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetBusinessAccountProfilePhotoRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	photo *InputProfilePhoto
	isPublic *bool
}

// Unique identifier of the business connection
func (r ApiPostSetBusinessAccountProfilePhotoRequest) BusinessConnectionId(businessConnectionId string) ApiPostSetBusinessAccountProfilePhotoRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

func (r ApiPostSetBusinessAccountProfilePhotoRequest) Photo(photo InputProfilePhoto) ApiPostSetBusinessAccountProfilePhotoRequest {
	r.photo = &photo
	return r
}

// Pass *True* to set the public photo, which will be visible even if the main photo is hidden by the business account&#39;s privacy settings. An account can have only one public photo.
func (r ApiPostSetBusinessAccountProfilePhotoRequest) IsPublic(isPublic bool) ApiPostSetBusinessAccountProfilePhotoRequest {
	r.isPublic = &isPublic
	return r
}

func (r ApiPostSetBusinessAccountProfilePhotoRequest) Execute() (*SetBusinessAccountProfilePhotoResponse, *http.Response, error) {
	return r.ApiService.PostSetBusinessAccountProfilePhotoExecute(r)
}

/*
PostSetBusinessAccountProfilePhoto setBusinessAccountProfilePhoto

Changes the profile photo of a managed business account. Requires the *can\_edit\_profile\_photo* business bot right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetBusinessAccountProfilePhotoRequest
*/
func (a *DefaultAPIService) PostSetBusinessAccountProfilePhoto(ctx context.Context) ApiPostSetBusinessAccountProfilePhotoRequest {
	return ApiPostSetBusinessAccountProfilePhotoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetBusinessAccountProfilePhotoResponse
func (a *DefaultAPIService) PostSetBusinessAccountProfilePhotoExecute(r ApiPostSetBusinessAccountProfilePhotoRequest) (*SetBusinessAccountProfilePhotoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetBusinessAccountProfilePhotoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetBusinessAccountProfilePhoto")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setBusinessAccountProfilePhoto"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.photo == nil {
		return localVarReturnValue, nil, reportError("photo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "photo", r.photo, "", "")
	if r.isPublic != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_public", r.isPublic, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetBusinessAccountUsernameRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	username *string
}

// Unique identifier of the business connection
func (r ApiPostSetBusinessAccountUsernameRequest) BusinessConnectionId(businessConnectionId string) ApiPostSetBusinessAccountUsernameRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// The new value of the username for the business account; 0-32 characters
func (r ApiPostSetBusinessAccountUsernameRequest) Username(username string) ApiPostSetBusinessAccountUsernameRequest {
	r.username = &username
	return r
}

func (r ApiPostSetBusinessAccountUsernameRequest) Execute() (*SetBusinessAccountUsernameResponse, *http.Response, error) {
	return r.ApiService.PostSetBusinessAccountUsernameExecute(r)
}

/*
PostSetBusinessAccountUsername setBusinessAccountUsername

Changes the username of a managed business account. Requires the *can\_change\_username* business bot right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetBusinessAccountUsernameRequest
*/
func (a *DefaultAPIService) PostSetBusinessAccountUsername(ctx context.Context) ApiPostSetBusinessAccountUsernameRequest {
	return ApiPostSetBusinessAccountUsernameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetBusinessAccountUsernameResponse
func (a *DefaultAPIService) PostSetBusinessAccountUsernameExecute(r ApiPostSetBusinessAccountUsernameRequest) (*SetBusinessAccountUsernameResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetBusinessAccountUsernameResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetBusinessAccountUsername")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setBusinessAccountUsername"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	if r.username != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "username", r.username, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetChatAdministratorCustomTitleRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *BotCommandScopeChatChatId
	userId *int32
	customTitle *string
}

func (r ApiPostSetChatAdministratorCustomTitleRequest) ChatId(chatId BotCommandScopeChatChatId) ApiPostSetChatAdministratorCustomTitleRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the target user
func (r ApiPostSetChatAdministratorCustomTitleRequest) UserId(userId int32) ApiPostSetChatAdministratorCustomTitleRequest {
	r.userId = &userId
	return r
}

// New custom title for the administrator; 0-16 characters, emoji are not allowed
func (r ApiPostSetChatAdministratorCustomTitleRequest) CustomTitle(customTitle string) ApiPostSetChatAdministratorCustomTitleRequest {
	r.customTitle = &customTitle
	return r
}

func (r ApiPostSetChatAdministratorCustomTitleRequest) Execute() (*SetChatAdministratorCustomTitleResponse, *http.Response, error) {
	return r.ApiService.PostSetChatAdministratorCustomTitleExecute(r)
}

/*
PostSetChatAdministratorCustomTitle setChatAdministratorCustomTitle

Use this method to set a custom title for an administrator in a supergroup promoted by the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetChatAdministratorCustomTitleRequest
*/
func (a *DefaultAPIService) PostSetChatAdministratorCustomTitle(ctx context.Context) ApiPostSetChatAdministratorCustomTitleRequest {
	return ApiPostSetChatAdministratorCustomTitleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetChatAdministratorCustomTitleResponse
func (a *DefaultAPIService) PostSetChatAdministratorCustomTitleExecute(r ApiPostSetChatAdministratorCustomTitleRequest) (*SetChatAdministratorCustomTitleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetChatAdministratorCustomTitleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetChatAdministratorCustomTitle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setChatAdministratorCustomTitle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.customTitle == nil {
		return localVarReturnValue, nil, reportError("customTitle is required and must be specified")
	}
	if strlen(*r.customTitle) < 0 {
		return localVarReturnValue, nil, reportError("customTitle must have at least 0 elements")
	}
	if strlen(*r.customTitle) > 16 {
		return localVarReturnValue, nil, reportError("customTitle must have less than 16 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "custom_title", r.customTitle, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetChatDescriptionRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	description *string
}

func (r ApiPostSetChatDescriptionRequest) ChatId(chatId SendMessageRequestChatId) ApiPostSetChatDescriptionRequest {
	r.chatId = &chatId
	return r
}

// New chat description, 0-255 characters
func (r ApiPostSetChatDescriptionRequest) Description(description string) ApiPostSetChatDescriptionRequest {
	r.description = &description
	return r
}

func (r ApiPostSetChatDescriptionRequest) Execute() (*SetChatDescriptionResponse, *http.Response, error) {
	return r.ApiService.PostSetChatDescriptionExecute(r)
}

/*
PostSetChatDescription setChatDescription

Use this method to change the description of a group, a supergroup or a channel. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetChatDescriptionRequest
*/
func (a *DefaultAPIService) PostSetChatDescription(ctx context.Context) ApiPostSetChatDescriptionRequest {
	return ApiPostSetChatDescriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetChatDescriptionResponse
func (a *DefaultAPIService) PostSetChatDescriptionExecute(r ApiPostSetChatDescriptionRequest) (*SetChatDescriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetChatDescriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetChatDescription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setChatDescription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetChatMenuButtonRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *int32
	menuButton *MenuButton
}

// Unique identifier for the target private chat. If not specified, default bot&#39;s menu button will be changed
func (r ApiPostSetChatMenuButtonRequest) ChatId(chatId int32) ApiPostSetChatMenuButtonRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostSetChatMenuButtonRequest) MenuButton(menuButton MenuButton) ApiPostSetChatMenuButtonRequest {
	r.menuButton = &menuButton
	return r
}

func (r ApiPostSetChatMenuButtonRequest) Execute() (*SetChatMenuButtonResponse, *http.Response, error) {
	return r.ApiService.PostSetChatMenuButtonExecute(r)
}

/*
PostSetChatMenuButton setChatMenuButton

Use this method to change the bot's menu button in a private chat, or the default menu button. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetChatMenuButtonRequest
*/
func (a *DefaultAPIService) PostSetChatMenuButton(ctx context.Context) ApiPostSetChatMenuButtonRequest {
	return ApiPostSetChatMenuButtonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetChatMenuButtonResponse
func (a *DefaultAPIService) PostSetChatMenuButtonExecute(r ApiPostSetChatMenuButtonRequest) (*SetChatMenuButtonResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetChatMenuButtonResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetChatMenuButton")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setChatMenuButton"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.chatId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	}
	if r.menuButton != nil {
		paramJson, err := parameterToJson(*r.menuButton)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("menu_button", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetChatPermissionsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *BotCommandScopeChatChatId
	permissions *ChatPermissions
	useIndependentChatPermissions *bool
}

func (r ApiPostSetChatPermissionsRequest) ChatId(chatId BotCommandScopeChatChatId) ApiPostSetChatPermissionsRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostSetChatPermissionsRequest) Permissions(permissions ChatPermissions) ApiPostSetChatPermissionsRequest {
	r.permissions = &permissions
	return r
}

// Pass *True* if chat permissions are set independently. Otherwise, the *can\\\\_send\\\\_other\\\\_messages* and *can\\\\_add\\\\_web\\\\_page\\\\_previews* permissions will imply the *can\\\\_send\\\\_messages*, *can\\\\_send\\\\_audios*, *can\\\\_send\\\\_documents*, *can\\\\_send\\\\_photos*, *can\\\\_send\\\\_videos*, *can\\\\_send\\\\_video\\\\_notes*, and *can\\\\_send\\\\_voice\\\\_notes* permissions; the *can\\\\_send\\\\_polls* permission will imply the *can\\\\_send\\\\_messages* permission.
func (r ApiPostSetChatPermissionsRequest) UseIndependentChatPermissions(useIndependentChatPermissions bool) ApiPostSetChatPermissionsRequest {
	r.useIndependentChatPermissions = &useIndependentChatPermissions
	return r
}

func (r ApiPostSetChatPermissionsRequest) Execute() (*SetChatPermissionsResponse, *http.Response, error) {
	return r.ApiService.PostSetChatPermissionsExecute(r)
}

/*
PostSetChatPermissions setChatPermissions

Use this method to set default chat permissions for all members. The bot must be an administrator in the group or a supergroup for this to work and must have the *can\_restrict\_members* administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetChatPermissionsRequest
*/
func (a *DefaultAPIService) PostSetChatPermissions(ctx context.Context) ApiPostSetChatPermissionsRequest {
	return ApiPostSetChatPermissionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetChatPermissionsResponse
func (a *DefaultAPIService) PostSetChatPermissionsExecute(r ApiPostSetChatPermissionsRequest) (*SetChatPermissionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetChatPermissionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetChatPermissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setChatPermissions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.permissions == nil {
		return localVarReturnValue, nil, reportError("permissions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "permissions", r.permissions, "", "")
	if r.useIndependentChatPermissions != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "use_independent_chat_permissions", r.useIndependentChatPermissions, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetChatPhotoRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	photo *interface{}
}

func (r ApiPostSetChatPhotoRequest) ChatId(chatId SendMessageRequestChatId) ApiPostSetChatPhotoRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostSetChatPhotoRequest) Photo(photo interface{}) ApiPostSetChatPhotoRequest {
	r.photo = &photo
	return r
}

func (r ApiPostSetChatPhotoRequest) Execute() (*SetChatPhotoResponse, *http.Response, error) {
	return r.ApiService.PostSetChatPhotoExecute(r)
}

/*
PostSetChatPhoto setChatPhoto

Use this method to set a new profile photo for the chat. Photos can't be changed for private chats. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetChatPhotoRequest
*/
func (a *DefaultAPIService) PostSetChatPhoto(ctx context.Context) ApiPostSetChatPhotoRequest {
	return ApiPostSetChatPhotoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetChatPhotoResponse
func (a *DefaultAPIService) PostSetChatPhotoExecute(r ApiPostSetChatPhotoRequest) (*SetChatPhotoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetChatPhotoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetChatPhoto")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setChatPhoto"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.photo == nil {
		return localVarReturnValue, nil, reportError("photo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "photo", r.photo, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetChatStickerSetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *BotCommandScopeChatChatId
	stickerSetName *string
}

func (r ApiPostSetChatStickerSetRequest) ChatId(chatId BotCommandScopeChatChatId) ApiPostSetChatStickerSetRequest {
	r.chatId = &chatId
	return r
}

// Name of the sticker set to be set as the group sticker set
func (r ApiPostSetChatStickerSetRequest) StickerSetName(stickerSetName string) ApiPostSetChatStickerSetRequest {
	r.stickerSetName = &stickerSetName
	return r
}

func (r ApiPostSetChatStickerSetRequest) Execute() (*SetChatStickerSetResponse, *http.Response, error) {
	return r.ApiService.PostSetChatStickerSetExecute(r)
}

/*
PostSetChatStickerSet setChatStickerSet

Use this method to set a new group sticker set for a supergroup. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Use the field *can\_set\_sticker\_set* optionally returned in [getChat](https://core.telegram.org/bots/api/#getchat) requests to check if the bot can use this method. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetChatStickerSetRequest
*/
func (a *DefaultAPIService) PostSetChatStickerSet(ctx context.Context) ApiPostSetChatStickerSetRequest {
	return ApiPostSetChatStickerSetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetChatStickerSetResponse
func (a *DefaultAPIService) PostSetChatStickerSetExecute(r ApiPostSetChatStickerSetRequest) (*SetChatStickerSetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetChatStickerSetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetChatStickerSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setChatStickerSet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.stickerSetName == nil {
		return localVarReturnValue, nil, reportError("stickerSetName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "sticker_set_name", r.stickerSetName, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetChatTitleRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	title *string
}

func (r ApiPostSetChatTitleRequest) ChatId(chatId SendMessageRequestChatId) ApiPostSetChatTitleRequest {
	r.chatId = &chatId
	return r
}

// New chat title, 1-128 characters
func (r ApiPostSetChatTitleRequest) Title(title string) ApiPostSetChatTitleRequest {
	r.title = &title
	return r
}

func (r ApiPostSetChatTitleRequest) Execute() (*SetChatTitleResponse, *http.Response, error) {
	return r.ApiService.PostSetChatTitleExecute(r)
}

/*
PostSetChatTitle setChatTitle

Use this method to change the title of a chat. Titles can't be changed for private chats. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetChatTitleRequest
*/
func (a *DefaultAPIService) PostSetChatTitle(ctx context.Context) ApiPostSetChatTitleRequest {
	return ApiPostSetChatTitleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetChatTitleResponse
func (a *DefaultAPIService) PostSetChatTitleExecute(r ApiPostSetChatTitleRequest) (*SetChatTitleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetChatTitleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetChatTitle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setChatTitle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if strlen(*r.title) < 1 {
		return localVarReturnValue, nil, reportError("title must have at least 1 elements")
	}
	if strlen(*r.title) > 128 {
		return localVarReturnValue, nil, reportError("title must have less than 128 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetCustomEmojiStickerSetThumbnailRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	name *string
	customEmojiId *string
}

// Sticker set name
func (r ApiPostSetCustomEmojiStickerSetThumbnailRequest) Name(name string) ApiPostSetCustomEmojiStickerSetThumbnailRequest {
	r.name = &name
	return r
}

// Custom emoji identifier of a sticker from the sticker set; pass an empty string to drop the thumbnail and use the first sticker as the thumbnail.
func (r ApiPostSetCustomEmojiStickerSetThumbnailRequest) CustomEmojiId(customEmojiId string) ApiPostSetCustomEmojiStickerSetThumbnailRequest {
	r.customEmojiId = &customEmojiId
	return r
}

func (r ApiPostSetCustomEmojiStickerSetThumbnailRequest) Execute() (*SetCustomEmojiStickerSetThumbnailResponse, *http.Response, error) {
	return r.ApiService.PostSetCustomEmojiStickerSetThumbnailExecute(r)
}

/*
PostSetCustomEmojiStickerSetThumbnail setCustomEmojiStickerSetThumbnail

Use this method to set the thumbnail of a custom emoji sticker set. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetCustomEmojiStickerSetThumbnailRequest
*/
func (a *DefaultAPIService) PostSetCustomEmojiStickerSetThumbnail(ctx context.Context) ApiPostSetCustomEmojiStickerSetThumbnailRequest {
	return ApiPostSetCustomEmojiStickerSetThumbnailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetCustomEmojiStickerSetThumbnailResponse
func (a *DefaultAPIService) PostSetCustomEmojiStickerSetThumbnailExecute(r ApiPostSetCustomEmojiStickerSetThumbnailRequest) (*SetCustomEmojiStickerSetThumbnailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetCustomEmojiStickerSetThumbnailResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetCustomEmojiStickerSetThumbnail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setCustomEmojiStickerSetThumbnail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	if r.customEmojiId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "custom_emoji_id", r.customEmojiId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetGameScoreRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	score *int32
	force *bool
	disableEditMessage *bool
	chatId *int32
	messageId *int32
	inlineMessageId *string
}

// User identifier
func (r ApiPostSetGameScoreRequest) UserId(userId int32) ApiPostSetGameScoreRequest {
	r.userId = &userId
	return r
}

// New score, must be non-negative
func (r ApiPostSetGameScoreRequest) Score(score int32) ApiPostSetGameScoreRequest {
	r.score = &score
	return r
}

// Pass *True* if the high score is allowed to decrease. This can be useful when fixing mistakes or banning cheaters
func (r ApiPostSetGameScoreRequest) Force(force bool) ApiPostSetGameScoreRequest {
	r.force = &force
	return r
}

// Pass *True* if the game message should not be automatically edited to include the current scoreboard
func (r ApiPostSetGameScoreRequest) DisableEditMessage(disableEditMessage bool) ApiPostSetGameScoreRequest {
	r.disableEditMessage = &disableEditMessage
	return r
}

// Required if *inline\\\\_message\\\\_id* is not specified. Unique identifier for the target chat
func (r ApiPostSetGameScoreRequest) ChatId(chatId int32) ApiPostSetGameScoreRequest {
	r.chatId = &chatId
	return r
}

// Required if *inline\\\\_message\\\\_id* is not specified. Identifier of the sent message
func (r ApiPostSetGameScoreRequest) MessageId(messageId int32) ApiPostSetGameScoreRequest {
	r.messageId = &messageId
	return r
}

// Required if *chat\\\\_id* and *message\\\\_id* are not specified. Identifier of the inline message
func (r ApiPostSetGameScoreRequest) InlineMessageId(inlineMessageId string) ApiPostSetGameScoreRequest {
	r.inlineMessageId = &inlineMessageId
	return r
}

func (r ApiPostSetGameScoreRequest) Execute() (*SetGameScoreResponse, *http.Response, error) {
	return r.ApiService.PostSetGameScoreExecute(r)
}

/*
PostSetGameScore setGameScore

Use this method to set the score of the specified user in a game message. On success, if the message is not an inline message, the [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned. Returns an error, if the new score is not greater than the user's current score in the chat and *force* is *False*.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetGameScoreRequest
*/
func (a *DefaultAPIService) PostSetGameScore(ctx context.Context) ApiPostSetGameScoreRequest {
	return ApiPostSetGameScoreRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetGameScoreResponse
func (a *DefaultAPIService) PostSetGameScoreExecute(r ApiPostSetGameScoreRequest) (*SetGameScoreResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetGameScoreResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetGameScore")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setGameScore"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.score == nil {
		return localVarReturnValue, nil, reportError("score is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "score", r.score, "", "")
	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "force", r.force, "", "")
	}
	if r.disableEditMessage != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_edit_message", r.disableEditMessage, "", "")
	}
	if r.chatId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	}
	if r.messageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	}
	if r.inlineMessageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "inline_message_id", r.inlineMessageId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetMessageReactionRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	messageId *int32
	reaction *[]ReactionType
	isBig *bool
}

func (r ApiPostSetMessageReactionRequest) ChatId(chatId SendMessageRequestChatId) ApiPostSetMessageReactionRequest {
	r.chatId = &chatId
	return r
}

// Identifier of the target message. If the message belongs to a media group, the reaction is set to the first non-deleted message in the group instead.
func (r ApiPostSetMessageReactionRequest) MessageId(messageId int32) ApiPostSetMessageReactionRequest {
	r.messageId = &messageId
	return r
}

// A JSON-serialized list of reaction types to set on the message. Currently, as non-premium users, bots can set up to one reaction per message. A custom emoji reaction can be used if it is either already present on the message or explicitly allowed by chat administrators. Paid reactions can&#39;t be used by bots.
func (r ApiPostSetMessageReactionRequest) Reaction(reaction []ReactionType) ApiPostSetMessageReactionRequest {
	r.reaction = &reaction
	return r
}

// Pass *True* to set the reaction with a big animation
func (r ApiPostSetMessageReactionRequest) IsBig(isBig bool) ApiPostSetMessageReactionRequest {
	r.isBig = &isBig
	return r
}

func (r ApiPostSetMessageReactionRequest) Execute() (*SetMessageReactionResponse, *http.Response, error) {
	return r.ApiService.PostSetMessageReactionExecute(r)
}

/*
PostSetMessageReaction setMessageReaction

Use this method to change the chosen reactions on a message. Service messages of some types can't be reacted to. Automatically forwarded messages from a channel to its discussion group have the same available reactions as messages in the channel. Bots can't use paid reactions. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetMessageReactionRequest
*/
func (a *DefaultAPIService) PostSetMessageReaction(ctx context.Context) ApiPostSetMessageReactionRequest {
	return ApiPostSetMessageReactionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetMessageReactionResponse
func (a *DefaultAPIService) PostSetMessageReactionExecute(r ApiPostSetMessageReactionRequest) (*SetMessageReactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetMessageReactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetMessageReaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setMessageReaction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.messageId == nil {
		return localVarReturnValue, nil, reportError("messageId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	if r.reaction != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "reaction", r.reaction, "", "csv")
	}
	if r.isBig != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_big", r.isBig, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetMyCommandsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	commands *[]BotCommand
	scope *BotCommandScope
	languageCode *string
}

// A JSON-serialized list of bot commands to be set as the list of the bot&#39;s commands. At most 100 commands can be specified.
func (r ApiPostSetMyCommandsRequest) Commands(commands []BotCommand) ApiPostSetMyCommandsRequest {
	r.commands = &commands
	return r
}

func (r ApiPostSetMyCommandsRequest) Scope(scope BotCommandScope) ApiPostSetMyCommandsRequest {
	r.scope = &scope
	return r
}

// A two-letter ISO 639-1 language code. If empty, commands will be applied to all users from the given scope, for whose language there are no dedicated commands
func (r ApiPostSetMyCommandsRequest) LanguageCode(languageCode string) ApiPostSetMyCommandsRequest {
	r.languageCode = &languageCode
	return r
}

func (r ApiPostSetMyCommandsRequest) Execute() (*SetMyCommandsResponse, *http.Response, error) {
	return r.ApiService.PostSetMyCommandsExecute(r)
}

/*
PostSetMyCommands setMyCommands

Use this method to change the list of the bot's commands. See [this manual](https://core.telegram.org/bots/features#commands) for more details about bot commands. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetMyCommandsRequest
*/
func (a *DefaultAPIService) PostSetMyCommands(ctx context.Context) ApiPostSetMyCommandsRequest {
	return ApiPostSetMyCommandsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetMyCommandsResponse
func (a *DefaultAPIService) PostSetMyCommandsExecute(r ApiPostSetMyCommandsRequest) (*SetMyCommandsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetMyCommandsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetMyCommands")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setMyCommands"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.commands == nil {
		return localVarReturnValue, nil, reportError("commands is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "commands", r.commands, "", "csv")
	if r.scope != nil {
		paramJson, err := parameterToJson(*r.scope)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("scope", paramJson)
	}
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "language_code", r.languageCode, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetMyDefaultAdministratorRightsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	rights *ChatAdministratorRights
	forChannels *bool
}

func (r ApiPostSetMyDefaultAdministratorRightsRequest) Rights(rights ChatAdministratorRights) ApiPostSetMyDefaultAdministratorRightsRequest {
	r.rights = &rights
	return r
}

// Pass *True* to change the default administrator rights of the bot in channels. Otherwise, the default administrator rights of the bot for groups and supergroups will be changed.
func (r ApiPostSetMyDefaultAdministratorRightsRequest) ForChannels(forChannels bool) ApiPostSetMyDefaultAdministratorRightsRequest {
	r.forChannels = &forChannels
	return r
}

func (r ApiPostSetMyDefaultAdministratorRightsRequest) Execute() (*SetMyDefaultAdministratorRightsResponse, *http.Response, error) {
	return r.ApiService.PostSetMyDefaultAdministratorRightsExecute(r)
}

/*
PostSetMyDefaultAdministratorRights setMyDefaultAdministratorRights

Use this method to change the default administrator rights requested by the bot when it's added as an administrator to groups or channels. These rights will be suggested to users, but they are free to modify the list before adding the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetMyDefaultAdministratorRightsRequest
*/
func (a *DefaultAPIService) PostSetMyDefaultAdministratorRights(ctx context.Context) ApiPostSetMyDefaultAdministratorRightsRequest {
	return ApiPostSetMyDefaultAdministratorRightsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetMyDefaultAdministratorRightsResponse
func (a *DefaultAPIService) PostSetMyDefaultAdministratorRightsExecute(r ApiPostSetMyDefaultAdministratorRightsRequest) (*SetMyDefaultAdministratorRightsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetMyDefaultAdministratorRightsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetMyDefaultAdministratorRights")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setMyDefaultAdministratorRights"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.rights != nil {
		paramJson, err := parameterToJson(*r.rights)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("rights", paramJson)
	}
	if r.forChannels != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "for_channels", r.forChannels, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetMyDescriptionRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	description *string
	languageCode *string
}

// New bot description; 0-512 characters. Pass an empty string to remove the dedicated description for the given language.
func (r ApiPostSetMyDescriptionRequest) Description(description string) ApiPostSetMyDescriptionRequest {
	r.description = &description
	return r
}

// A two-letter ISO 639-1 language code. If empty, the description will be applied to all users for whose language there is no dedicated description.
func (r ApiPostSetMyDescriptionRequest) LanguageCode(languageCode string) ApiPostSetMyDescriptionRequest {
	r.languageCode = &languageCode
	return r
}

func (r ApiPostSetMyDescriptionRequest) Execute() (*SetMyDescriptionResponse, *http.Response, error) {
	return r.ApiService.PostSetMyDescriptionExecute(r)
}

/*
PostSetMyDescription setMyDescription

Use this method to change the bot's description, which is shown in the chat with the bot if the chat is empty. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetMyDescriptionRequest
*/
func (a *DefaultAPIService) PostSetMyDescription(ctx context.Context) ApiPostSetMyDescriptionRequest {
	return ApiPostSetMyDescriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetMyDescriptionResponse
func (a *DefaultAPIService) PostSetMyDescriptionExecute(r ApiPostSetMyDescriptionRequest) (*SetMyDescriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetMyDescriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetMyDescription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setMyDescription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "", "")
	}
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "language_code", r.languageCode, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetMyNameRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	name *string
	languageCode *string
}

// New bot name; 0-64 characters. Pass an empty string to remove the dedicated name for the given language.
func (r ApiPostSetMyNameRequest) Name(name string) ApiPostSetMyNameRequest {
	r.name = &name
	return r
}

// A two-letter ISO 639-1 language code. If empty, the name will be shown to all users for whose language there is no dedicated name.
func (r ApiPostSetMyNameRequest) LanguageCode(languageCode string) ApiPostSetMyNameRequest {
	r.languageCode = &languageCode
	return r
}

func (r ApiPostSetMyNameRequest) Execute() (*SetMyNameResponse, *http.Response, error) {
	return r.ApiService.PostSetMyNameExecute(r)
}

/*
PostSetMyName setMyName

Use this method to change the bot's name. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetMyNameRequest
*/
func (a *DefaultAPIService) PostSetMyName(ctx context.Context) ApiPostSetMyNameRequest {
	return ApiPostSetMyNameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetMyNameResponse
func (a *DefaultAPIService) PostSetMyNameExecute(r ApiPostSetMyNameRequest) (*SetMyNameResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetMyNameResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetMyName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setMyName"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	}
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "language_code", r.languageCode, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetMyShortDescriptionRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	shortDescription *string
	languageCode *string
}

// New short description for the bot; 0-120 characters. Pass an empty string to remove the dedicated short description for the given language.
func (r ApiPostSetMyShortDescriptionRequest) ShortDescription(shortDescription string) ApiPostSetMyShortDescriptionRequest {
	r.shortDescription = &shortDescription
	return r
}

// A two-letter ISO 639-1 language code. If empty, the short description will be applied to all users for whose language there is no dedicated short description.
func (r ApiPostSetMyShortDescriptionRequest) LanguageCode(languageCode string) ApiPostSetMyShortDescriptionRequest {
	r.languageCode = &languageCode
	return r
}

func (r ApiPostSetMyShortDescriptionRequest) Execute() (*SetMyShortDescriptionResponse, *http.Response, error) {
	return r.ApiService.PostSetMyShortDescriptionExecute(r)
}

/*
PostSetMyShortDescription setMyShortDescription

Use this method to change the bot's short description, which is shown on the bot's profile page and is sent together with the link when users share the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetMyShortDescriptionRequest
*/
func (a *DefaultAPIService) PostSetMyShortDescription(ctx context.Context) ApiPostSetMyShortDescriptionRequest {
	return ApiPostSetMyShortDescriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetMyShortDescriptionResponse
func (a *DefaultAPIService) PostSetMyShortDescriptionExecute(r ApiPostSetMyShortDescriptionRequest) (*SetMyShortDescriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetMyShortDescriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetMyShortDescription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setMyShortDescription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shortDescription != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "short_description", r.shortDescription, "", "")
	}
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "language_code", r.languageCode, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetPassportDataErrorsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	errors *[]PassportElementError
}

// User identifier
func (r ApiPostSetPassportDataErrorsRequest) UserId(userId int32) ApiPostSetPassportDataErrorsRequest {
	r.userId = &userId
	return r
}

// A JSON-serialized array describing the errors
func (r ApiPostSetPassportDataErrorsRequest) Errors(errors []PassportElementError) ApiPostSetPassportDataErrorsRequest {
	r.errors = &errors
	return r
}

func (r ApiPostSetPassportDataErrorsRequest) Execute() (*SetPassportDataErrorsResponse, *http.Response, error) {
	return r.ApiService.PostSetPassportDataErrorsExecute(r)
}

/*
PostSetPassportDataErrors setPassportDataErrors

Informs a user that some of the Telegram Passport elements they provided contains errors. The user will not be able to re-submit their Passport to you until the errors are fixed (the contents of the field for which you returned the error must change). Returns *True* on success.

Use this if the data submitted by the user doesn't satisfy the standards your service requires for any reason. For example, if a birthday date seems invalid, a submitted document is blurry, a scan shows evidence of tampering, etc. Supply some details in the error message to make sure the user knows how to correct the issues.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetPassportDataErrorsRequest
*/
func (a *DefaultAPIService) PostSetPassportDataErrors(ctx context.Context) ApiPostSetPassportDataErrorsRequest {
	return ApiPostSetPassportDataErrorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetPassportDataErrorsResponse
func (a *DefaultAPIService) PostSetPassportDataErrorsExecute(r ApiPostSetPassportDataErrorsRequest) (*SetPassportDataErrorsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetPassportDataErrorsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetPassportDataErrors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setPassportDataErrors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.errors == nil {
		return localVarReturnValue, nil, reportError("errors is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "errors", r.errors, "", "csv")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetStickerEmojiListRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	sticker *string
	emojiList *[]string
}

// File identifier of the sticker
func (r ApiPostSetStickerEmojiListRequest) Sticker(sticker string) ApiPostSetStickerEmojiListRequest {
	r.sticker = &sticker
	return r
}

// A JSON-serialized list of 1-20 emoji associated with the sticker
func (r ApiPostSetStickerEmojiListRequest) EmojiList(emojiList []string) ApiPostSetStickerEmojiListRequest {
	r.emojiList = &emojiList
	return r
}

func (r ApiPostSetStickerEmojiListRequest) Execute() (*SetStickerEmojiListResponse, *http.Response, error) {
	return r.ApiService.PostSetStickerEmojiListExecute(r)
}

/*
PostSetStickerEmojiList setStickerEmojiList

Use this method to change the list of emoji assigned to a regular or custom emoji sticker. The sticker must belong to a sticker set created by the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetStickerEmojiListRequest
*/
func (a *DefaultAPIService) PostSetStickerEmojiList(ctx context.Context) ApiPostSetStickerEmojiListRequest {
	return ApiPostSetStickerEmojiListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetStickerEmojiListResponse
func (a *DefaultAPIService) PostSetStickerEmojiListExecute(r ApiPostSetStickerEmojiListRequest) (*SetStickerEmojiListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetStickerEmojiListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetStickerEmojiList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setStickerEmojiList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sticker == nil {
		return localVarReturnValue, nil, reportError("sticker is required and must be specified")
	}
	if r.emojiList == nil {
		return localVarReturnValue, nil, reportError("emojiList is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "sticker", r.sticker, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "emoji_list", r.emojiList, "", "csv")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetStickerKeywordsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	sticker *string
	keywords *[]string
}

// File identifier of the sticker
func (r ApiPostSetStickerKeywordsRequest) Sticker(sticker string) ApiPostSetStickerKeywordsRequest {
	r.sticker = &sticker
	return r
}

// A JSON-serialized list of 0-20 search keywords for the sticker with total length of up to 64 characters
func (r ApiPostSetStickerKeywordsRequest) Keywords(keywords []string) ApiPostSetStickerKeywordsRequest {
	r.keywords = &keywords
	return r
}

func (r ApiPostSetStickerKeywordsRequest) Execute() (*SetStickerKeywordsResponse, *http.Response, error) {
	return r.ApiService.PostSetStickerKeywordsExecute(r)
}

/*
PostSetStickerKeywords setStickerKeywords

Use this method to change search keywords assigned to a regular or custom emoji sticker. The sticker must belong to a sticker set created by the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetStickerKeywordsRequest
*/
func (a *DefaultAPIService) PostSetStickerKeywords(ctx context.Context) ApiPostSetStickerKeywordsRequest {
	return ApiPostSetStickerKeywordsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetStickerKeywordsResponse
func (a *DefaultAPIService) PostSetStickerKeywordsExecute(r ApiPostSetStickerKeywordsRequest) (*SetStickerKeywordsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetStickerKeywordsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetStickerKeywords")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setStickerKeywords"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sticker == nil {
		return localVarReturnValue, nil, reportError("sticker is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "sticker", r.sticker, "", "")
	if r.keywords != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "keywords", r.keywords, "", "csv")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetStickerMaskPositionRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	sticker *string
	maskPosition *MaskPosition
}

// File identifier of the sticker
func (r ApiPostSetStickerMaskPositionRequest) Sticker(sticker string) ApiPostSetStickerMaskPositionRequest {
	r.sticker = &sticker
	return r
}

func (r ApiPostSetStickerMaskPositionRequest) MaskPosition(maskPosition MaskPosition) ApiPostSetStickerMaskPositionRequest {
	r.maskPosition = &maskPosition
	return r
}

func (r ApiPostSetStickerMaskPositionRequest) Execute() (*SetStickerMaskPositionResponse, *http.Response, error) {
	return r.ApiService.PostSetStickerMaskPositionExecute(r)
}

/*
PostSetStickerMaskPosition setStickerMaskPosition

Use this method to change the [mask position](https://core.telegram.org/bots/api/#maskposition) of a mask sticker. The sticker must belong to a sticker set that was created by the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetStickerMaskPositionRequest
*/
func (a *DefaultAPIService) PostSetStickerMaskPosition(ctx context.Context) ApiPostSetStickerMaskPositionRequest {
	return ApiPostSetStickerMaskPositionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetStickerMaskPositionResponse
func (a *DefaultAPIService) PostSetStickerMaskPositionExecute(r ApiPostSetStickerMaskPositionRequest) (*SetStickerMaskPositionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetStickerMaskPositionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetStickerMaskPosition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setStickerMaskPosition"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sticker == nil {
		return localVarReturnValue, nil, reportError("sticker is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "sticker", r.sticker, "", "")
	if r.maskPosition != nil {
		paramJson, err := parameterToJson(*r.maskPosition)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("mask_position", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetStickerPositionInSetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	sticker *string
	position *int32
}

// File identifier of the sticker
func (r ApiPostSetStickerPositionInSetRequest) Sticker(sticker string) ApiPostSetStickerPositionInSetRequest {
	r.sticker = &sticker
	return r
}

// New sticker position in the set, zero-based
func (r ApiPostSetStickerPositionInSetRequest) Position(position int32) ApiPostSetStickerPositionInSetRequest {
	r.position = &position
	return r
}

func (r ApiPostSetStickerPositionInSetRequest) Execute() (*SetStickerPositionInSetResponse, *http.Response, error) {
	return r.ApiService.PostSetStickerPositionInSetExecute(r)
}

/*
PostSetStickerPositionInSet setStickerPositionInSet

Use this method to move a sticker in a set created by the bot to a specific position. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetStickerPositionInSetRequest
*/
func (a *DefaultAPIService) PostSetStickerPositionInSet(ctx context.Context) ApiPostSetStickerPositionInSetRequest {
	return ApiPostSetStickerPositionInSetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetStickerPositionInSetResponse
func (a *DefaultAPIService) PostSetStickerPositionInSetExecute(r ApiPostSetStickerPositionInSetRequest) (*SetStickerPositionInSetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetStickerPositionInSetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetStickerPositionInSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setStickerPositionInSet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sticker == nil {
		return localVarReturnValue, nil, reportError("sticker is required and must be specified")
	}
	if r.position == nil {
		return localVarReturnValue, nil, reportError("position is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "sticker", r.sticker, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "position", r.position, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetStickerSetThumbnailRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	name *string
	userId *int32
	format *string
	thumbnail *string
}

// Sticker set name
func (r ApiPostSetStickerSetThumbnailRequest) Name(name string) ApiPostSetStickerSetThumbnailRequest {
	r.name = &name
	return r
}

// User identifier of the sticker set owner
func (r ApiPostSetStickerSetThumbnailRequest) UserId(userId int32) ApiPostSetStickerSetThumbnailRequest {
	r.userId = &userId
	return r
}

// Format of the thumbnail, must be one of “static” for a **.WEBP** or **.PNG** image, “animated” for a **.TGS** animation, or “video” for a **.WEBM** video
func (r ApiPostSetStickerSetThumbnailRequest) Format(format string) ApiPostSetStickerSetThumbnailRequest {
	r.format = &format
	return r
}

func (r ApiPostSetStickerSetThumbnailRequest) Thumbnail(thumbnail string) ApiPostSetStickerSetThumbnailRequest {
	r.thumbnail = &thumbnail
	return r
}

func (r ApiPostSetStickerSetThumbnailRequest) Execute() (*SetStickerSetThumbnailResponse, *http.Response, error) {
	return r.ApiService.PostSetStickerSetThumbnailExecute(r)
}

/*
PostSetStickerSetThumbnail setStickerSetThumbnail

Use this method to set the thumbnail of a regular or mask sticker set. The format of the thumbnail file must match the format of the stickers in the set. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetStickerSetThumbnailRequest
*/
func (a *DefaultAPIService) PostSetStickerSetThumbnail(ctx context.Context) ApiPostSetStickerSetThumbnailRequest {
	return ApiPostSetStickerSetThumbnailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetStickerSetThumbnailResponse
func (a *DefaultAPIService) PostSetStickerSetThumbnailExecute(r ApiPostSetStickerSetThumbnailRequest) (*SetStickerSetThumbnailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetStickerSetThumbnailResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetStickerSetThumbnail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setStickerSetThumbnail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.format == nil {
		return localVarReturnValue, nil, reportError("format is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	if r.thumbnail != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "thumbnail", r.thumbnail, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "format", r.format, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetStickerSetTitleRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	name *string
	title *string
}

// Sticker set name
func (r ApiPostSetStickerSetTitleRequest) Name(name string) ApiPostSetStickerSetTitleRequest {
	r.name = &name
	return r
}

// Sticker set title, 1-64 characters
func (r ApiPostSetStickerSetTitleRequest) Title(title string) ApiPostSetStickerSetTitleRequest {
	r.title = &title
	return r
}

func (r ApiPostSetStickerSetTitleRequest) Execute() (*SetStickerSetTitleResponse, *http.Response, error) {
	return r.ApiService.PostSetStickerSetTitleExecute(r)
}

/*
PostSetStickerSetTitle setStickerSetTitle

Use this method to set the title of a created sticker set. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetStickerSetTitleRequest
*/
func (a *DefaultAPIService) PostSetStickerSetTitle(ctx context.Context) ApiPostSetStickerSetTitleRequest {
	return ApiPostSetStickerSetTitleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetStickerSetTitleResponse
func (a *DefaultAPIService) PostSetStickerSetTitleExecute(r ApiPostSetStickerSetTitleRequest) (*SetStickerSetTitleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetStickerSetTitleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetStickerSetTitle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setStickerSetTitle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if strlen(*r.title) < 1 {
		return localVarReturnValue, nil, reportError("title must have at least 1 elements")
	}
	if strlen(*r.title) > 64 {
		return localVarReturnValue, nil, reportError("title must have less than 64 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetUserEmojiStatusRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	emojiStatusCustomEmojiId *string
	emojiStatusExpirationDate *int32
}

// Unique identifier of the target user
func (r ApiPostSetUserEmojiStatusRequest) UserId(userId int32) ApiPostSetUserEmojiStatusRequest {
	r.userId = &userId
	return r
}

// Custom emoji identifier of the emoji status to set. Pass an empty string to remove the status.
func (r ApiPostSetUserEmojiStatusRequest) EmojiStatusCustomEmojiId(emojiStatusCustomEmojiId string) ApiPostSetUserEmojiStatusRequest {
	r.emojiStatusCustomEmojiId = &emojiStatusCustomEmojiId
	return r
}

// Expiration date of the emoji status, if any
func (r ApiPostSetUserEmojiStatusRequest) EmojiStatusExpirationDate(emojiStatusExpirationDate int32) ApiPostSetUserEmojiStatusRequest {
	r.emojiStatusExpirationDate = &emojiStatusExpirationDate
	return r
}

func (r ApiPostSetUserEmojiStatusRequest) Execute() (*SetUserEmojiStatusResponse, *http.Response, error) {
	return r.ApiService.PostSetUserEmojiStatusExecute(r)
}

/*
PostSetUserEmojiStatus setUserEmojiStatus

Changes the emoji status for a given user that previously allowed the bot to manage their emoji status via the Mini App method [requestEmojiStatusAccess](https://core.telegram.org/bots/webapps#initializing-mini-apps). Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetUserEmojiStatusRequest
*/
func (a *DefaultAPIService) PostSetUserEmojiStatus(ctx context.Context) ApiPostSetUserEmojiStatusRequest {
	return ApiPostSetUserEmojiStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetUserEmojiStatusResponse
func (a *DefaultAPIService) PostSetUserEmojiStatusExecute(r ApiPostSetUserEmojiStatusRequest) (*SetUserEmojiStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetUserEmojiStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetUserEmojiStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setUserEmojiStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	if r.emojiStatusCustomEmojiId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "emoji_status_custom_emoji_id", r.emojiStatusCustomEmojiId, "", "")
	}
	if r.emojiStatusExpirationDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "emoji_status_expiration_date", r.emojiStatusExpirationDate, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSetWebhookRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	url *string
	certificate *interface{}
	ipAddress *string
	maxConnections *int32
	allowedUpdates *[]string
	dropPendingUpdates *bool
	secretToken *string
}

// HTTPS URL to send updates to. Use an empty string to remove webhook integration
func (r ApiPostSetWebhookRequest) Url(url string) ApiPostSetWebhookRequest {
	r.url = &url
	return r
}

func (r ApiPostSetWebhookRequest) Certificate(certificate interface{}) ApiPostSetWebhookRequest {
	r.certificate = &certificate
	return r
}

// The fixed IP address which will be used to send webhook requests instead of the IP address resolved through DNS
func (r ApiPostSetWebhookRequest) IpAddress(ipAddress string) ApiPostSetWebhookRequest {
	r.ipAddress = &ipAddress
	return r
}

// The maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery, 1-100. Defaults to *40*. Use lower values to limit the load on your bot&#39;s server, and higher values to increase your bot&#39;s throughput.
func (r ApiPostSetWebhookRequest) MaxConnections(maxConnections int32) ApiPostSetWebhookRequest {
	r.maxConnections = &maxConnections
	return r
}

// A JSON-serialized list of the update types you want your bot to receive. For example, specify &#x60;[\\\&quot;message\\\&quot;, \\\&quot;edited_channel_post\\\&quot;, \\\&quot;callback_query\\\&quot;]&#x60; to only receive updates of these types. See [Update](https://core.telegram.org/bots/api/#update) for a complete list of available update types. Specify an empty list to receive all update types except *chat\\\\_member*, *message\\\\_reaction*, and *message\\\\_reaction\\\\_count* (default). If not specified, the previous setting will be used.   Please note that this parameter doesn&#39;t affect updates created before the call to the setWebhook, so unwanted updates may be received for a short period of time.
func (r ApiPostSetWebhookRequest) AllowedUpdates(allowedUpdates []string) ApiPostSetWebhookRequest {
	r.allowedUpdates = &allowedUpdates
	return r
}

// Pass *True* to drop all pending updates
func (r ApiPostSetWebhookRequest) DropPendingUpdates(dropPendingUpdates bool) ApiPostSetWebhookRequest {
	r.dropPendingUpdates = &dropPendingUpdates
	return r
}

// A secret token to be sent in a header “X-Telegram-Bot-Api-Secret-Token” in every webhook request, 1-256 characters. Only characters &#x60;A-Z&#x60;, &#x60;a-z&#x60;, &#x60;0-9&#x60;, &#x60;_&#x60; and &#x60;-&#x60; are allowed. The header is useful to ensure that the request comes from a webhook set by you.
func (r ApiPostSetWebhookRequest) SecretToken(secretToken string) ApiPostSetWebhookRequest {
	r.secretToken = &secretToken
	return r
}

func (r ApiPostSetWebhookRequest) Execute() (*SetWebhookResponse, *http.Response, error) {
	return r.ApiService.PostSetWebhookExecute(r)
}

/*
PostSetWebhook setWebhook

Use this method to specify a URL and receive incoming updates via an outgoing webhook. Whenever there is an update for the bot, we will send an HTTPS POST request to the specified URL, containing a JSON-serialized [Update](https://core.telegram.org/bots/api/#update). In case of an unsuccessful request (a request with response [HTTP status code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) different from `2XY`), we will repeat the request and give up after a reasonable amount of attempts. Returns *True* on success.

If you'd like to make sure that the webhook was set by you, you can specify secret data in the parameter *secret\_token*. If specified, the request will contain a header “X-Telegram-Bot-Api-Secret-Token” with the secret token as content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSetWebhookRequest
*/
func (a *DefaultAPIService) PostSetWebhook(ctx context.Context) ApiPostSetWebhookRequest {
	return ApiPostSetWebhookRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookResponse
func (a *DefaultAPIService) PostSetWebhookExecute(r ApiPostSetWebhookRequest) (*SetWebhookResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostSetWebhook")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setWebhook"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.url == nil {
		return localVarReturnValue, nil, reportError("url is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "url", r.url, "", "")
	if r.certificate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "certificate", r.certificate, "", "")
	}
	if r.ipAddress != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "ip_address", r.ipAddress, "", "")
	}
	if r.maxConnections != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "max_connections", r.maxConnections, "", "")
	}
	if r.allowedUpdates != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allowed_updates", r.allowedUpdates, "", "csv")
	}
	if r.dropPendingUpdates != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "drop_pending_updates", r.dropPendingUpdates, "", "")
	}
	if r.secretToken != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "secret_token", r.secretToken, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostStopMessageLiveLocationRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	chatId *EditMessageTextRequestChatId
	messageId *int32
	inlineMessageId *string
	replyMarkup *InlineKeyboardMarkup
}

// Unique identifier of the business connection on behalf of which the message to be edited was sent
func (r ApiPostStopMessageLiveLocationRequest) BusinessConnectionId(businessConnectionId string) ApiPostStopMessageLiveLocationRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

func (r ApiPostStopMessageLiveLocationRequest) ChatId(chatId EditMessageTextRequestChatId) ApiPostStopMessageLiveLocationRequest {
	r.chatId = &chatId
	return r
}

// Required if *inline\\\\_message\\\\_id* is not specified. Identifier of the message with live location to stop
func (r ApiPostStopMessageLiveLocationRequest) MessageId(messageId int32) ApiPostStopMessageLiveLocationRequest {
	r.messageId = &messageId
	return r
}

// Required if *chat\\\\_id* and *message\\\\_id* are not specified. Identifier of the inline message
func (r ApiPostStopMessageLiveLocationRequest) InlineMessageId(inlineMessageId string) ApiPostStopMessageLiveLocationRequest {
	r.inlineMessageId = &inlineMessageId
	return r
}

func (r ApiPostStopMessageLiveLocationRequest) ReplyMarkup(replyMarkup InlineKeyboardMarkup) ApiPostStopMessageLiveLocationRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostStopMessageLiveLocationRequest) Execute() (*StopMessageLiveLocationResponse, *http.Response, error) {
	return r.ApiService.PostStopMessageLiveLocationExecute(r)
}

/*
PostStopMessageLiveLocation stopMessageLiveLocation

Use this method to stop updating a live location message before *live\_period* expires. On success, if the message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostStopMessageLiveLocationRequest
*/
func (a *DefaultAPIService) PostStopMessageLiveLocation(ctx context.Context) ApiPostStopMessageLiveLocationRequest {
	return ApiPostStopMessageLiveLocationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StopMessageLiveLocationResponse
func (a *DefaultAPIService) PostStopMessageLiveLocationExecute(r ApiPostStopMessageLiveLocationRequest) (*StopMessageLiveLocationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StopMessageLiveLocationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostStopMessageLiveLocation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stopMessageLiveLocation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	if r.chatId != nil {
		paramJson, err := parameterToJson(*r.chatId)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("chat_id", paramJson)
	}
	if r.messageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	}
	if r.inlineMessageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "inline_message_id", r.inlineMessageId, "", "")
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostStopPollRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	messageId *int32
	businessConnectionId *string
	replyMarkup *InlineKeyboardMarkup
}

func (r ApiPostStopPollRequest) ChatId(chatId SendMessageRequestChatId) ApiPostStopPollRequest {
	r.chatId = &chatId
	return r
}

// Identifier of the original message with the poll
func (r ApiPostStopPollRequest) MessageId(messageId int32) ApiPostStopPollRequest {
	r.messageId = &messageId
	return r
}

// Unique identifier of the business connection on behalf of which the message to be edited was sent
func (r ApiPostStopPollRequest) BusinessConnectionId(businessConnectionId string) ApiPostStopPollRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

func (r ApiPostStopPollRequest) ReplyMarkup(replyMarkup InlineKeyboardMarkup) ApiPostStopPollRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiPostStopPollRequest) Execute() (*StopPollResponse, *http.Response, error) {
	return r.ApiService.PostStopPollExecute(r)
}

/*
PostStopPoll stopPoll

Use this method to stop a poll which was sent by the bot. On success, the stopped [Poll](https://core.telegram.org/bots/api/#poll) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostStopPollRequest
*/
func (a *DefaultAPIService) PostStopPoll(ctx context.Context) ApiPostStopPollRequest {
	return ApiPostStopPollRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StopPollResponse
func (a *DefaultAPIService) PostStopPollExecute(r ApiPostStopPollRequest) (*StopPollResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StopPollResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostStopPoll")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stopPoll"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.messageId == nil {
		return localVarReturnValue, nil, reportError("messageId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostTransferBusinessAccountStarsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	starCount *int32
}

// Unique identifier of the business connection
func (r ApiPostTransferBusinessAccountStarsRequest) BusinessConnectionId(businessConnectionId string) ApiPostTransferBusinessAccountStarsRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Number of Telegram Stars to transfer; 1-10000
func (r ApiPostTransferBusinessAccountStarsRequest) StarCount(starCount int32) ApiPostTransferBusinessAccountStarsRequest {
	r.starCount = &starCount
	return r
}

func (r ApiPostTransferBusinessAccountStarsRequest) Execute() (*TransferBusinessAccountStarsResponse, *http.Response, error) {
	return r.ApiService.PostTransferBusinessAccountStarsExecute(r)
}

/*
PostTransferBusinessAccountStars transferBusinessAccountStars

Transfers Telegram Stars from the business account balance to the bot's balance. Requires the *can\_transfer\_stars* business bot right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostTransferBusinessAccountStarsRequest
*/
func (a *DefaultAPIService) PostTransferBusinessAccountStars(ctx context.Context) ApiPostTransferBusinessAccountStarsRequest {
	return ApiPostTransferBusinessAccountStarsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TransferBusinessAccountStarsResponse
func (a *DefaultAPIService) PostTransferBusinessAccountStarsExecute(r ApiPostTransferBusinessAccountStarsRequest) (*TransferBusinessAccountStarsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransferBusinessAccountStarsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostTransferBusinessAccountStars")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transferBusinessAccountStars"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.starCount == nil {
		return localVarReturnValue, nil, reportError("starCount is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "star_count", r.starCount, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostTransferGiftRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	ownedGiftId *string
	newOwnerChatId *int32
	starCount *int32
}

// Unique identifier of the business connection
func (r ApiPostTransferGiftRequest) BusinessConnectionId(businessConnectionId string) ApiPostTransferGiftRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier of the regular gift that should be transferred
func (r ApiPostTransferGiftRequest) OwnedGiftId(ownedGiftId string) ApiPostTransferGiftRequest {
	r.ownedGiftId = &ownedGiftId
	return r
}

// Unique identifier of the chat which will own the gift. The chat must be active in the last 24 hours.
func (r ApiPostTransferGiftRequest) NewOwnerChatId(newOwnerChatId int32) ApiPostTransferGiftRequest {
	r.newOwnerChatId = &newOwnerChatId
	return r
}

// The amount of Telegram Stars that will be paid for the transfer from the business account balance. If positive, then the *can\\\\_transfer\\\\_stars* business bot right is required.
func (r ApiPostTransferGiftRequest) StarCount(starCount int32) ApiPostTransferGiftRequest {
	r.starCount = &starCount
	return r
}

func (r ApiPostTransferGiftRequest) Execute() (*TransferGiftResponse, *http.Response, error) {
	return r.ApiService.PostTransferGiftExecute(r)
}

/*
PostTransferGift transferGift

Transfers an owned unique gift to another user. Requires the *can\_transfer\_and\_upgrade\_gifts* business bot right. Requires *can\_transfer\_stars* business bot right if the transfer is paid. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostTransferGiftRequest
*/
func (a *DefaultAPIService) PostTransferGift(ctx context.Context) ApiPostTransferGiftRequest {
	return ApiPostTransferGiftRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TransferGiftResponse
func (a *DefaultAPIService) PostTransferGiftExecute(r ApiPostTransferGiftRequest) (*TransferGiftResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransferGiftResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostTransferGift")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transferGift"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.ownedGiftId == nil {
		return localVarReturnValue, nil, reportError("ownedGiftId is required and must be specified")
	}
	if r.newOwnerChatId == nil {
		return localVarReturnValue, nil, reportError("newOwnerChatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "owned_gift_id", r.ownedGiftId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "new_owner_chat_id", r.newOwnerChatId, "", "")
	if r.starCount != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "star_count", r.starCount, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUnbanChatMemberRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *BanChatMemberRequestChatId
	userId *int32
	onlyIfBanned *bool
}

func (r ApiPostUnbanChatMemberRequest) ChatId(chatId BanChatMemberRequestChatId) ApiPostUnbanChatMemberRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the target user
func (r ApiPostUnbanChatMemberRequest) UserId(userId int32) ApiPostUnbanChatMemberRequest {
	r.userId = &userId
	return r
}

// Do nothing if the user is not banned
func (r ApiPostUnbanChatMemberRequest) OnlyIfBanned(onlyIfBanned bool) ApiPostUnbanChatMemberRequest {
	r.onlyIfBanned = &onlyIfBanned
	return r
}

func (r ApiPostUnbanChatMemberRequest) Execute() (*UnbanChatMemberResponse, *http.Response, error) {
	return r.ApiService.PostUnbanChatMemberExecute(r)
}

/*
PostUnbanChatMember unbanChatMember

Use this method to unban a previously banned user in a supergroup or channel. The user will **not** return to the group or channel automatically, but will be able to join via link, etc. The bot must be an administrator for this to work. By default, this method guarantees that after the call the user is not a member of the chat, but will be able to join it. So if the user is a member of the chat they will also be **removed** from the chat. If you don't want this, use the parameter *only\_if\_banned*. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUnbanChatMemberRequest
*/
func (a *DefaultAPIService) PostUnbanChatMember(ctx context.Context) ApiPostUnbanChatMemberRequest {
	return ApiPostUnbanChatMemberRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UnbanChatMemberResponse
func (a *DefaultAPIService) PostUnbanChatMemberExecute(r ApiPostUnbanChatMemberRequest) (*UnbanChatMemberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UnbanChatMemberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostUnbanChatMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unbanChatMember"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	if r.onlyIfBanned != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "only_if_banned", r.onlyIfBanned, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUnbanChatSenderChatRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	senderChatId *int32
}

func (r ApiPostUnbanChatSenderChatRequest) ChatId(chatId SendMessageRequestChatId) ApiPostUnbanChatSenderChatRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the target sender chat
func (r ApiPostUnbanChatSenderChatRequest) SenderChatId(senderChatId int32) ApiPostUnbanChatSenderChatRequest {
	r.senderChatId = &senderChatId
	return r
}

func (r ApiPostUnbanChatSenderChatRequest) Execute() (*UnbanChatSenderChatResponse, *http.Response, error) {
	return r.ApiService.PostUnbanChatSenderChatExecute(r)
}

/*
PostUnbanChatSenderChat unbanChatSenderChat

Use this method to unban a previously banned channel chat in a supergroup or channel. The bot must be an administrator for this to work and must have the appropriate administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUnbanChatSenderChatRequest
*/
func (a *DefaultAPIService) PostUnbanChatSenderChat(ctx context.Context) ApiPostUnbanChatSenderChatRequest {
	return ApiPostUnbanChatSenderChatRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UnbanChatSenderChatResponse
func (a *DefaultAPIService) PostUnbanChatSenderChatExecute(r ApiPostUnbanChatSenderChatRequest) (*UnbanChatSenderChatResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UnbanChatSenderChatResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostUnbanChatSenderChat")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unbanChatSenderChat"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.senderChatId == nil {
		return localVarReturnValue, nil, reportError("senderChatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "sender_chat_id", r.senderChatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUnhideGeneralForumTopicRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *BotCommandScopeChatChatId
}

func (r ApiPostUnhideGeneralForumTopicRequest) ChatId(chatId BotCommandScopeChatChatId) ApiPostUnhideGeneralForumTopicRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostUnhideGeneralForumTopicRequest) Execute() (*UnhideGeneralForumTopicResponse, *http.Response, error) {
	return r.ApiService.PostUnhideGeneralForumTopicExecute(r)
}

/*
PostUnhideGeneralForumTopic unhideGeneralForumTopic

Use this method to unhide the 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUnhideGeneralForumTopicRequest
*/
func (a *DefaultAPIService) PostUnhideGeneralForumTopic(ctx context.Context) ApiPostUnhideGeneralForumTopicRequest {
	return ApiPostUnhideGeneralForumTopicRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UnhideGeneralForumTopicResponse
func (a *DefaultAPIService) PostUnhideGeneralForumTopicExecute(r ApiPostUnhideGeneralForumTopicRequest) (*UnhideGeneralForumTopicResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UnhideGeneralForumTopicResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostUnhideGeneralForumTopic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unhideGeneralForumTopic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUnpinAllChatMessagesRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
}

func (r ApiPostUnpinAllChatMessagesRequest) ChatId(chatId SendMessageRequestChatId) ApiPostUnpinAllChatMessagesRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostUnpinAllChatMessagesRequest) Execute() (*UnpinAllChatMessagesResponse, *http.Response, error) {
	return r.ApiService.PostUnpinAllChatMessagesExecute(r)
}

/*
PostUnpinAllChatMessages unpinAllChatMessages

Use this method to clear the list of pinned messages in a chat. If the chat is not a private chat, the bot must be an administrator in the chat for this to work and must have the 'can\_pin\_messages' administrator right in a supergroup or 'can\_edit\_messages' administrator right in a channel. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUnpinAllChatMessagesRequest
*/
func (a *DefaultAPIService) PostUnpinAllChatMessages(ctx context.Context) ApiPostUnpinAllChatMessagesRequest {
	return ApiPostUnpinAllChatMessagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UnpinAllChatMessagesResponse
func (a *DefaultAPIService) PostUnpinAllChatMessagesExecute(r ApiPostUnpinAllChatMessagesRequest) (*UnpinAllChatMessagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UnpinAllChatMessagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostUnpinAllChatMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unpinAllChatMessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUnpinAllForumTopicMessagesRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *BotCommandScopeChatChatId
	messageThreadId *int32
}

func (r ApiPostUnpinAllForumTopicMessagesRequest) ChatId(chatId BotCommandScopeChatChatId) ApiPostUnpinAllForumTopicMessagesRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier for the target message thread of the forum topic
func (r ApiPostUnpinAllForumTopicMessagesRequest) MessageThreadId(messageThreadId int32) ApiPostUnpinAllForumTopicMessagesRequest {
	r.messageThreadId = &messageThreadId
	return r
}

func (r ApiPostUnpinAllForumTopicMessagesRequest) Execute() (*UnpinAllForumTopicMessagesResponse, *http.Response, error) {
	return r.ApiService.PostUnpinAllForumTopicMessagesExecute(r)
}

/*
PostUnpinAllForumTopicMessages unpinAllForumTopicMessages

Use this method to clear the list of pinned messages in a forum topic. The bot must be an administrator in the chat for this to work and must have the *can\_pin\_messages* administrator right in the supergroup. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUnpinAllForumTopicMessagesRequest
*/
func (a *DefaultAPIService) PostUnpinAllForumTopicMessages(ctx context.Context) ApiPostUnpinAllForumTopicMessagesRequest {
	return ApiPostUnpinAllForumTopicMessagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UnpinAllForumTopicMessagesResponse
func (a *DefaultAPIService) PostUnpinAllForumTopicMessagesExecute(r ApiPostUnpinAllForumTopicMessagesRequest) (*UnpinAllForumTopicMessagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UnpinAllForumTopicMessagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostUnpinAllForumTopicMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unpinAllForumTopicMessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.messageThreadId == nil {
		return localVarReturnValue, nil, reportError("messageThreadId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUnpinAllGeneralForumTopicMessagesRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *BotCommandScopeChatChatId
}

func (r ApiPostUnpinAllGeneralForumTopicMessagesRequest) ChatId(chatId BotCommandScopeChatChatId) ApiPostUnpinAllGeneralForumTopicMessagesRequest {
	r.chatId = &chatId
	return r
}

func (r ApiPostUnpinAllGeneralForumTopicMessagesRequest) Execute() (*UnpinAllGeneralForumTopicMessagesResponse, *http.Response, error) {
	return r.ApiService.PostUnpinAllGeneralForumTopicMessagesExecute(r)
}

/*
PostUnpinAllGeneralForumTopicMessages unpinAllGeneralForumTopicMessages

Use this method to clear the list of pinned messages in a General forum topic. The bot must be an administrator in the chat for this to work and must have the *can\_pin\_messages* administrator right in the supergroup. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUnpinAllGeneralForumTopicMessagesRequest
*/
func (a *DefaultAPIService) PostUnpinAllGeneralForumTopicMessages(ctx context.Context) ApiPostUnpinAllGeneralForumTopicMessagesRequest {
	return ApiPostUnpinAllGeneralForumTopicMessagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UnpinAllGeneralForumTopicMessagesResponse
func (a *DefaultAPIService) PostUnpinAllGeneralForumTopicMessagesExecute(r ApiPostUnpinAllGeneralForumTopicMessagesRequest) (*UnpinAllGeneralForumTopicMessagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UnpinAllGeneralForumTopicMessagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostUnpinAllGeneralForumTopicMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unpinAllGeneralForumTopicMessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUnpinChatMessageRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	businessConnectionId *string
	messageId *int32
}

func (r ApiPostUnpinChatMessageRequest) ChatId(chatId SendMessageRequestChatId) ApiPostUnpinChatMessageRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the business connection on behalf of which the message will be unpinned
func (r ApiPostUnpinChatMessageRequest) BusinessConnectionId(businessConnectionId string) ApiPostUnpinChatMessageRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Identifier of the message to unpin. Required if *business\\\\_connection\\\\_id* is specified. If not specified, the most recent pinned message (by sending date) will be unpinned.
func (r ApiPostUnpinChatMessageRequest) MessageId(messageId int32) ApiPostUnpinChatMessageRequest {
	r.messageId = &messageId
	return r
}

func (r ApiPostUnpinChatMessageRequest) Execute() (*UnpinChatMessageResponse, *http.Response, error) {
	return r.ApiService.PostUnpinChatMessageExecute(r)
}

/*
PostUnpinChatMessage unpinChatMessage

Use this method to remove a message from the list of pinned messages in a chat. If the chat is not a private chat, the bot must be an administrator in the chat for this to work and must have the 'can\_pin\_messages' administrator right in a supergroup or 'can\_edit\_messages' administrator right in a channel. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUnpinChatMessageRequest
*/
func (a *DefaultAPIService) PostUnpinChatMessage(ctx context.Context) ApiPostUnpinChatMessageRequest {
	return ApiPostUnpinChatMessageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UnpinChatMessageResponse
func (a *DefaultAPIService) PostUnpinChatMessageExecute(r ApiPostUnpinChatMessageRequest) (*UnpinChatMessageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UnpinChatMessageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostUnpinChatMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unpinChatMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUpgradeGiftRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	ownedGiftId *string
	keepOriginalDetails *bool
	starCount *int32
}

// Unique identifier of the business connection
func (r ApiPostUpgradeGiftRequest) BusinessConnectionId(businessConnectionId string) ApiPostUpgradeGiftRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier of the regular gift that should be upgraded to a unique one
func (r ApiPostUpgradeGiftRequest) OwnedGiftId(ownedGiftId string) ApiPostUpgradeGiftRequest {
	r.ownedGiftId = &ownedGiftId
	return r
}

// Pass *True* to keep the original gift text, sender and receiver in the upgraded gift
func (r ApiPostUpgradeGiftRequest) KeepOriginalDetails(keepOriginalDetails bool) ApiPostUpgradeGiftRequest {
	r.keepOriginalDetails = &keepOriginalDetails
	return r
}

// The amount of Telegram Stars that will be paid for the upgrade from the business account balance. If &#x60;gift.prepaid_upgrade_star_count &gt; 0&#x60;, then pass 0, otherwise, the *can\\\\_transfer\\\\_stars* business bot right is required and &#x60;gift.upgrade_star_count&#x60; must be passed.
func (r ApiPostUpgradeGiftRequest) StarCount(starCount int32) ApiPostUpgradeGiftRequest {
	r.starCount = &starCount
	return r
}

func (r ApiPostUpgradeGiftRequest) Execute() (*UpgradeGiftResponse, *http.Response, error) {
	return r.ApiService.PostUpgradeGiftExecute(r)
}

/*
PostUpgradeGift upgradeGift

Upgrades a given regular gift to a unique gift. Requires the *can\_transfer\_and\_upgrade\_gifts* business bot right. Additionally requires the *can\_transfer\_stars* business bot right if the upgrade is paid. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUpgradeGiftRequest
*/
func (a *DefaultAPIService) PostUpgradeGift(ctx context.Context) ApiPostUpgradeGiftRequest {
	return ApiPostUpgradeGiftRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpgradeGiftResponse
func (a *DefaultAPIService) PostUpgradeGiftExecute(r ApiPostUpgradeGiftRequest) (*UpgradeGiftResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpgradeGiftResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostUpgradeGift")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/upgradeGift"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.ownedGiftId == nil {
		return localVarReturnValue, nil, reportError("ownedGiftId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "owned_gift_id", r.ownedGiftId, "", "")
	if r.keepOriginalDetails != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "keep_original_details", r.keepOriginalDetails, "", "")
	}
	if r.starCount != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "star_count", r.starCount, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUploadStickerFileRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	sticker *interface{}
	stickerFormat *string
}

// User identifier of sticker file owner
func (r ApiPostUploadStickerFileRequest) UserId(userId int32) ApiPostUploadStickerFileRequest {
	r.userId = &userId
	return r
}

func (r ApiPostUploadStickerFileRequest) Sticker(sticker interface{}) ApiPostUploadStickerFileRequest {
	r.sticker = &sticker
	return r
}

// Format of the sticker, must be one of “static”, “animated”, “video”
func (r ApiPostUploadStickerFileRequest) StickerFormat(stickerFormat string) ApiPostUploadStickerFileRequest {
	r.stickerFormat = &stickerFormat
	return r
}

func (r ApiPostUploadStickerFileRequest) Execute() (*UploadStickerFileResponse, *http.Response, error) {
	return r.ApiService.PostUploadStickerFileExecute(r)
}

/*
PostUploadStickerFile uploadStickerFile

Use this method to upload a file with a sticker for later use in the [createNewStickerSet](https://core.telegram.org/bots/api/#createnewstickerset), [addStickerToSet](https://core.telegram.org/bots/api/#addstickertoset), or [replaceStickerInSet](https://core.telegram.org/bots/api/#replacestickerinset) methods (the file can be used multiple times). Returns the uploaded [File](https://core.telegram.org/bots/api/#file) on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUploadStickerFileRequest
*/
func (a *DefaultAPIService) PostUploadStickerFile(ctx context.Context) ApiPostUploadStickerFileRequest {
	return ApiPostUploadStickerFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UploadStickerFileResponse
func (a *DefaultAPIService) PostUploadStickerFileExecute(r ApiPostUploadStickerFileRequest) (*UploadStickerFileResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UploadStickerFileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostUploadStickerFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/uploadStickerFile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.sticker == nil {
		return localVarReturnValue, nil, reportError("sticker is required and must be specified")
	}
	if r.stickerFormat == nil {
		return localVarReturnValue, nil, reportError("stickerFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "sticker", r.sticker, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "sticker_format", r.stickerFormat, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostVerifyChatRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessageRequestChatId
	customDescription *string
}

func (r ApiPostVerifyChatRequest) ChatId(chatId SendMessageRequestChatId) ApiPostVerifyChatRequest {
	r.chatId = &chatId
	return r
}

// Custom description for the verification; 0-70 characters. Must be empty if the organization isn&#39;t allowed to provide a custom verification description.
func (r ApiPostVerifyChatRequest) CustomDescription(customDescription string) ApiPostVerifyChatRequest {
	r.customDescription = &customDescription
	return r
}

func (r ApiPostVerifyChatRequest) Execute() (*VerifyChatResponse, *http.Response, error) {
	return r.ApiService.PostVerifyChatExecute(r)
}

/*
PostVerifyChat verifyChat

Verifies a chat [on behalf of the organization](https://telegram.org/verify#third-party-verification) which is represented by the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostVerifyChatRequest
*/
func (a *DefaultAPIService) PostVerifyChat(ctx context.Context) ApiPostVerifyChatRequest {
	return ApiPostVerifyChatRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VerifyChatResponse
func (a *DefaultAPIService) PostVerifyChatExecute(r ApiPostVerifyChatRequest) (*VerifyChatResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifyChatResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostVerifyChat")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verifyChat"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.customDescription != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "custom_description", r.customDescription, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostVerifyUserRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	customDescription *string
}

// Unique identifier of the target user
func (r ApiPostVerifyUserRequest) UserId(userId int32) ApiPostVerifyUserRequest {
	r.userId = &userId
	return r
}

// Custom description for the verification; 0-70 characters. Must be empty if the organization isn&#39;t allowed to provide a custom verification description.
func (r ApiPostVerifyUserRequest) CustomDescription(customDescription string) ApiPostVerifyUserRequest {
	r.customDescription = &customDescription
	return r
}

func (r ApiPostVerifyUserRequest) Execute() (*VerifyUserResponse, *http.Response, error) {
	return r.ApiService.PostVerifyUserExecute(r)
}

/*
PostVerifyUser verifyUser

Verifies a user [on behalf of the organization](https://telegram.org/verify#third-party-verification) which is represented by the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostVerifyUserRequest
*/
func (a *DefaultAPIService) PostVerifyUser(ctx context.Context) ApiPostVerifyUserRequest {
	return ApiPostVerifyUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VerifyUserResponse
func (a *DefaultAPIService) PostVerifyUserExecute(r ApiPostVerifyUserRequest) (*VerifyUserResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifyUserResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostVerifyUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verifyUser"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	if r.customDescription != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "custom_description", r.customDescription, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
