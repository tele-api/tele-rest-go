/** 
 * Telegram Bot API - REST API Client
 * The Bot API is an HTTP-based interface created for developers keen on building bots for Telegram. To learn how to create and set up a bot, please consult our Introduction to Bots and Bot FAQ.
 * 
 * ## Metadata
 *    * - **Copyright**: Copyright (c) 2025 Qntx
 *    * - **Author**: ΣX <gitctrlx@gmail.com>
 *    * - **Version**: 9.0.0
 *    * - **Modified**: 2025-07-01T14:36:13.209453861Z[Etc/UTC]
 *    * - **Generator Version**: 7.14.0
 * 
 * <details>
 * <summary><strong>⚠️ Important Disclaimer & Limitation of Liability</strong></summary>
 * <br>
 * > **IMPORTANT**: This software is provided "as is" without any warranties, express or implied, including but not limited
 * > to warranties of merchantability, fitness for a particular purpose, or non-infringement. The developers, contributors,
 * > and licensors (collectively, "Developers") make no representations regarding the accuracy, completeness, or reliability
 * > of this software or its outputs.
 * > 
 * > This client is not intended to provide financial, investment, tax, or legal advice. It facilitates interaction with the
 * > Telegram Bot API service but does not endorse or recommend any financial actions, including the purchase, sale, or holding of
 * > financial instruments (e.g., stocks, bonds, derivatives, cryptocurrencies). Users must consult qualified financial or
 * > legal professionals before making decisions based on this software's outputs.
 * > 
 * > Financial markets are inherently speculative and carry significant risks. Using this software in trading, analysis, or
 * > other financial activities may result in substantial losses, including total loss of capital. The Developers are not
 * > liable for any losses or damages arising from such use. Users assume full responsibility for validating the software's
 * > outputs and ensuring their suitability for intended purposes.
 * > 
 * > This client may rely on third-party data or services (e.g., market feeds, APIs). The Developers do not control or verify
 * > the accuracy of these services and are not liable for any errors, delays, or losses resulting from their use. Users must
 * > comply with third-party terms and conditions.
 * > 
 * > Users are solely responsible for ensuring compliance with all applicable financial, tax, and regulatory requirements in
 * > their jurisdiction. This includes obtaining necessary licenses or approvals for trading or investment activities. The
 * > Developers disclaim liability for any legal consequences arising from non-compliance.
 * > 
 * > To the fullest extent permitted by law, the Developers shall not be liable for any direct, indirect, incidental,
 * > consequential, or punitive damages arising from the use or inability to use this software, including but not limited to
 * > loss of profits, data, or business opportunities.
 * 
 * </details>
 */

package tele_rest

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


type DefaultAPI interface {

	/*
	AddStickerToSetPost Method for AddStickerToSetPost

	Use this method to add a new sticker to a set created by the bot. Emoji sticker sets can have up to 200 stickers. Other sticker sets can have up to 120 stickers. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddStickerToSetPostRequest
	*/
	AddStickerToSetPost(ctx context.Context) ApiAddStickerToSetPostRequest

	// AddStickerToSetPostExecute executes the request
	//  @return SetWebhookPost200Response
	AddStickerToSetPostExecute(r ApiAddStickerToSetPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	AnswerCallbackQueryPost Method for AnswerCallbackQueryPost

	Use this method to send answers to callback queries sent from [inline keyboards](https://core.telegram.org/bots/features#inline-keyboards). The answer will be displayed to the user as a notification at the top of the chat screen or as an alert. On success, *True* is returned.

Alternatively, the user can be redirected to the specified Game URL. For this option to work, you must first create a game for your bot via [@BotFather](https://t.me/botfather) and accept the terms. Otherwise, you may use links like `t.me/your_bot?start=XXXX` that open your bot with a parameter.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAnswerCallbackQueryPostRequest
	*/
	AnswerCallbackQueryPost(ctx context.Context) ApiAnswerCallbackQueryPostRequest

	// AnswerCallbackQueryPostExecute executes the request
	//  @return SetWebhookPost200Response
	AnswerCallbackQueryPostExecute(r ApiAnswerCallbackQueryPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	AnswerInlineQueryPost Method for AnswerInlineQueryPost

	Use this method to send answers to an inline query. On success, *True* is returned.  
No more than **50** results per query are allowed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAnswerInlineQueryPostRequest
	*/
	AnswerInlineQueryPost(ctx context.Context) ApiAnswerInlineQueryPostRequest

	// AnswerInlineQueryPostExecute executes the request
	//  @return SetWebhookPost200Response
	AnswerInlineQueryPostExecute(r ApiAnswerInlineQueryPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	AnswerPreCheckoutQueryPost Method for AnswerPreCheckoutQueryPost

	Once the user has confirmed their payment and shipping details, the Bot API sends the final confirmation in the form of an [Update](https://core.telegram.org/bots/api/#update) with the field *pre\_checkout\_query*. Use this method to respond to such pre-checkout queries. On success, *True* is returned. **Note:** The Bot API must receive an answer within 10 seconds after the pre-checkout query was sent.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAnswerPreCheckoutQueryPostRequest
	*/
	AnswerPreCheckoutQueryPost(ctx context.Context) ApiAnswerPreCheckoutQueryPostRequest

	// AnswerPreCheckoutQueryPostExecute executes the request
	//  @return SetWebhookPost200Response
	AnswerPreCheckoutQueryPostExecute(r ApiAnswerPreCheckoutQueryPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	AnswerShippingQueryPost Method for AnswerShippingQueryPost

	If you sent an invoice requesting a shipping address and the parameter *is\_flexible* was specified, the Bot API will send an [Update](https://core.telegram.org/bots/api/#update) with a *shipping\_query* field to the bot. Use this method to reply to shipping queries. On success, *True* is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAnswerShippingQueryPostRequest
	*/
	AnswerShippingQueryPost(ctx context.Context) ApiAnswerShippingQueryPostRequest

	// AnswerShippingQueryPostExecute executes the request
	//  @return SetWebhookPost200Response
	AnswerShippingQueryPostExecute(r ApiAnswerShippingQueryPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	AnswerWebAppQueryPost Method for AnswerWebAppQueryPost

	Use this method to set the result of an interaction with a [Web App](https://core.telegram.org/bots/webapps) and send a corresponding message on behalf of the user to the chat from which the query originated. On success, a [SentWebAppMessage](https://core.telegram.org/bots/api/#sentwebappmessage) object is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAnswerWebAppQueryPostRequest
	*/
	AnswerWebAppQueryPost(ctx context.Context) ApiAnswerWebAppQueryPostRequest

	// AnswerWebAppQueryPostExecute executes the request
	//  @return AnswerWebAppQueryPost200Response
	AnswerWebAppQueryPostExecute(r ApiAnswerWebAppQueryPostRequest) (*AnswerWebAppQueryPost200Response, *http.Response, error)

	/*
	ApproveChatJoinRequestPost Method for ApproveChatJoinRequestPost

	Use this method to approve a chat join request. The bot must be an administrator in the chat for this to work and must have the *can\_invite\_users* administrator right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApproveChatJoinRequestPostRequest
	*/
	ApproveChatJoinRequestPost(ctx context.Context) ApiApproveChatJoinRequestPostRequest

	// ApproveChatJoinRequestPostExecute executes the request
	//  @return SetWebhookPost200Response
	ApproveChatJoinRequestPostExecute(r ApiApproveChatJoinRequestPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	BanChatMemberPost Method for BanChatMemberPost

	Use this method to ban a user in a group, a supergroup or a channel. In the case of supergroups and channels, the user will not be able to return to the chat on their own using invite links, etc., unless [unbanned](https://core.telegram.org/bots/api/#unbanchatmember) first. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiBanChatMemberPostRequest
	*/
	BanChatMemberPost(ctx context.Context) ApiBanChatMemberPostRequest

	// BanChatMemberPostExecute executes the request
	//  @return SetWebhookPost200Response
	BanChatMemberPostExecute(r ApiBanChatMemberPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	BanChatSenderChatPost Method for BanChatSenderChatPost

	Use this method to ban a channel chat in a supergroup or a channel. Until the chat is [unbanned](https://core.telegram.org/bots/api/#unbanchatsenderchat), the owner of the banned chat won't be able to send messages on behalf of **any of their channels**. The bot must be an administrator in the supergroup or channel for this to work and must have the appropriate administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiBanChatSenderChatPostRequest
	*/
	BanChatSenderChatPost(ctx context.Context) ApiBanChatSenderChatPostRequest

	// BanChatSenderChatPostExecute executes the request
	//  @return SetWebhookPost200Response
	BanChatSenderChatPostExecute(r ApiBanChatSenderChatPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	CloseForumTopicPost Method for CloseForumTopicPost

	Use this method to close an open topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights, unless it is the creator of the topic. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCloseForumTopicPostRequest
	*/
	CloseForumTopicPost(ctx context.Context) ApiCloseForumTopicPostRequest

	// CloseForumTopicPostExecute executes the request
	//  @return SetWebhookPost200Response
	CloseForumTopicPostExecute(r ApiCloseForumTopicPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	CloseGeneralForumTopicPost Method for CloseGeneralForumTopicPost

	Use this method to close an open 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCloseGeneralForumTopicPostRequest
	*/
	CloseGeneralForumTopicPost(ctx context.Context) ApiCloseGeneralForumTopicPostRequest

	// CloseGeneralForumTopicPostExecute executes the request
	//  @return SetWebhookPost200Response
	CloseGeneralForumTopicPostExecute(r ApiCloseGeneralForumTopicPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	ClosePost Method for ClosePost

	Use this method to close the bot instance before moving it from one local server to another. You need to delete the webhook before calling this method to ensure that the bot isn't launched again after server restart. The method will return error 429 in the first 10 minutes after the bot is launched. Returns *True* on success. Requires no parameters.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiClosePostRequest
	*/
	ClosePost(ctx context.Context) ApiClosePostRequest

	// ClosePostExecute executes the request
	//  @return SetWebhookPost200Response
	ClosePostExecute(r ApiClosePostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	ConvertGiftToStarsPost Method for ConvertGiftToStarsPost

	Converts a given regular gift to Telegram Stars. Requires the *can\_convert\_gifts\_to\_stars* business bot right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiConvertGiftToStarsPostRequest
	*/
	ConvertGiftToStarsPost(ctx context.Context) ApiConvertGiftToStarsPostRequest

	// ConvertGiftToStarsPostExecute executes the request
	//  @return SetWebhookPost200Response
	ConvertGiftToStarsPostExecute(r ApiConvertGiftToStarsPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	CopyMessagePost Method for CopyMessagePost

	Use this method to copy messages of any kind. Service messages, paid media messages, giveaway messages, giveaway winners messages, and invoice messages can't be copied. A quiz [poll](https://core.telegram.org/bots/api/#poll) can be copied only if the value of the field *correct\_option\_id* is known to the bot. The method is analogous to the method [forwardMessage](https://core.telegram.org/bots/api/#forwardmessage), but the copied message doesn't have a link to the original message. Returns the [MessageId](https://core.telegram.org/bots/api/#messageid) of the sent message on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCopyMessagePostRequest
	*/
	CopyMessagePost(ctx context.Context) ApiCopyMessagePostRequest

	// CopyMessagePostExecute executes the request
	//  @return CopyMessagePost200Response
	CopyMessagePostExecute(r ApiCopyMessagePostRequest) (*CopyMessagePost200Response, *http.Response, error)

	/*
	CopyMessagesPost Method for CopyMessagesPost

	Use this method to copy messages of any kind. If some of the specified messages can't be found or copied, they are skipped. Service messages, paid media messages, giveaway messages, giveaway winners messages, and invoice messages can't be copied. A quiz [poll](https://core.telegram.org/bots/api/#poll) can be copied only if the value of the field *correct\_option\_id* is known to the bot. The method is analogous to the method [forwardMessages](https://core.telegram.org/bots/api/#forwardmessages), but the copied messages don't have a link to the original message. Album grouping is kept for copied messages. On success, an array of [MessageId](https://core.telegram.org/bots/api/#messageid) of the sent messages is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCopyMessagesPostRequest
	*/
	CopyMessagesPost(ctx context.Context) ApiCopyMessagesPostRequest

	// CopyMessagesPostExecute executes the request
	//  @return ForwardMessagesPost200Response
	CopyMessagesPostExecute(r ApiCopyMessagesPostRequest) (*ForwardMessagesPost200Response, *http.Response, error)

	/*
	CreateChatInviteLinkPost Method for CreateChatInviteLinkPost

	Use this method to create an additional invite link for a chat. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. The link can be revoked using the method [revokeChatInviteLink](https://core.telegram.org/bots/api/#revokechatinvitelink). Returns the new invite link as [ChatInviteLink](https://core.telegram.org/bots/api/#chatinvitelink) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateChatInviteLinkPostRequest
	*/
	CreateChatInviteLinkPost(ctx context.Context) ApiCreateChatInviteLinkPostRequest

	// CreateChatInviteLinkPostExecute executes the request
	//  @return CreateChatInviteLinkPost200Response
	CreateChatInviteLinkPostExecute(r ApiCreateChatInviteLinkPostRequest) (*CreateChatInviteLinkPost200Response, *http.Response, error)

	/*
	CreateChatSubscriptionInviteLinkPost Method for CreateChatSubscriptionInviteLinkPost

	Use this method to create a [subscription invite link](https://telegram.org/blog/superchannels-star-reactions-subscriptions#star-subscriptions) for a channel chat. The bot must have the *can\_invite\_users* administrator rights. The link can be edited using the method [editChatSubscriptionInviteLink](https://core.telegram.org/bots/api/#editchatsubscriptioninvitelink) or revoked using the method [revokeChatInviteLink](https://core.telegram.org/bots/api/#revokechatinvitelink). Returns the new invite link as a [ChatInviteLink](https://core.telegram.org/bots/api/#chatinvitelink) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateChatSubscriptionInviteLinkPostRequest
	*/
	CreateChatSubscriptionInviteLinkPost(ctx context.Context) ApiCreateChatSubscriptionInviteLinkPostRequest

	// CreateChatSubscriptionInviteLinkPostExecute executes the request
	//  @return CreateChatInviteLinkPost200Response
	CreateChatSubscriptionInviteLinkPostExecute(r ApiCreateChatSubscriptionInviteLinkPostRequest) (*CreateChatInviteLinkPost200Response, *http.Response, error)

	/*
	CreateForumTopicPost Method for CreateForumTopicPost

	Use this method to create a topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. Returns information about the created topic as a [ForumTopic](https://core.telegram.org/bots/api/#forumtopic) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateForumTopicPostRequest
	*/
	CreateForumTopicPost(ctx context.Context) ApiCreateForumTopicPostRequest

	// CreateForumTopicPostExecute executes the request
	//  @return CreateForumTopicPost200Response
	CreateForumTopicPostExecute(r ApiCreateForumTopicPostRequest) (*CreateForumTopicPost200Response, *http.Response, error)

	/*
	CreateInvoiceLinkPost Method for CreateInvoiceLinkPost

	Use this method to create a link for an invoice. Returns the created invoice link as *String* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateInvoiceLinkPostRequest
	*/
	CreateInvoiceLinkPost(ctx context.Context) ApiCreateInvoiceLinkPostRequest

	// CreateInvoiceLinkPostExecute executes the request
	//  @return ExportChatInviteLinkPost200Response
	CreateInvoiceLinkPostExecute(r ApiCreateInvoiceLinkPostRequest) (*ExportChatInviteLinkPost200Response, *http.Response, error)

	/*
	CreateNewStickerSetPost Method for CreateNewStickerSetPost

	Use this method to create a new sticker set owned by a user. The bot will be able to edit the sticker set thus created. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateNewStickerSetPostRequest
	*/
	CreateNewStickerSetPost(ctx context.Context) ApiCreateNewStickerSetPostRequest

	// CreateNewStickerSetPostExecute executes the request
	//  @return SetWebhookPost200Response
	CreateNewStickerSetPostExecute(r ApiCreateNewStickerSetPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	DeclineChatJoinRequestPost Method for DeclineChatJoinRequestPost

	Use this method to decline a chat join request. The bot must be an administrator in the chat for this to work and must have the *can\_invite\_users* administrator right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeclineChatJoinRequestPostRequest
	*/
	DeclineChatJoinRequestPost(ctx context.Context) ApiDeclineChatJoinRequestPostRequest

	// DeclineChatJoinRequestPostExecute executes the request
	//  @return SetWebhookPost200Response
	DeclineChatJoinRequestPostExecute(r ApiDeclineChatJoinRequestPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	DeleteBusinessMessagesPost Method for DeleteBusinessMessagesPost

	Delete messages on behalf of a business account. Requires the *can\_delete\_sent\_messages* business bot right to delete messages sent by the bot itself, or the *can\_delete\_all\_messages* business bot right to delete any message. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteBusinessMessagesPostRequest
	*/
	DeleteBusinessMessagesPost(ctx context.Context) ApiDeleteBusinessMessagesPostRequest

	// DeleteBusinessMessagesPostExecute executes the request
	//  @return SetWebhookPost200Response
	DeleteBusinessMessagesPostExecute(r ApiDeleteBusinessMessagesPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	DeleteChatPhotoPost Method for DeleteChatPhotoPost

	Use this method to delete a chat photo. Photos can't be changed for private chats. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteChatPhotoPostRequest
	*/
	DeleteChatPhotoPost(ctx context.Context) ApiDeleteChatPhotoPostRequest

	// DeleteChatPhotoPostExecute executes the request
	//  @return SetWebhookPost200Response
	DeleteChatPhotoPostExecute(r ApiDeleteChatPhotoPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	DeleteChatStickerSetPost Method for DeleteChatStickerSetPost

	Use this method to delete a group sticker set from a supergroup. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Use the field *can\_set\_sticker\_set* optionally returned in [getChat](https://core.telegram.org/bots/api/#getchat) requests to check if the bot can use this method. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteChatStickerSetPostRequest
	*/
	DeleteChatStickerSetPost(ctx context.Context) ApiDeleteChatStickerSetPostRequest

	// DeleteChatStickerSetPostExecute executes the request
	//  @return SetWebhookPost200Response
	DeleteChatStickerSetPostExecute(r ApiDeleteChatStickerSetPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	DeleteForumTopicPost Method for DeleteForumTopicPost

	Use this method to delete a forum topic along with all its messages in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_delete\_messages* administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteForumTopicPostRequest
	*/
	DeleteForumTopicPost(ctx context.Context) ApiDeleteForumTopicPostRequest

	// DeleteForumTopicPostExecute executes the request
	//  @return SetWebhookPost200Response
	DeleteForumTopicPostExecute(r ApiDeleteForumTopicPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	DeleteMessagePost Method for DeleteMessagePost

	Use this method to delete a message, including service messages, with the following limitations:  
\- A message can only be deleted if it was sent less than 48 hours ago.  
\- Service messages about a supergroup, channel, or forum topic creation can't be deleted.  
\- A dice message in a private chat can only be deleted if it was sent more than 24 hours ago.  
\- Bots can delete outgoing messages in private chats, groups, and supergroups.  
\- Bots can delete incoming messages in private chats.  
\- Bots granted *can\_post\_messages* permissions can delete outgoing messages in channels.  
\- If the bot is an administrator of a group, it can delete any message there.  
\- If the bot has *can\_delete\_messages* permission in a supergroup or a channel, it can delete any message there.  
Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteMessagePostRequest
	*/
	DeleteMessagePost(ctx context.Context) ApiDeleteMessagePostRequest

	// DeleteMessagePostExecute executes the request
	//  @return SetWebhookPost200Response
	DeleteMessagePostExecute(r ApiDeleteMessagePostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	DeleteMessagesPost Method for DeleteMessagesPost

	Use this method to delete multiple messages simultaneously. If some of the specified messages can't be found, they are skipped. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteMessagesPostRequest
	*/
	DeleteMessagesPost(ctx context.Context) ApiDeleteMessagesPostRequest

	// DeleteMessagesPostExecute executes the request
	//  @return SetWebhookPost200Response
	DeleteMessagesPostExecute(r ApiDeleteMessagesPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	DeleteMyCommandsPost Method for DeleteMyCommandsPost

	Use this method to delete the list of the bot's commands for the given scope and user language. After deletion, [higher level commands](https://core.telegram.org/bots/api/#determining-list-of-commands) will be shown to affected users. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteMyCommandsPostRequest
	*/
	DeleteMyCommandsPost(ctx context.Context) ApiDeleteMyCommandsPostRequest

	// DeleteMyCommandsPostExecute executes the request
	//  @return SetWebhookPost200Response
	DeleteMyCommandsPostExecute(r ApiDeleteMyCommandsPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	DeleteStickerFromSetPost Method for DeleteStickerFromSetPost

	Use this method to delete a sticker from a set created by the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteStickerFromSetPostRequest
	*/
	DeleteStickerFromSetPost(ctx context.Context) ApiDeleteStickerFromSetPostRequest

	// DeleteStickerFromSetPostExecute executes the request
	//  @return SetWebhookPost200Response
	DeleteStickerFromSetPostExecute(r ApiDeleteStickerFromSetPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	DeleteStickerSetPost Method for DeleteStickerSetPost

	Use this method to delete a sticker set that was created by the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteStickerSetPostRequest
	*/
	DeleteStickerSetPost(ctx context.Context) ApiDeleteStickerSetPostRequest

	// DeleteStickerSetPostExecute executes the request
	//  @return SetWebhookPost200Response
	DeleteStickerSetPostExecute(r ApiDeleteStickerSetPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	DeleteStoryPost Method for DeleteStoryPost

	Deletes a story previously posted by the bot on behalf of a managed business account. Requires the *can\_manage\_stories* business bot right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteStoryPostRequest
	*/
	DeleteStoryPost(ctx context.Context) ApiDeleteStoryPostRequest

	// DeleteStoryPostExecute executes the request
	//  @return SetWebhookPost200Response
	DeleteStoryPostExecute(r ApiDeleteStoryPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	DeleteWebhookPost Method for DeleteWebhookPost

	Use this method to remove webhook integration if you decide to switch back to [getUpdates](https://core.telegram.org/bots/api/#getupdates). Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteWebhookPostRequest
	*/
	DeleteWebhookPost(ctx context.Context) ApiDeleteWebhookPostRequest

	// DeleteWebhookPostExecute executes the request
	//  @return SetWebhookPost200Response
	DeleteWebhookPostExecute(r ApiDeleteWebhookPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	EditChatInviteLinkPost Method for EditChatInviteLinkPost

	Use this method to edit a non-primary invite link created by the bot. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns the edited invite link as a [ChatInviteLink](https://core.telegram.org/bots/api/#chatinvitelink) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEditChatInviteLinkPostRequest
	*/
	EditChatInviteLinkPost(ctx context.Context) ApiEditChatInviteLinkPostRequest

	// EditChatInviteLinkPostExecute executes the request
	//  @return CreateChatInviteLinkPost200Response
	EditChatInviteLinkPostExecute(r ApiEditChatInviteLinkPostRequest) (*CreateChatInviteLinkPost200Response, *http.Response, error)

	/*
	EditChatSubscriptionInviteLinkPost Method for EditChatSubscriptionInviteLinkPost

	Use this method to edit a subscription invite link created by the bot. The bot must have the *can\_invite\_users* administrator rights. Returns the edited invite link as a [ChatInviteLink](https://core.telegram.org/bots/api/#chatinvitelink) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEditChatSubscriptionInviteLinkPostRequest
	*/
	EditChatSubscriptionInviteLinkPost(ctx context.Context) ApiEditChatSubscriptionInviteLinkPostRequest

	// EditChatSubscriptionInviteLinkPostExecute executes the request
	//  @return CreateChatInviteLinkPost200Response
	EditChatSubscriptionInviteLinkPostExecute(r ApiEditChatSubscriptionInviteLinkPostRequest) (*CreateChatInviteLinkPost200Response, *http.Response, error)

	/*
	EditForumTopicPost Method for EditForumTopicPost

	Use this method to edit name and icon of a topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights, unless it is the creator of the topic. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEditForumTopicPostRequest
	*/
	EditForumTopicPost(ctx context.Context) ApiEditForumTopicPostRequest

	// EditForumTopicPostExecute executes the request
	//  @return SetWebhookPost200Response
	EditForumTopicPostExecute(r ApiEditForumTopicPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	EditGeneralForumTopicPost Method for EditGeneralForumTopicPost

	Use this method to edit the name of the 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEditGeneralForumTopicPostRequest
	*/
	EditGeneralForumTopicPost(ctx context.Context) ApiEditGeneralForumTopicPostRequest

	// EditGeneralForumTopicPostExecute executes the request
	//  @return SetWebhookPost200Response
	EditGeneralForumTopicPostExecute(r ApiEditGeneralForumTopicPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	EditMessageCaptionPost Method for EditMessageCaptionPost

	Use this method to edit captions of messages. On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned. Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within **48 hours** from the time they were sent.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEditMessageCaptionPostRequest
	*/
	EditMessageCaptionPost(ctx context.Context) ApiEditMessageCaptionPostRequest

	// EditMessageCaptionPostExecute executes the request
	//  @return EditMessageTextPost200Response
	EditMessageCaptionPostExecute(r ApiEditMessageCaptionPostRequest) (*EditMessageTextPost200Response, *http.Response, error)

	/*
	EditMessageLiveLocationPost Method for EditMessageLiveLocationPost

	Use this method to edit live location messages. A location can be edited until its *live\_period* expires or editing is explicitly disabled by a call to [stopMessageLiveLocation](https://core.telegram.org/bots/api/#stopmessagelivelocation). On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEditMessageLiveLocationPostRequest
	*/
	EditMessageLiveLocationPost(ctx context.Context) ApiEditMessageLiveLocationPostRequest

	// EditMessageLiveLocationPostExecute executes the request
	//  @return EditMessageTextPost200Response
	EditMessageLiveLocationPostExecute(r ApiEditMessageLiveLocationPostRequest) (*EditMessageTextPost200Response, *http.Response, error)

	/*
	EditMessageMediaPost Method for EditMessageMediaPost

	Use this method to edit animation, audio, document, photo, or video messages, or to add media to text messages. If a message is part of a message album, then it can be edited only to an audio for audio albums, only to a document for document albums and to a photo or a video otherwise. When an inline message is edited, a new file can't be uploaded; use a previously uploaded file via its file\_id or specify a URL. On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned. Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within **48 hours** from the time they were sent.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEditMessageMediaPostRequest
	*/
	EditMessageMediaPost(ctx context.Context) ApiEditMessageMediaPostRequest

	// EditMessageMediaPostExecute executes the request
	//  @return EditMessageTextPost200Response
	EditMessageMediaPostExecute(r ApiEditMessageMediaPostRequest) (*EditMessageTextPost200Response, *http.Response, error)

	/*
	EditMessageReplyMarkupPost Method for EditMessageReplyMarkupPost

	Use this method to edit only the reply markup of messages. On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned. Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within **48 hours** from the time they were sent.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEditMessageReplyMarkupPostRequest
	*/
	EditMessageReplyMarkupPost(ctx context.Context) ApiEditMessageReplyMarkupPostRequest

	// EditMessageReplyMarkupPostExecute executes the request
	//  @return EditMessageTextPost200Response
	EditMessageReplyMarkupPostExecute(r ApiEditMessageReplyMarkupPostRequest) (*EditMessageTextPost200Response, *http.Response, error)

	/*
	EditMessageTextPost Method for EditMessageTextPost

	Use this method to edit text and [game](https://core.telegram.org/bots/api/#games) messages. On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned. Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within **48 hours** from the time they were sent.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEditMessageTextPostRequest
	*/
	EditMessageTextPost(ctx context.Context) ApiEditMessageTextPostRequest

	// EditMessageTextPostExecute executes the request
	//  @return EditMessageTextPost200Response
	EditMessageTextPostExecute(r ApiEditMessageTextPostRequest) (*EditMessageTextPost200Response, *http.Response, error)

	/*
	EditStoryPost Method for EditStoryPost

	Edits a story previously posted by the bot on behalf of a managed business account. Requires the *can\_manage\_stories* business bot right. Returns [Story](https://core.telegram.org/bots/api/#story) on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEditStoryPostRequest
	*/
	EditStoryPost(ctx context.Context) ApiEditStoryPostRequest

	// EditStoryPostExecute executes the request
	//  @return PostStoryPost200Response
	EditStoryPostExecute(r ApiEditStoryPostRequest) (*PostStoryPost200Response, *http.Response, error)

	/*
	EditUserStarSubscriptionPost Method for EditUserStarSubscriptionPost

	Allows the bot to cancel or re-enable extension of a subscription paid in Telegram Stars. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEditUserStarSubscriptionPostRequest
	*/
	EditUserStarSubscriptionPost(ctx context.Context) ApiEditUserStarSubscriptionPostRequest

	// EditUserStarSubscriptionPostExecute executes the request
	//  @return SetWebhookPost200Response
	EditUserStarSubscriptionPostExecute(r ApiEditUserStarSubscriptionPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	ExportChatInviteLinkPost Method for ExportChatInviteLinkPost

	Use this method to generate a new primary invite link for a chat; any previously generated primary link is revoked. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns the new invite link as *String* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiExportChatInviteLinkPostRequest
	*/
	ExportChatInviteLinkPost(ctx context.Context) ApiExportChatInviteLinkPostRequest

	// ExportChatInviteLinkPostExecute executes the request
	//  @return ExportChatInviteLinkPost200Response
	ExportChatInviteLinkPostExecute(r ApiExportChatInviteLinkPostRequest) (*ExportChatInviteLinkPost200Response, *http.Response, error)

	/*
	ForwardMessagePost Method for ForwardMessagePost

	Use this method to forward messages of any kind. Service messages and messages with protected content can't be forwarded. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiForwardMessagePostRequest
	*/
	ForwardMessagePost(ctx context.Context) ApiForwardMessagePostRequest

	// ForwardMessagePostExecute executes the request
	//  @return SendMessagePost200Response
	ForwardMessagePostExecute(r ApiForwardMessagePostRequest) (*SendMessagePost200Response, *http.Response, error)

	/*
	ForwardMessagesPost Method for ForwardMessagesPost

	Use this method to forward multiple messages of any kind. If some of the specified messages can't be found or forwarded, they are skipped. Service messages and messages with protected content can't be forwarded. Album grouping is kept for forwarded messages. On success, an array of [MessageId](https://core.telegram.org/bots/api/#messageid) of the sent messages is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiForwardMessagesPostRequest
	*/
	ForwardMessagesPost(ctx context.Context) ApiForwardMessagesPostRequest

	// ForwardMessagesPostExecute executes the request
	//  @return ForwardMessagesPost200Response
	ForwardMessagesPostExecute(r ApiForwardMessagesPostRequest) (*ForwardMessagesPost200Response, *http.Response, error)

	/*
	GetAvailableGiftsPost Method for GetAvailableGiftsPost

	Returns the list of gifts that can be sent by the bot to users and channel chats. Requires no parameters. Returns a [Gifts](https://core.telegram.org/bots/api/#gifts) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAvailableGiftsPostRequest
	*/
	GetAvailableGiftsPost(ctx context.Context) ApiGetAvailableGiftsPostRequest

	// GetAvailableGiftsPostExecute executes the request
	//  @return GetAvailableGiftsPost200Response
	GetAvailableGiftsPostExecute(r ApiGetAvailableGiftsPostRequest) (*GetAvailableGiftsPost200Response, *http.Response, error)

	/*
	GetBusinessAccountGiftsPost Method for GetBusinessAccountGiftsPost

	Returns the gifts received and owned by a managed business account. Requires the *can\_view\_gifts\_and\_stars* business bot right. Returns [OwnedGifts](https://core.telegram.org/bots/api/#ownedgifts) on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetBusinessAccountGiftsPostRequest
	*/
	GetBusinessAccountGiftsPost(ctx context.Context) ApiGetBusinessAccountGiftsPostRequest

	// GetBusinessAccountGiftsPostExecute executes the request
	//  @return GetBusinessAccountGiftsPost200Response
	GetBusinessAccountGiftsPostExecute(r ApiGetBusinessAccountGiftsPostRequest) (*GetBusinessAccountGiftsPost200Response, *http.Response, error)

	/*
	GetBusinessAccountStarBalancePost Method for GetBusinessAccountStarBalancePost

	Returns the amount of Telegram Stars owned by a managed business account. Requires the *can\_view\_gifts\_and\_stars* business bot right. Returns [StarAmount](https://core.telegram.org/bots/api/#staramount) on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetBusinessAccountStarBalancePostRequest
	*/
	GetBusinessAccountStarBalancePost(ctx context.Context) ApiGetBusinessAccountStarBalancePostRequest

	// GetBusinessAccountStarBalancePostExecute executes the request
	//  @return GetBusinessAccountStarBalancePost200Response
	GetBusinessAccountStarBalancePostExecute(r ApiGetBusinessAccountStarBalancePostRequest) (*GetBusinessAccountStarBalancePost200Response, *http.Response, error)

	/*
	GetBusinessConnectionPost Method for GetBusinessConnectionPost

	Use this method to get information about the connection of the bot with a business account. Returns a [BusinessConnection](https://core.telegram.org/bots/api/#businessconnection) object on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetBusinessConnectionPostRequest
	*/
	GetBusinessConnectionPost(ctx context.Context) ApiGetBusinessConnectionPostRequest

	// GetBusinessConnectionPostExecute executes the request
	//  @return GetBusinessConnectionPost200Response
	GetBusinessConnectionPostExecute(r ApiGetBusinessConnectionPostRequest) (*GetBusinessConnectionPost200Response, *http.Response, error)

	/*
	GetChatAdministratorsPost Method for GetChatAdministratorsPost

	Use this method to get a list of administrators in a chat, which aren't bots. Returns an Array of [ChatMember](https://core.telegram.org/bots/api/#chatmember) objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetChatAdministratorsPostRequest
	*/
	GetChatAdministratorsPost(ctx context.Context) ApiGetChatAdministratorsPostRequest

	// GetChatAdministratorsPostExecute executes the request
	//  @return GetChatAdministratorsPost200Response
	GetChatAdministratorsPostExecute(r ApiGetChatAdministratorsPostRequest) (*GetChatAdministratorsPost200Response, *http.Response, error)

	/*
	GetChatMemberCountPost Method for GetChatMemberCountPost

	Use this method to get the number of members in a chat. Returns *Int* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetChatMemberCountPostRequest
	*/
	GetChatMemberCountPost(ctx context.Context) ApiGetChatMemberCountPostRequest

	// GetChatMemberCountPostExecute executes the request
	//  @return GetChatMemberCountPost200Response
	GetChatMemberCountPostExecute(r ApiGetChatMemberCountPostRequest) (*GetChatMemberCountPost200Response, *http.Response, error)

	/*
	GetChatMemberPost Method for GetChatMemberPost

	Use this method to get information about a member of a chat. The method is only guaranteed to work for other users if the bot is an administrator in the chat. Returns a [ChatMember](https://core.telegram.org/bots/api/#chatmember) object on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetChatMemberPostRequest
	*/
	GetChatMemberPost(ctx context.Context) ApiGetChatMemberPostRequest

	// GetChatMemberPostExecute executes the request
	//  @return GetChatMemberPost200Response
	GetChatMemberPostExecute(r ApiGetChatMemberPostRequest) (*GetChatMemberPost200Response, *http.Response, error)

	/*
	GetChatMenuButtonPost Method for GetChatMenuButtonPost

	Use this method to get the current value of the bot's menu button in a private chat, or the default menu button. Returns [MenuButton](https://core.telegram.org/bots/api/#menubutton) on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetChatMenuButtonPostRequest
	*/
	GetChatMenuButtonPost(ctx context.Context) ApiGetChatMenuButtonPostRequest

	// GetChatMenuButtonPostExecute executes the request
	//  @return GetChatMenuButtonPost200Response
	GetChatMenuButtonPostExecute(r ApiGetChatMenuButtonPostRequest) (*GetChatMenuButtonPost200Response, *http.Response, error)

	/*
	GetChatPost Method for GetChatPost

	Use this method to get up-to-date information about the chat. Returns a [ChatFullInfo](https://core.telegram.org/bots/api/#chatfullinfo) object on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetChatPostRequest
	*/
	GetChatPost(ctx context.Context) ApiGetChatPostRequest

	// GetChatPostExecute executes the request
	//  @return GetChatPost200Response
	GetChatPostExecute(r ApiGetChatPostRequest) (*GetChatPost200Response, *http.Response, error)

	/*
	GetCustomEmojiStickersPost Method for GetCustomEmojiStickersPost

	Use this method to get information about custom emoji stickers by their identifiers. Returns an Array of [Sticker](https://core.telegram.org/bots/api/#sticker) objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetCustomEmojiStickersPostRequest
	*/
	GetCustomEmojiStickersPost(ctx context.Context) ApiGetCustomEmojiStickersPostRequest

	// GetCustomEmojiStickersPostExecute executes the request
	//  @return GetForumTopicIconStickersPost200Response
	GetCustomEmojiStickersPostExecute(r ApiGetCustomEmojiStickersPostRequest) (*GetForumTopicIconStickersPost200Response, *http.Response, error)

	/*
	GetFilePost Method for GetFilePost

	Use this method to get basic information about a file and prepare it for downloading. For the moment, bots can download files of up to 20MB in size. On success, a [File](https://core.telegram.org/bots/api/#file) object is returned. The file can then be downloaded via the link `https://api.telegram.org/file/bot<token>/<file_path>`, where `<file_path>` is taken from the response. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling [getFile](https://core.telegram.org/bots/api/#getfile) again.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetFilePostRequest
	*/
	GetFilePost(ctx context.Context) ApiGetFilePostRequest

	// GetFilePostExecute executes the request
	//  @return GetFilePost200Response
	GetFilePostExecute(r ApiGetFilePostRequest) (*GetFilePost200Response, *http.Response, error)

	/*
	GetForumTopicIconStickersPost Method for GetForumTopicIconStickersPost

	Use this method to get custom emoji stickers, which can be used as a forum topic icon by any user. Requires no parameters. Returns an Array of [Sticker](https://core.telegram.org/bots/api/#sticker) objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetForumTopicIconStickersPostRequest
	*/
	GetForumTopicIconStickersPost(ctx context.Context) ApiGetForumTopicIconStickersPostRequest

	// GetForumTopicIconStickersPostExecute executes the request
	//  @return GetForumTopicIconStickersPost200Response
	GetForumTopicIconStickersPostExecute(r ApiGetForumTopicIconStickersPostRequest) (*GetForumTopicIconStickersPost200Response, *http.Response, error)

	/*
	GetGameHighScoresPost Method for GetGameHighScoresPost

	Use this method to get data for high score tables. Will return the score of the specified user and several of their neighbors in a game. Returns an Array of [GameHighScore](https://core.telegram.org/bots/api/#gamehighscore) objects.

This method will currently return scores for the target user, plus two of their closest neighbors on each side. Will also return the top three users if the user and their neighbors are not among them. Please note that this behavior is subject to change.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetGameHighScoresPostRequest
	*/
	GetGameHighScoresPost(ctx context.Context) ApiGetGameHighScoresPostRequest

	// GetGameHighScoresPostExecute executes the request
	//  @return GetGameHighScoresPost200Response
	GetGameHighScoresPostExecute(r ApiGetGameHighScoresPostRequest) (*GetGameHighScoresPost200Response, *http.Response, error)

	/*
	GetMePost Method for GetMePost

	A simple method for testing your bot's authentication token. Requires no parameters. Returns basic information about the bot in form of a [User](https://core.telegram.org/bots/api/#user) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetMePostRequest
	*/
	GetMePost(ctx context.Context) ApiGetMePostRequest

	// GetMePostExecute executes the request
	//  @return GetMePost200Response
	GetMePostExecute(r ApiGetMePostRequest) (*GetMePost200Response, *http.Response, error)

	/*
	GetMyCommandsPost Method for GetMyCommandsPost

	Use this method to get the current list of the bot's commands for the given scope and user language. Returns an Array of [BotCommand](https://core.telegram.org/bots/api/#botcommand) objects. If commands aren't set, an empty list is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetMyCommandsPostRequest
	*/
	GetMyCommandsPost(ctx context.Context) ApiGetMyCommandsPostRequest

	// GetMyCommandsPostExecute executes the request
	//  @return GetMyCommandsPost200Response
	GetMyCommandsPostExecute(r ApiGetMyCommandsPostRequest) (*GetMyCommandsPost200Response, *http.Response, error)

	/*
	GetMyDefaultAdministratorRightsPost Method for GetMyDefaultAdministratorRightsPost

	Use this method to get the current default administrator rights of the bot. Returns [ChatAdministratorRights](https://core.telegram.org/bots/api/#chatadministratorrights) on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetMyDefaultAdministratorRightsPostRequest
	*/
	GetMyDefaultAdministratorRightsPost(ctx context.Context) ApiGetMyDefaultAdministratorRightsPostRequest

	// GetMyDefaultAdministratorRightsPostExecute executes the request
	//  @return GetMyDefaultAdministratorRightsPost200Response
	GetMyDefaultAdministratorRightsPostExecute(r ApiGetMyDefaultAdministratorRightsPostRequest) (*GetMyDefaultAdministratorRightsPost200Response, *http.Response, error)

	/*
	GetMyDescriptionPost Method for GetMyDescriptionPost

	Use this method to get the current bot description for the given user language. Returns [BotDescription](https://core.telegram.org/bots/api/#botdescription) on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetMyDescriptionPostRequest
	*/
	GetMyDescriptionPost(ctx context.Context) ApiGetMyDescriptionPostRequest

	// GetMyDescriptionPostExecute executes the request
	//  @return GetMyDescriptionPost200Response
	GetMyDescriptionPostExecute(r ApiGetMyDescriptionPostRequest) (*GetMyDescriptionPost200Response, *http.Response, error)

	/*
	GetMyNamePost Method for GetMyNamePost

	Use this method to get the current bot name for the given user language. Returns [BotName](https://core.telegram.org/bots/api/#botname) on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetMyNamePostRequest
	*/
	GetMyNamePost(ctx context.Context) ApiGetMyNamePostRequest

	// GetMyNamePostExecute executes the request
	//  @return GetMyNamePost200Response
	GetMyNamePostExecute(r ApiGetMyNamePostRequest) (*GetMyNamePost200Response, *http.Response, error)

	/*
	GetMyShortDescriptionPost Method for GetMyShortDescriptionPost

	Use this method to get the current bot short description for the given user language. Returns [BotShortDescription](https://core.telegram.org/bots/api/#botshortdescription) on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetMyShortDescriptionPostRequest
	*/
	GetMyShortDescriptionPost(ctx context.Context) ApiGetMyShortDescriptionPostRequest

	// GetMyShortDescriptionPostExecute executes the request
	//  @return GetMyShortDescriptionPost200Response
	GetMyShortDescriptionPostExecute(r ApiGetMyShortDescriptionPostRequest) (*GetMyShortDescriptionPost200Response, *http.Response, error)

	/*
	GetStarTransactionsPost Method for GetStarTransactionsPost

	Returns the bot's Telegram Star transactions in chronological order. On success, returns a [StarTransactions](https://core.telegram.org/bots/api/#startransactions) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetStarTransactionsPostRequest
	*/
	GetStarTransactionsPost(ctx context.Context) ApiGetStarTransactionsPostRequest

	// GetStarTransactionsPostExecute executes the request
	//  @return GetStarTransactionsPost200Response
	GetStarTransactionsPostExecute(r ApiGetStarTransactionsPostRequest) (*GetStarTransactionsPost200Response, *http.Response, error)

	/*
	GetStickerSetPost Method for GetStickerSetPost

	Use this method to get a sticker set. On success, a [StickerSet](https://core.telegram.org/bots/api/#stickerset) object is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetStickerSetPostRequest
	*/
	GetStickerSetPost(ctx context.Context) ApiGetStickerSetPostRequest

	// GetStickerSetPostExecute executes the request
	//  @return GetStickerSetPost200Response
	GetStickerSetPostExecute(r ApiGetStickerSetPostRequest) (*GetStickerSetPost200Response, *http.Response, error)

	/*
	GetUpdatesPost Method for GetUpdatesPost

	Use this method to receive incoming updates using long polling ([wiki](https://en.wikipedia.org/wiki/Push_technology#Long_polling)). Returns an Array of [Update](https://core.telegram.org/bots/api/#update) objects.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUpdatesPostRequest
	*/
	GetUpdatesPost(ctx context.Context) ApiGetUpdatesPostRequest

	// GetUpdatesPostExecute executes the request
	//  @return GetUpdatesPost200Response
	GetUpdatesPostExecute(r ApiGetUpdatesPostRequest) (*GetUpdatesPost200Response, *http.Response, error)

	/*
	GetUserChatBoostsPost Method for GetUserChatBoostsPost

	Use this method to get the list of boosts added to a chat by a user. Requires administrator rights in the chat. Returns a [UserChatBoosts](https://core.telegram.org/bots/api/#userchatboosts) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUserChatBoostsPostRequest
	*/
	GetUserChatBoostsPost(ctx context.Context) ApiGetUserChatBoostsPostRequest

	// GetUserChatBoostsPostExecute executes the request
	//  @return GetUserChatBoostsPost200Response
	GetUserChatBoostsPostExecute(r ApiGetUserChatBoostsPostRequest) (*GetUserChatBoostsPost200Response, *http.Response, error)

	/*
	GetUserProfilePhotosPost Method for GetUserProfilePhotosPost

	Use this method to get a list of profile pictures for a user. Returns a [UserProfilePhotos](https://core.telegram.org/bots/api/#userprofilephotos) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUserProfilePhotosPostRequest
	*/
	GetUserProfilePhotosPost(ctx context.Context) ApiGetUserProfilePhotosPostRequest

	// GetUserProfilePhotosPostExecute executes the request
	//  @return GetUserProfilePhotosPost200Response
	GetUserProfilePhotosPostExecute(r ApiGetUserProfilePhotosPostRequest) (*GetUserProfilePhotosPost200Response, *http.Response, error)

	/*
	GetWebhookInfoPost Method for GetWebhookInfoPost

	Use this method to get current webhook status. Requires no parameters. On success, returns a [WebhookInfo](https://core.telegram.org/bots/api/#webhookinfo) object. If the bot is using [getUpdates](https://core.telegram.org/bots/api/#getupdates), will return an object with the *url* field empty.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetWebhookInfoPostRequest
	*/
	GetWebhookInfoPost(ctx context.Context) ApiGetWebhookInfoPostRequest

	// GetWebhookInfoPostExecute executes the request
	//  @return GetWebhookInfoPost200Response
	GetWebhookInfoPostExecute(r ApiGetWebhookInfoPostRequest) (*GetWebhookInfoPost200Response, *http.Response, error)

	/*
	GiftPremiumSubscriptionPost Method for GiftPremiumSubscriptionPost

	Gifts a Telegram Premium subscription to the given user. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGiftPremiumSubscriptionPostRequest
	*/
	GiftPremiumSubscriptionPost(ctx context.Context) ApiGiftPremiumSubscriptionPostRequest

	// GiftPremiumSubscriptionPostExecute executes the request
	//  @return SetWebhookPost200Response
	GiftPremiumSubscriptionPostExecute(r ApiGiftPremiumSubscriptionPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	HideGeneralForumTopicPost Method for HideGeneralForumTopicPost

	Use this method to hide the 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. The topic will be automatically closed if it was open. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiHideGeneralForumTopicPostRequest
	*/
	HideGeneralForumTopicPost(ctx context.Context) ApiHideGeneralForumTopicPostRequest

	// HideGeneralForumTopicPostExecute executes the request
	//  @return SetWebhookPost200Response
	HideGeneralForumTopicPostExecute(r ApiHideGeneralForumTopicPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	LeaveChatPost Method for LeaveChatPost

	Use this method for your bot to leave a group, supergroup or channel. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLeaveChatPostRequest
	*/
	LeaveChatPost(ctx context.Context) ApiLeaveChatPostRequest

	// LeaveChatPostExecute executes the request
	//  @return SetWebhookPost200Response
	LeaveChatPostExecute(r ApiLeaveChatPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	LogOutPost Method for LogOutPost

	Use this method to log out from the cloud Bot API server before launching the bot locally. You **must** log out the bot before running it locally, otherwise there is no guarantee that the bot will receive updates. After a successful call, you can immediately log in on a local server, but will not be able to log in back to the cloud Bot API server for 10 minutes. Returns *True* on success. Requires no parameters.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLogOutPostRequest
	*/
	LogOutPost(ctx context.Context) ApiLogOutPostRequest

	// LogOutPostExecute executes the request
	//  @return SetWebhookPost200Response
	LogOutPostExecute(r ApiLogOutPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	PinChatMessagePost Method for PinChatMessagePost

	Use this method to add a message to the list of pinned messages in a chat. If the chat is not a private chat, the bot must be an administrator in the chat for this to work and must have the 'can\_pin\_messages' administrator right in a supergroup or 'can\_edit\_messages' administrator right in a channel. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPinChatMessagePostRequest
	*/
	PinChatMessagePost(ctx context.Context) ApiPinChatMessagePostRequest

	// PinChatMessagePostExecute executes the request
	//  @return SetWebhookPost200Response
	PinChatMessagePostExecute(r ApiPinChatMessagePostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	PostStoryPost Method for PostStoryPost

	Posts a story on behalf of a managed business account. Requires the *can\_manage\_stories* business bot right. Returns [Story](https://core.telegram.org/bots/api/#story) on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostStoryPostRequest
	*/
	PostStoryPost(ctx context.Context) ApiPostStoryPostRequest

	// PostStoryPostExecute executes the request
	//  @return PostStoryPost200Response
	PostStoryPostExecute(r ApiPostStoryPostRequest) (*PostStoryPost200Response, *http.Response, error)

	/*
	PromoteChatMemberPost Method for PromoteChatMemberPost

	Use this method to promote or demote a user in a supergroup or a channel. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Pass *False* for all boolean parameters to demote a user. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPromoteChatMemberPostRequest
	*/
	PromoteChatMemberPost(ctx context.Context) ApiPromoteChatMemberPostRequest

	// PromoteChatMemberPostExecute executes the request
	//  @return SetWebhookPost200Response
	PromoteChatMemberPostExecute(r ApiPromoteChatMemberPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	ReadBusinessMessagePost Method for ReadBusinessMessagePost

	Marks incoming message as read on behalf of a business account. Requires the *can\_read\_messages* business bot right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiReadBusinessMessagePostRequest
	*/
	ReadBusinessMessagePost(ctx context.Context) ApiReadBusinessMessagePostRequest

	// ReadBusinessMessagePostExecute executes the request
	//  @return SetWebhookPost200Response
	ReadBusinessMessagePostExecute(r ApiReadBusinessMessagePostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	RefundStarPaymentPost Method for RefundStarPaymentPost

	Refunds a successful payment in [Telegram Stars](https://t.me/BotNews/90). Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRefundStarPaymentPostRequest
	*/
	RefundStarPaymentPost(ctx context.Context) ApiRefundStarPaymentPostRequest

	// RefundStarPaymentPostExecute executes the request
	//  @return SetWebhookPost200Response
	RefundStarPaymentPostExecute(r ApiRefundStarPaymentPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	RemoveBusinessAccountProfilePhotoPost Method for RemoveBusinessAccountProfilePhotoPost

	Removes the current profile photo of a managed business account. Requires the *can\_edit\_profile\_photo* business bot right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRemoveBusinessAccountProfilePhotoPostRequest
	*/
	RemoveBusinessAccountProfilePhotoPost(ctx context.Context) ApiRemoveBusinessAccountProfilePhotoPostRequest

	// RemoveBusinessAccountProfilePhotoPostExecute executes the request
	//  @return SetWebhookPost200Response
	RemoveBusinessAccountProfilePhotoPostExecute(r ApiRemoveBusinessAccountProfilePhotoPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	RemoveChatVerificationPost Method for RemoveChatVerificationPost

	Removes verification from a chat that is currently verified [on behalf of the organization](https://telegram.org/verify#third-party-verification) represented by the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRemoveChatVerificationPostRequest
	*/
	RemoveChatVerificationPost(ctx context.Context) ApiRemoveChatVerificationPostRequest

	// RemoveChatVerificationPostExecute executes the request
	//  @return SetWebhookPost200Response
	RemoveChatVerificationPostExecute(r ApiRemoveChatVerificationPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	RemoveUserVerificationPost Method for RemoveUserVerificationPost

	Removes verification from a user who is currently verified [on behalf of the organization](https://telegram.org/verify#third-party-verification) represented by the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRemoveUserVerificationPostRequest
	*/
	RemoveUserVerificationPost(ctx context.Context) ApiRemoveUserVerificationPostRequest

	// RemoveUserVerificationPostExecute executes the request
	//  @return SetWebhookPost200Response
	RemoveUserVerificationPostExecute(r ApiRemoveUserVerificationPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	ReopenForumTopicPost Method for ReopenForumTopicPost

	Use this method to reopen a closed topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights, unless it is the creator of the topic. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiReopenForumTopicPostRequest
	*/
	ReopenForumTopicPost(ctx context.Context) ApiReopenForumTopicPostRequest

	// ReopenForumTopicPostExecute executes the request
	//  @return SetWebhookPost200Response
	ReopenForumTopicPostExecute(r ApiReopenForumTopicPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	ReopenGeneralForumTopicPost Method for ReopenGeneralForumTopicPost

	Use this method to reopen a closed 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. The topic will be automatically unhidden if it was hidden. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiReopenGeneralForumTopicPostRequest
	*/
	ReopenGeneralForumTopicPost(ctx context.Context) ApiReopenGeneralForumTopicPostRequest

	// ReopenGeneralForumTopicPostExecute executes the request
	//  @return SetWebhookPost200Response
	ReopenGeneralForumTopicPostExecute(r ApiReopenGeneralForumTopicPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	ReplaceStickerInSetPost Method for ReplaceStickerInSetPost

	Use this method to replace an existing sticker in a sticker set with a new one. The method is equivalent to calling [deleteStickerFromSet](https://core.telegram.org/bots/api/#deletestickerfromset), then [addStickerToSet](https://core.telegram.org/bots/api/#addstickertoset), then [setStickerPositionInSet](https://core.telegram.org/bots/api/#setstickerpositioninset). Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiReplaceStickerInSetPostRequest
	*/
	ReplaceStickerInSetPost(ctx context.Context) ApiReplaceStickerInSetPostRequest

	// ReplaceStickerInSetPostExecute executes the request
	//  @return SetWebhookPost200Response
	ReplaceStickerInSetPostExecute(r ApiReplaceStickerInSetPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	RestrictChatMemberPost Method for RestrictChatMemberPost

	Use this method to restrict a user in a supergroup. The bot must be an administrator in the supergroup for this to work and must have the appropriate administrator rights. Pass *True* for all permissions to lift restrictions from a user. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRestrictChatMemberPostRequest
	*/
	RestrictChatMemberPost(ctx context.Context) ApiRestrictChatMemberPostRequest

	// RestrictChatMemberPostExecute executes the request
	//  @return SetWebhookPost200Response
	RestrictChatMemberPostExecute(r ApiRestrictChatMemberPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	RevokeChatInviteLinkPost Method for RevokeChatInviteLinkPost

	Use this method to revoke an invite link created by the bot. If the primary link is revoked, a new link is automatically generated. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns the revoked invite link as [ChatInviteLink](https://core.telegram.org/bots/api/#chatinvitelink) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRevokeChatInviteLinkPostRequest
	*/
	RevokeChatInviteLinkPost(ctx context.Context) ApiRevokeChatInviteLinkPostRequest

	// RevokeChatInviteLinkPostExecute executes the request
	//  @return CreateChatInviteLinkPost200Response
	RevokeChatInviteLinkPostExecute(r ApiRevokeChatInviteLinkPostRequest) (*CreateChatInviteLinkPost200Response, *http.Response, error)

	/*
	SavePreparedInlineMessagePost Method for SavePreparedInlineMessagePost

	Stores a message that can be sent by a user of a Mini App. Returns a [PreparedInlineMessage](https://core.telegram.org/bots/api/#preparedinlinemessage) object.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSavePreparedInlineMessagePostRequest
	*/
	SavePreparedInlineMessagePost(ctx context.Context) ApiSavePreparedInlineMessagePostRequest

	// SavePreparedInlineMessagePostExecute executes the request
	//  @return SavePreparedInlineMessagePost200Response
	SavePreparedInlineMessagePostExecute(r ApiSavePreparedInlineMessagePostRequest) (*SavePreparedInlineMessagePost200Response, *http.Response, error)

	/*
	SendAnimationPost Method for SendAnimationPost

	Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without sound). On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned. Bots can currently send animation files of up to 50 MB in size, this limit may be changed in the future.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSendAnimationPostRequest
	*/
	SendAnimationPost(ctx context.Context) ApiSendAnimationPostRequest

	// SendAnimationPostExecute executes the request
	//  @return SendMessagePost200Response
	SendAnimationPostExecute(r ApiSendAnimationPostRequest) (*SendMessagePost200Response, *http.Response, error)

	/*
	SendAudioPost Method for SendAudioPost

	Use this method to send audio files, if you want Telegram clients to display them in the music player. Your audio must be in the .MP3 or .M4A format. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned. Bots can currently send audio files of up to 50 MB in size, this limit may be changed in the future.

For sending voice messages, use the [sendVoice](https://core.telegram.org/bots/api/#sendvoice) method instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSendAudioPostRequest
	*/
	SendAudioPost(ctx context.Context) ApiSendAudioPostRequest

	// SendAudioPostExecute executes the request
	//  @return SendMessagePost200Response
	SendAudioPostExecute(r ApiSendAudioPostRequest) (*SendMessagePost200Response, *http.Response, error)

	/*
	SendChatActionPost Method for SendChatActionPost

	Use this method when you need to tell the user that something is happening on the bot's side. The status is set for 5 seconds or less (when a message arrives from your bot, Telegram clients clear its typing status). Returns *True* on success.

Example: The [ImageBot](https://t.me/imagebot) needs some time to process a request and upload the image. Instead of sending a text message along the lines of “Retrieving image, please wait…”, the bot may use [sendChatAction](https://core.telegram.org/bots/api/#sendchataction) with *action* = *upload\_photo*. The user will see a “sending photo” status for the bot.

We only recommend using this method when a response from the bot will take a **noticeable** amount of time to arrive.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSendChatActionPostRequest
	*/
	SendChatActionPost(ctx context.Context) ApiSendChatActionPostRequest

	// SendChatActionPostExecute executes the request
	//  @return SetWebhookPost200Response
	SendChatActionPostExecute(r ApiSendChatActionPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SendContactPost Method for SendContactPost

	Use this method to send phone contacts. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSendContactPostRequest
	*/
	SendContactPost(ctx context.Context) ApiSendContactPostRequest

	// SendContactPostExecute executes the request
	//  @return SendMessagePost200Response
	SendContactPostExecute(r ApiSendContactPostRequest) (*SendMessagePost200Response, *http.Response, error)

	/*
	SendDicePost Method for SendDicePost

	Use this method to send an animated emoji that will display a random value. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSendDicePostRequest
	*/
	SendDicePost(ctx context.Context) ApiSendDicePostRequest

	// SendDicePostExecute executes the request
	//  @return SendMessagePost200Response
	SendDicePostExecute(r ApiSendDicePostRequest) (*SendMessagePost200Response, *http.Response, error)

	/*
	SendDocumentPost Method for SendDocumentPost

	Use this method to send general files. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned. Bots can currently send files of any type of up to 50 MB in size, this limit may be changed in the future.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSendDocumentPostRequest
	*/
	SendDocumentPost(ctx context.Context) ApiSendDocumentPostRequest

	// SendDocumentPostExecute executes the request
	//  @return SendMessagePost200Response
	SendDocumentPostExecute(r ApiSendDocumentPostRequest) (*SendMessagePost200Response, *http.Response, error)

	/*
	SendGamePost Method for SendGamePost

	Use this method to send a game. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSendGamePostRequest
	*/
	SendGamePost(ctx context.Context) ApiSendGamePostRequest

	// SendGamePostExecute executes the request
	//  @return SendMessagePost200Response
	SendGamePostExecute(r ApiSendGamePostRequest) (*SendMessagePost200Response, *http.Response, error)

	/*
	SendGiftPost Method for SendGiftPost

	Sends a gift to the given user or channel chat. The gift can't be converted to Telegram Stars by the receiver. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSendGiftPostRequest
	*/
	SendGiftPost(ctx context.Context) ApiSendGiftPostRequest

	// SendGiftPostExecute executes the request
	//  @return SetWebhookPost200Response
	SendGiftPostExecute(r ApiSendGiftPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SendInvoicePost Method for SendInvoicePost

	Use this method to send invoices. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSendInvoicePostRequest
	*/
	SendInvoicePost(ctx context.Context) ApiSendInvoicePostRequest

	// SendInvoicePostExecute executes the request
	//  @return SendMessagePost200Response
	SendInvoicePostExecute(r ApiSendInvoicePostRequest) (*SendMessagePost200Response, *http.Response, error)

	/*
	SendLocationPost Method for SendLocationPost

	Use this method to send point on the map. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSendLocationPostRequest
	*/
	SendLocationPost(ctx context.Context) ApiSendLocationPostRequest

	// SendLocationPostExecute executes the request
	//  @return SendMessagePost200Response
	SendLocationPostExecute(r ApiSendLocationPostRequest) (*SendMessagePost200Response, *http.Response, error)

	/*
	SendMediaGroupPost Method for SendMediaGroupPost

	Use this method to send a group of photos, videos, documents or audios as an album. Documents and audio files can be only grouped in an album with messages of the same type. On success, an array of [Messages](https://core.telegram.org/bots/api/#message) that were sent is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSendMediaGroupPostRequest
	*/
	SendMediaGroupPost(ctx context.Context) ApiSendMediaGroupPostRequest

	// SendMediaGroupPostExecute executes the request
	//  @return SendMediaGroupPost200Response
	SendMediaGroupPostExecute(r ApiSendMediaGroupPostRequest) (*SendMediaGroupPost200Response, *http.Response, error)

	/*
	SendMessagePost Method for SendMessagePost

	Use this method to send text messages. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSendMessagePostRequest
	*/
	SendMessagePost(ctx context.Context) ApiSendMessagePostRequest

	// SendMessagePostExecute executes the request
	//  @return SendMessagePost200Response
	SendMessagePostExecute(r ApiSendMessagePostRequest) (*SendMessagePost200Response, *http.Response, error)

	/*
	SendPaidMediaPost Method for SendPaidMediaPost

	Use this method to send paid media. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSendPaidMediaPostRequest
	*/
	SendPaidMediaPost(ctx context.Context) ApiSendPaidMediaPostRequest

	// SendPaidMediaPostExecute executes the request
	//  @return SendMessagePost200Response
	SendPaidMediaPostExecute(r ApiSendPaidMediaPostRequest) (*SendMessagePost200Response, *http.Response, error)

	/*
	SendPhotoPost Method for SendPhotoPost

	Use this method to send photos. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSendPhotoPostRequest
	*/
	SendPhotoPost(ctx context.Context) ApiSendPhotoPostRequest

	// SendPhotoPostExecute executes the request
	//  @return SendMessagePost200Response
	SendPhotoPostExecute(r ApiSendPhotoPostRequest) (*SendMessagePost200Response, *http.Response, error)

	/*
	SendPollPost Method for SendPollPost

	Use this method to send a native poll. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSendPollPostRequest
	*/
	SendPollPost(ctx context.Context) ApiSendPollPostRequest

	// SendPollPostExecute executes the request
	//  @return SendMessagePost200Response
	SendPollPostExecute(r ApiSendPollPostRequest) (*SendMessagePost200Response, *http.Response, error)

	/*
	SendStickerPost Method for SendStickerPost

	Use this method to send static .WEBP, [animated](https://telegram.org/blog/animated-stickers) .TGS, or [video](https://telegram.org/blog/video-stickers-better-reactions) .WEBM stickers. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSendStickerPostRequest
	*/
	SendStickerPost(ctx context.Context) ApiSendStickerPostRequest

	// SendStickerPostExecute executes the request
	//  @return SendMessagePost200Response
	SendStickerPostExecute(r ApiSendStickerPostRequest) (*SendMessagePost200Response, *http.Response, error)

	/*
	SendVenuePost Method for SendVenuePost

	Use this method to send information about a venue. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSendVenuePostRequest
	*/
	SendVenuePost(ctx context.Context) ApiSendVenuePostRequest

	// SendVenuePostExecute executes the request
	//  @return SendMessagePost200Response
	SendVenuePostExecute(r ApiSendVenuePostRequest) (*SendMessagePost200Response, *http.Response, error)

	/*
	SendVideoNotePost Method for SendVideoNotePost

	As of [v.4.0](https://telegram.org/blog/video-messages-and-telescope), Telegram clients support rounded square MPEG4 videos of up to 1 minute long. Use this method to send video messages. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSendVideoNotePostRequest
	*/
	SendVideoNotePost(ctx context.Context) ApiSendVideoNotePostRequest

	// SendVideoNotePostExecute executes the request
	//  @return SendMessagePost200Response
	SendVideoNotePostExecute(r ApiSendVideoNotePostRequest) (*SendMessagePost200Response, *http.Response, error)

	/*
	SendVideoPost Method for SendVideoPost

	Use this method to send video files, Telegram clients support MPEG4 videos (other formats may be sent as [Document](https://core.telegram.org/bots/api/#document)). On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned. Bots can currently send video files of up to 50 MB in size, this limit may be changed in the future.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSendVideoPostRequest
	*/
	SendVideoPost(ctx context.Context) ApiSendVideoPostRequest

	// SendVideoPostExecute executes the request
	//  @return SendMessagePost200Response
	SendVideoPostExecute(r ApiSendVideoPostRequest) (*SendMessagePost200Response, *http.Response, error)

	/*
	SendVoicePost Method for SendVoicePost

	Use this method to send audio files, if you want Telegram clients to display the file as a playable voice message. For this to work, your audio must be in an .OGG file encoded with OPUS, or in .MP3 format, or in .M4A format (other formats may be sent as [Audio](https://core.telegram.org/bots/api/#audio) or [Document](https://core.telegram.org/bots/api/#document)). On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned. Bots can currently send voice messages of up to 50 MB in size, this limit may be changed in the future.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSendVoicePostRequest
	*/
	SendVoicePost(ctx context.Context) ApiSendVoicePostRequest

	// SendVoicePostExecute executes the request
	//  @return SendMessagePost200Response
	SendVoicePostExecute(r ApiSendVoicePostRequest) (*SendMessagePost200Response, *http.Response, error)

	/*
	SetBusinessAccountBioPost Method for SetBusinessAccountBioPost

	Changes the bio of a managed business account. Requires the *can\_change\_bio* business bot right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetBusinessAccountBioPostRequest
	*/
	SetBusinessAccountBioPost(ctx context.Context) ApiSetBusinessAccountBioPostRequest

	// SetBusinessAccountBioPostExecute executes the request
	//  @return SetWebhookPost200Response
	SetBusinessAccountBioPostExecute(r ApiSetBusinessAccountBioPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetBusinessAccountGiftSettingsPost Method for SetBusinessAccountGiftSettingsPost

	Changes the privacy settings pertaining to incoming gifts in a managed business account. Requires the *can\_change\_gift\_settings* business bot right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetBusinessAccountGiftSettingsPostRequest
	*/
	SetBusinessAccountGiftSettingsPost(ctx context.Context) ApiSetBusinessAccountGiftSettingsPostRequest

	// SetBusinessAccountGiftSettingsPostExecute executes the request
	//  @return SetWebhookPost200Response
	SetBusinessAccountGiftSettingsPostExecute(r ApiSetBusinessAccountGiftSettingsPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetBusinessAccountNamePost Method for SetBusinessAccountNamePost

	Changes the first and last name of a managed business account. Requires the *can\_change\_name* business bot right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetBusinessAccountNamePostRequest
	*/
	SetBusinessAccountNamePost(ctx context.Context) ApiSetBusinessAccountNamePostRequest

	// SetBusinessAccountNamePostExecute executes the request
	//  @return SetWebhookPost200Response
	SetBusinessAccountNamePostExecute(r ApiSetBusinessAccountNamePostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetBusinessAccountProfilePhotoPost Method for SetBusinessAccountProfilePhotoPost

	Changes the profile photo of a managed business account. Requires the *can\_edit\_profile\_photo* business bot right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetBusinessAccountProfilePhotoPostRequest
	*/
	SetBusinessAccountProfilePhotoPost(ctx context.Context) ApiSetBusinessAccountProfilePhotoPostRequest

	// SetBusinessAccountProfilePhotoPostExecute executes the request
	//  @return SetWebhookPost200Response
	SetBusinessAccountProfilePhotoPostExecute(r ApiSetBusinessAccountProfilePhotoPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetBusinessAccountUsernamePost Method for SetBusinessAccountUsernamePost

	Changes the username of a managed business account. Requires the *can\_change\_username* business bot right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetBusinessAccountUsernamePostRequest
	*/
	SetBusinessAccountUsernamePost(ctx context.Context) ApiSetBusinessAccountUsernamePostRequest

	// SetBusinessAccountUsernamePostExecute executes the request
	//  @return SetWebhookPost200Response
	SetBusinessAccountUsernamePostExecute(r ApiSetBusinessAccountUsernamePostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetChatAdministratorCustomTitlePost Method for SetChatAdministratorCustomTitlePost

	Use this method to set a custom title for an administrator in a supergroup promoted by the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetChatAdministratorCustomTitlePostRequest
	*/
	SetChatAdministratorCustomTitlePost(ctx context.Context) ApiSetChatAdministratorCustomTitlePostRequest

	// SetChatAdministratorCustomTitlePostExecute executes the request
	//  @return SetWebhookPost200Response
	SetChatAdministratorCustomTitlePostExecute(r ApiSetChatAdministratorCustomTitlePostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetChatDescriptionPost Method for SetChatDescriptionPost

	Use this method to change the description of a group, a supergroup or a channel. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetChatDescriptionPostRequest
	*/
	SetChatDescriptionPost(ctx context.Context) ApiSetChatDescriptionPostRequest

	// SetChatDescriptionPostExecute executes the request
	//  @return SetWebhookPost200Response
	SetChatDescriptionPostExecute(r ApiSetChatDescriptionPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetChatMenuButtonPost Method for SetChatMenuButtonPost

	Use this method to change the bot's menu button in a private chat, or the default menu button. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetChatMenuButtonPostRequest
	*/
	SetChatMenuButtonPost(ctx context.Context) ApiSetChatMenuButtonPostRequest

	// SetChatMenuButtonPostExecute executes the request
	//  @return SetWebhookPost200Response
	SetChatMenuButtonPostExecute(r ApiSetChatMenuButtonPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetChatPermissionsPost Method for SetChatPermissionsPost

	Use this method to set default chat permissions for all members. The bot must be an administrator in the group or a supergroup for this to work and must have the *can\_restrict\_members* administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetChatPermissionsPostRequest
	*/
	SetChatPermissionsPost(ctx context.Context) ApiSetChatPermissionsPostRequest

	// SetChatPermissionsPostExecute executes the request
	//  @return SetWebhookPost200Response
	SetChatPermissionsPostExecute(r ApiSetChatPermissionsPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetChatPhotoPost Method for SetChatPhotoPost

	Use this method to set a new profile photo for the chat. Photos can't be changed for private chats. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetChatPhotoPostRequest
	*/
	SetChatPhotoPost(ctx context.Context) ApiSetChatPhotoPostRequest

	// SetChatPhotoPostExecute executes the request
	//  @return SetWebhookPost200Response
	SetChatPhotoPostExecute(r ApiSetChatPhotoPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetChatStickerSetPost Method for SetChatStickerSetPost

	Use this method to set a new group sticker set for a supergroup. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Use the field *can\_set\_sticker\_set* optionally returned in [getChat](https://core.telegram.org/bots/api/#getchat) requests to check if the bot can use this method. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetChatStickerSetPostRequest
	*/
	SetChatStickerSetPost(ctx context.Context) ApiSetChatStickerSetPostRequest

	// SetChatStickerSetPostExecute executes the request
	//  @return SetWebhookPost200Response
	SetChatStickerSetPostExecute(r ApiSetChatStickerSetPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetChatTitlePost Method for SetChatTitlePost

	Use this method to change the title of a chat. Titles can't be changed for private chats. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetChatTitlePostRequest
	*/
	SetChatTitlePost(ctx context.Context) ApiSetChatTitlePostRequest

	// SetChatTitlePostExecute executes the request
	//  @return SetWebhookPost200Response
	SetChatTitlePostExecute(r ApiSetChatTitlePostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetCustomEmojiStickerSetThumbnailPost Method for SetCustomEmojiStickerSetThumbnailPost

	Use this method to set the thumbnail of a custom emoji sticker set. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetCustomEmojiStickerSetThumbnailPostRequest
	*/
	SetCustomEmojiStickerSetThumbnailPost(ctx context.Context) ApiSetCustomEmojiStickerSetThumbnailPostRequest

	// SetCustomEmojiStickerSetThumbnailPostExecute executes the request
	//  @return SetWebhookPost200Response
	SetCustomEmojiStickerSetThumbnailPostExecute(r ApiSetCustomEmojiStickerSetThumbnailPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetGameScorePost Method for SetGameScorePost

	Use this method to set the score of the specified user in a game message. On success, if the message is not an inline message, the [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned. Returns an error, if the new score is not greater than the user's current score in the chat and *force* is *False*.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetGameScorePostRequest
	*/
	SetGameScorePost(ctx context.Context) ApiSetGameScorePostRequest

	// SetGameScorePostExecute executes the request
	//  @return EditMessageTextPost200Response
	SetGameScorePostExecute(r ApiSetGameScorePostRequest) (*EditMessageTextPost200Response, *http.Response, error)

	/*
	SetMessageReactionPost Method for SetMessageReactionPost

	Use this method to change the chosen reactions on a message. Service messages of some types can't be reacted to. Automatically forwarded messages from a channel to its discussion group have the same available reactions as messages in the channel. Bots can't use paid reactions. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetMessageReactionPostRequest
	*/
	SetMessageReactionPost(ctx context.Context) ApiSetMessageReactionPostRequest

	// SetMessageReactionPostExecute executes the request
	//  @return SetWebhookPost200Response
	SetMessageReactionPostExecute(r ApiSetMessageReactionPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetMyCommandsPost Method for SetMyCommandsPost

	Use this method to change the list of the bot's commands. See [this manual](https://core.telegram.org/bots/features#commands) for more details about bot commands. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetMyCommandsPostRequest
	*/
	SetMyCommandsPost(ctx context.Context) ApiSetMyCommandsPostRequest

	// SetMyCommandsPostExecute executes the request
	//  @return SetWebhookPost200Response
	SetMyCommandsPostExecute(r ApiSetMyCommandsPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetMyDefaultAdministratorRightsPost Method for SetMyDefaultAdministratorRightsPost

	Use this method to change the default administrator rights requested by the bot when it's added as an administrator to groups or channels. These rights will be suggested to users, but they are free to modify the list before adding the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetMyDefaultAdministratorRightsPostRequest
	*/
	SetMyDefaultAdministratorRightsPost(ctx context.Context) ApiSetMyDefaultAdministratorRightsPostRequest

	// SetMyDefaultAdministratorRightsPostExecute executes the request
	//  @return SetWebhookPost200Response
	SetMyDefaultAdministratorRightsPostExecute(r ApiSetMyDefaultAdministratorRightsPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetMyDescriptionPost Method for SetMyDescriptionPost

	Use this method to change the bot's description, which is shown in the chat with the bot if the chat is empty. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetMyDescriptionPostRequest
	*/
	SetMyDescriptionPost(ctx context.Context) ApiSetMyDescriptionPostRequest

	// SetMyDescriptionPostExecute executes the request
	//  @return SetWebhookPost200Response
	SetMyDescriptionPostExecute(r ApiSetMyDescriptionPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetMyNamePost Method for SetMyNamePost

	Use this method to change the bot's name. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetMyNamePostRequest
	*/
	SetMyNamePost(ctx context.Context) ApiSetMyNamePostRequest

	// SetMyNamePostExecute executes the request
	//  @return SetWebhookPost200Response
	SetMyNamePostExecute(r ApiSetMyNamePostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetMyShortDescriptionPost Method for SetMyShortDescriptionPost

	Use this method to change the bot's short description, which is shown on the bot's profile page and is sent together with the link when users share the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetMyShortDescriptionPostRequest
	*/
	SetMyShortDescriptionPost(ctx context.Context) ApiSetMyShortDescriptionPostRequest

	// SetMyShortDescriptionPostExecute executes the request
	//  @return SetWebhookPost200Response
	SetMyShortDescriptionPostExecute(r ApiSetMyShortDescriptionPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetPassportDataErrorsPost Method for SetPassportDataErrorsPost

	Informs a user that some of the Telegram Passport elements they provided contains errors. The user will not be able to re-submit their Passport to you until the errors are fixed (the contents of the field for which you returned the error must change). Returns *True* on success.

Use this if the data submitted by the user doesn't satisfy the standards your service requires for any reason. For example, if a birthday date seems invalid, a submitted document is blurry, a scan shows evidence of tampering, etc. Supply some details in the error message to make sure the user knows how to correct the issues.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetPassportDataErrorsPostRequest
	*/
	SetPassportDataErrorsPost(ctx context.Context) ApiSetPassportDataErrorsPostRequest

	// SetPassportDataErrorsPostExecute executes the request
	//  @return SetWebhookPost200Response
	SetPassportDataErrorsPostExecute(r ApiSetPassportDataErrorsPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetStickerEmojiListPost Method for SetStickerEmojiListPost

	Use this method to change the list of emoji assigned to a regular or custom emoji sticker. The sticker must belong to a sticker set created by the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetStickerEmojiListPostRequest
	*/
	SetStickerEmojiListPost(ctx context.Context) ApiSetStickerEmojiListPostRequest

	// SetStickerEmojiListPostExecute executes the request
	//  @return SetWebhookPost200Response
	SetStickerEmojiListPostExecute(r ApiSetStickerEmojiListPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetStickerKeywordsPost Method for SetStickerKeywordsPost

	Use this method to change search keywords assigned to a regular or custom emoji sticker. The sticker must belong to a sticker set created by the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetStickerKeywordsPostRequest
	*/
	SetStickerKeywordsPost(ctx context.Context) ApiSetStickerKeywordsPostRequest

	// SetStickerKeywordsPostExecute executes the request
	//  @return SetWebhookPost200Response
	SetStickerKeywordsPostExecute(r ApiSetStickerKeywordsPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetStickerMaskPositionPost Method for SetStickerMaskPositionPost

	Use this method to change the [mask position](https://core.telegram.org/bots/api/#maskposition) of a mask sticker. The sticker must belong to a sticker set that was created by the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetStickerMaskPositionPostRequest
	*/
	SetStickerMaskPositionPost(ctx context.Context) ApiSetStickerMaskPositionPostRequest

	// SetStickerMaskPositionPostExecute executes the request
	//  @return SetWebhookPost200Response
	SetStickerMaskPositionPostExecute(r ApiSetStickerMaskPositionPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetStickerPositionInSetPost Method for SetStickerPositionInSetPost

	Use this method to move a sticker in a set created by the bot to a specific position. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetStickerPositionInSetPostRequest
	*/
	SetStickerPositionInSetPost(ctx context.Context) ApiSetStickerPositionInSetPostRequest

	// SetStickerPositionInSetPostExecute executes the request
	//  @return SetWebhookPost200Response
	SetStickerPositionInSetPostExecute(r ApiSetStickerPositionInSetPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetStickerSetThumbnailPost Method for SetStickerSetThumbnailPost

	Use this method to set the thumbnail of a regular or mask sticker set. The format of the thumbnail file must match the format of the stickers in the set. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetStickerSetThumbnailPostRequest
	*/
	SetStickerSetThumbnailPost(ctx context.Context) ApiSetStickerSetThumbnailPostRequest

	// SetStickerSetThumbnailPostExecute executes the request
	//  @return SetWebhookPost200Response
	SetStickerSetThumbnailPostExecute(r ApiSetStickerSetThumbnailPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetStickerSetTitlePost Method for SetStickerSetTitlePost

	Use this method to set the title of a created sticker set. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetStickerSetTitlePostRequest
	*/
	SetStickerSetTitlePost(ctx context.Context) ApiSetStickerSetTitlePostRequest

	// SetStickerSetTitlePostExecute executes the request
	//  @return SetWebhookPost200Response
	SetStickerSetTitlePostExecute(r ApiSetStickerSetTitlePostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetUserEmojiStatusPost Method for SetUserEmojiStatusPost

	Changes the emoji status for a given user that previously allowed the bot to manage their emoji status via the Mini App method [requestEmojiStatusAccess](https://core.telegram.org/bots/webapps#initializing-mini-apps). Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetUserEmojiStatusPostRequest
	*/
	SetUserEmojiStatusPost(ctx context.Context) ApiSetUserEmojiStatusPostRequest

	// SetUserEmojiStatusPostExecute executes the request
	//  @return SetWebhookPost200Response
	SetUserEmojiStatusPostExecute(r ApiSetUserEmojiStatusPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	SetWebhookPost Method for SetWebhookPost

	Use this method to specify a URL and receive incoming updates via an outgoing webhook. Whenever there is an update for the bot, we will send an HTTPS POST request to the specified URL, containing a JSON-serialized [Update](https://core.telegram.org/bots/api/#update). In case of an unsuccessful request (a request with response [HTTP status code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) different from `2XY`), we will repeat the request and give up after a reasonable amount of attempts. Returns *True* on success.

If you'd like to make sure that the webhook was set by you, you can specify secret data in the parameter *secret\_token*. If specified, the request will contain a header “X-Telegram-Bot-Api-Secret-Token” with the secret token as content.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetWebhookPostRequest
	*/
	SetWebhookPost(ctx context.Context) ApiSetWebhookPostRequest

	// SetWebhookPostExecute executes the request
	//  @return SetWebhookPost200Response
	SetWebhookPostExecute(r ApiSetWebhookPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	StopMessageLiveLocationPost Method for StopMessageLiveLocationPost

	Use this method to stop updating a live location message before *live\_period* expires. On success, if the message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStopMessageLiveLocationPostRequest
	*/
	StopMessageLiveLocationPost(ctx context.Context) ApiStopMessageLiveLocationPostRequest

	// StopMessageLiveLocationPostExecute executes the request
	//  @return EditMessageTextPost200Response
	StopMessageLiveLocationPostExecute(r ApiStopMessageLiveLocationPostRequest) (*EditMessageTextPost200Response, *http.Response, error)

	/*
	StopPollPost Method for StopPollPost

	Use this method to stop a poll which was sent by the bot. On success, the stopped [Poll](https://core.telegram.org/bots/api/#poll) is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStopPollPostRequest
	*/
	StopPollPost(ctx context.Context) ApiStopPollPostRequest

	// StopPollPostExecute executes the request
	//  @return StopPollPost200Response
	StopPollPostExecute(r ApiStopPollPostRequest) (*StopPollPost200Response, *http.Response, error)

	/*
	TransferBusinessAccountStarsPost Method for TransferBusinessAccountStarsPost

	Transfers Telegram Stars from the business account balance to the bot's balance. Requires the *can\_transfer\_stars* business bot right. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTransferBusinessAccountStarsPostRequest
	*/
	TransferBusinessAccountStarsPost(ctx context.Context) ApiTransferBusinessAccountStarsPostRequest

	// TransferBusinessAccountStarsPostExecute executes the request
	//  @return SetWebhookPost200Response
	TransferBusinessAccountStarsPostExecute(r ApiTransferBusinessAccountStarsPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	TransferGiftPost Method for TransferGiftPost

	Transfers an owned unique gift to another user. Requires the *can\_transfer\_and\_upgrade\_gifts* business bot right. Requires *can\_transfer\_stars* business bot right if the transfer is paid. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTransferGiftPostRequest
	*/
	TransferGiftPost(ctx context.Context) ApiTransferGiftPostRequest

	// TransferGiftPostExecute executes the request
	//  @return SetWebhookPost200Response
	TransferGiftPostExecute(r ApiTransferGiftPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	UnbanChatMemberPost Method for UnbanChatMemberPost

	Use this method to unban a previously banned user in a supergroup or channel. The user will **not** return to the group or channel automatically, but will be able to join via link, etc. The bot must be an administrator for this to work. By default, this method guarantees that after the call the user is not a member of the chat, but will be able to join it. So if the user is a member of the chat they will also be **removed** from the chat. If you don't want this, use the parameter *only\_if\_banned*. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUnbanChatMemberPostRequest
	*/
	UnbanChatMemberPost(ctx context.Context) ApiUnbanChatMemberPostRequest

	// UnbanChatMemberPostExecute executes the request
	//  @return SetWebhookPost200Response
	UnbanChatMemberPostExecute(r ApiUnbanChatMemberPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	UnbanChatSenderChatPost Method for UnbanChatSenderChatPost

	Use this method to unban a previously banned channel chat in a supergroup or channel. The bot must be an administrator for this to work and must have the appropriate administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUnbanChatSenderChatPostRequest
	*/
	UnbanChatSenderChatPost(ctx context.Context) ApiUnbanChatSenderChatPostRequest

	// UnbanChatSenderChatPostExecute executes the request
	//  @return SetWebhookPost200Response
	UnbanChatSenderChatPostExecute(r ApiUnbanChatSenderChatPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	UnhideGeneralForumTopicPost Method for UnhideGeneralForumTopicPost

	Use this method to unhide the 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUnhideGeneralForumTopicPostRequest
	*/
	UnhideGeneralForumTopicPost(ctx context.Context) ApiUnhideGeneralForumTopicPostRequest

	// UnhideGeneralForumTopicPostExecute executes the request
	//  @return SetWebhookPost200Response
	UnhideGeneralForumTopicPostExecute(r ApiUnhideGeneralForumTopicPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	UnpinAllChatMessagesPost Method for UnpinAllChatMessagesPost

	Use this method to clear the list of pinned messages in a chat. If the chat is not a private chat, the bot must be an administrator in the chat for this to work and must have the 'can\_pin\_messages' administrator right in a supergroup or 'can\_edit\_messages' administrator right in a channel. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUnpinAllChatMessagesPostRequest
	*/
	UnpinAllChatMessagesPost(ctx context.Context) ApiUnpinAllChatMessagesPostRequest

	// UnpinAllChatMessagesPostExecute executes the request
	//  @return SetWebhookPost200Response
	UnpinAllChatMessagesPostExecute(r ApiUnpinAllChatMessagesPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	UnpinAllForumTopicMessagesPost Method for UnpinAllForumTopicMessagesPost

	Use this method to clear the list of pinned messages in a forum topic. The bot must be an administrator in the chat for this to work and must have the *can\_pin\_messages* administrator right in the supergroup. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUnpinAllForumTopicMessagesPostRequest
	*/
	UnpinAllForumTopicMessagesPost(ctx context.Context) ApiUnpinAllForumTopicMessagesPostRequest

	// UnpinAllForumTopicMessagesPostExecute executes the request
	//  @return SetWebhookPost200Response
	UnpinAllForumTopicMessagesPostExecute(r ApiUnpinAllForumTopicMessagesPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	UnpinAllGeneralForumTopicMessagesPost Method for UnpinAllGeneralForumTopicMessagesPost

	Use this method to clear the list of pinned messages in a General forum topic. The bot must be an administrator in the chat for this to work and must have the *can\_pin\_messages* administrator right in the supergroup. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUnpinAllGeneralForumTopicMessagesPostRequest
	*/
	UnpinAllGeneralForumTopicMessagesPost(ctx context.Context) ApiUnpinAllGeneralForumTopicMessagesPostRequest

	// UnpinAllGeneralForumTopicMessagesPostExecute executes the request
	//  @return SetWebhookPost200Response
	UnpinAllGeneralForumTopicMessagesPostExecute(r ApiUnpinAllGeneralForumTopicMessagesPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	UnpinChatMessagePost Method for UnpinChatMessagePost

	Use this method to remove a message from the list of pinned messages in a chat. If the chat is not a private chat, the bot must be an administrator in the chat for this to work and must have the 'can\_pin\_messages' administrator right in a supergroup or 'can\_edit\_messages' administrator right in a channel. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUnpinChatMessagePostRequest
	*/
	UnpinChatMessagePost(ctx context.Context) ApiUnpinChatMessagePostRequest

	// UnpinChatMessagePostExecute executes the request
	//  @return SetWebhookPost200Response
	UnpinChatMessagePostExecute(r ApiUnpinChatMessagePostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	UpgradeGiftPost Method for UpgradeGiftPost

	Upgrades a given regular gift to a unique gift. Requires the *can\_transfer\_and\_upgrade\_gifts* business bot right. Additionally requires the *can\_transfer\_stars* business bot right if the upgrade is paid. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpgradeGiftPostRequest
	*/
	UpgradeGiftPost(ctx context.Context) ApiUpgradeGiftPostRequest

	// UpgradeGiftPostExecute executes the request
	//  @return SetWebhookPost200Response
	UpgradeGiftPostExecute(r ApiUpgradeGiftPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	UploadStickerFilePost Method for UploadStickerFilePost

	Use this method to upload a file with a sticker for later use in the [createNewStickerSet](https://core.telegram.org/bots/api/#createnewstickerset), [addStickerToSet](https://core.telegram.org/bots/api/#addstickertoset), or [replaceStickerInSet](https://core.telegram.org/bots/api/#replacestickerinset) methods (the file can be used multiple times). Returns the uploaded [File](https://core.telegram.org/bots/api/#file) on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUploadStickerFilePostRequest
	*/
	UploadStickerFilePost(ctx context.Context) ApiUploadStickerFilePostRequest

	// UploadStickerFilePostExecute executes the request
	//  @return GetFilePost200Response
	UploadStickerFilePostExecute(r ApiUploadStickerFilePostRequest) (*GetFilePost200Response, *http.Response, error)

	/*
	VerifyChatPost Method for VerifyChatPost

	Verifies a chat [on behalf of the organization](https://telegram.org/verify#third-party-verification) which is represented by the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVerifyChatPostRequest
	*/
	VerifyChatPost(ctx context.Context) ApiVerifyChatPostRequest

	// VerifyChatPostExecute executes the request
	//  @return SetWebhookPost200Response
	VerifyChatPostExecute(r ApiVerifyChatPostRequest) (*SetWebhookPost200Response, *http.Response, error)

	/*
	VerifyUserPost Method for VerifyUserPost

	Verifies a user [on behalf of the organization](https://telegram.org/verify#third-party-verification) which is represented by the bot. Returns *True* on success.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiVerifyUserPostRequest
	*/
	VerifyUserPost(ctx context.Context) ApiVerifyUserPostRequest

	// VerifyUserPostExecute executes the request
	//  @return SetWebhookPost200Response
	VerifyUserPostExecute(r ApiVerifyUserPostRequest) (*SetWebhookPost200Response, *http.Response, error)
}

// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiAddStickerToSetPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	name *string
	sticker *InputSticker
}

// User identifier of sticker set owner
func (r ApiAddStickerToSetPostRequest) UserId(userId int32) ApiAddStickerToSetPostRequest {
	r.userId = &userId
	return r
}

// Sticker set name
func (r ApiAddStickerToSetPostRequest) Name(name string) ApiAddStickerToSetPostRequest {
	r.name = &name
	return r
}

func (r ApiAddStickerToSetPostRequest) Sticker(sticker InputSticker) ApiAddStickerToSetPostRequest {
	r.sticker = &sticker
	return r
}

func (r ApiAddStickerToSetPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.AddStickerToSetPostExecute(r)
}

/*
AddStickerToSetPost Method for AddStickerToSetPost

Use this method to add a new sticker to a set created by the bot. Emoji sticker sets can have up to 200 stickers. Other sticker sets can have up to 120 stickers. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddStickerToSetPostRequest
*/
func (a *DefaultAPIService) AddStickerToSetPost(ctx context.Context) ApiAddStickerToSetPostRequest {
	return ApiAddStickerToSetPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) AddStickerToSetPostExecute(r ApiAddStickerToSetPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.AddStickerToSetPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addStickerToSet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.sticker == nil {
		return localVarReturnValue, nil, reportError("sticker is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "sticker", r.sticker, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAnswerCallbackQueryPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	callbackQueryId *string
	text *string
	showAlert *bool
	url *string
	cacheTime *int32
}

// Unique identifier for the query to be answered
func (r ApiAnswerCallbackQueryPostRequest) CallbackQueryId(callbackQueryId string) ApiAnswerCallbackQueryPostRequest {
	r.callbackQueryId = &callbackQueryId
	return r
}

// Text of the notification. If not specified, nothing will be shown to the user, 0-200 characters
func (r ApiAnswerCallbackQueryPostRequest) Text(text string) ApiAnswerCallbackQueryPostRequest {
	r.text = &text
	return r
}

// If *True*, an alert will be shown by the client instead of a notification at the top of the chat screen. Defaults to *false*.
func (r ApiAnswerCallbackQueryPostRequest) ShowAlert(showAlert bool) ApiAnswerCallbackQueryPostRequest {
	r.showAlert = &showAlert
	return r
}

// URL that will be opened by the user&#39;s client. If you have created a [Game](https://core.telegram.org/bots/api/#game) and accepted the conditions via [@BotFather](https://t.me/botfather), specify the URL that opens your game - note that this will only work if the query comes from a [*callback\\\\_game*](https://core.telegram.org/bots/api/#inlinekeyboardbutton) button.    Otherwise, you may use links like &#x60;t.me/your_bot?start&#x3D;XXXX&#x60; that open your bot with a parameter.
func (r ApiAnswerCallbackQueryPostRequest) Url(url string) ApiAnswerCallbackQueryPostRequest {
	r.url = &url
	return r
}

// The maximum amount of time in seconds that the result of the callback query may be cached client-side. Telegram apps will support caching starting in version 3.14. Defaults to 0.
func (r ApiAnswerCallbackQueryPostRequest) CacheTime(cacheTime int32) ApiAnswerCallbackQueryPostRequest {
	r.cacheTime = &cacheTime
	return r
}

func (r ApiAnswerCallbackQueryPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.AnswerCallbackQueryPostExecute(r)
}

/*
AnswerCallbackQueryPost Method for AnswerCallbackQueryPost

Use this method to send answers to callback queries sent from [inline keyboards](https://core.telegram.org/bots/features#inline-keyboards). The answer will be displayed to the user as a notification at the top of the chat screen or as an alert. On success, *True* is returned.

Alternatively, the user can be redirected to the specified Game URL. For this option to work, you must first create a game for your bot via [@BotFather](https://t.me/botfather) and accept the terms. Otherwise, you may use links like `t.me/your_bot?start=XXXX` that open your bot with a parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnswerCallbackQueryPostRequest
*/
func (a *DefaultAPIService) AnswerCallbackQueryPost(ctx context.Context) ApiAnswerCallbackQueryPostRequest {
	return ApiAnswerCallbackQueryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) AnswerCallbackQueryPostExecute(r ApiAnswerCallbackQueryPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.AnswerCallbackQueryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/answerCallbackQuery"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.callbackQueryId == nil {
		return localVarReturnValue, nil, reportError("callbackQueryId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "callback_query_id", r.callbackQueryId, "", "")
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "text", r.text, "", "")
	}
	if r.showAlert != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "show_alert", r.showAlert, "", "")
	}
	if r.url != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "url", r.url, "", "")
	}
	if r.cacheTime != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "cache_time", r.cacheTime, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAnswerInlineQueryPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	inlineQueryId *string
	results *[]InlineQueryResult
	cacheTime *int32
	isPersonal *bool
	nextOffset *string
	button *InlineQueryResultsButton
}

// Unique identifier for the answered query
func (r ApiAnswerInlineQueryPostRequest) InlineQueryId(inlineQueryId string) ApiAnswerInlineQueryPostRequest {
	r.inlineQueryId = &inlineQueryId
	return r
}

// A JSON-serialized array of results for the inline query
func (r ApiAnswerInlineQueryPostRequest) Results(results []InlineQueryResult) ApiAnswerInlineQueryPostRequest {
	r.results = &results
	return r
}

// The maximum amount of time in seconds that the result of the inline query may be cached on the server. Defaults to 300.
func (r ApiAnswerInlineQueryPostRequest) CacheTime(cacheTime int32) ApiAnswerInlineQueryPostRequest {
	r.cacheTime = &cacheTime
	return r
}

// Pass *True* if results may be cached on the server side only for the user that sent the query. By default, results may be returned to any user who sends the same query.
func (r ApiAnswerInlineQueryPostRequest) IsPersonal(isPersonal bool) ApiAnswerInlineQueryPostRequest {
	r.isPersonal = &isPersonal
	return r
}

// Pass the offset that a client should send in the next query with the same text to receive more results. Pass an empty string if there are no more results or if you don&#39;t support pagination. Offset length can&#39;t exceed 64 bytes.
func (r ApiAnswerInlineQueryPostRequest) NextOffset(nextOffset string) ApiAnswerInlineQueryPostRequest {
	r.nextOffset = &nextOffset
	return r
}

func (r ApiAnswerInlineQueryPostRequest) Button(button InlineQueryResultsButton) ApiAnswerInlineQueryPostRequest {
	r.button = &button
	return r
}

func (r ApiAnswerInlineQueryPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.AnswerInlineQueryPostExecute(r)
}

/*
AnswerInlineQueryPost Method for AnswerInlineQueryPost

Use this method to send answers to an inline query. On success, *True* is returned.  
No more than **50** results per query are allowed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnswerInlineQueryPostRequest
*/
func (a *DefaultAPIService) AnswerInlineQueryPost(ctx context.Context) ApiAnswerInlineQueryPostRequest {
	return ApiAnswerInlineQueryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) AnswerInlineQueryPostExecute(r ApiAnswerInlineQueryPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.AnswerInlineQueryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/answerInlineQuery"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inlineQueryId == nil {
		return localVarReturnValue, nil, reportError("inlineQueryId is required and must be specified")
	}
	if r.results == nil {
		return localVarReturnValue, nil, reportError("results is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "inline_query_id", r.inlineQueryId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "results", r.results, "", "csv")
	if r.cacheTime != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "cache_time", r.cacheTime, "", "")
	}
	if r.isPersonal != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_personal", r.isPersonal, "", "")
	}
	if r.nextOffset != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "next_offset", r.nextOffset, "", "")
	}
	if r.button != nil {
		paramJson, err := parameterToJson(*r.button)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("button", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAnswerPreCheckoutQueryPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	preCheckoutQueryId *string
	ok *bool
	errorMessage *string
}

// Unique identifier for the query to be answered
func (r ApiAnswerPreCheckoutQueryPostRequest) PreCheckoutQueryId(preCheckoutQueryId string) ApiAnswerPreCheckoutQueryPostRequest {
	r.preCheckoutQueryId = &preCheckoutQueryId
	return r
}

// Specify *True* if everything is alright (goods are available, etc.) and the bot is ready to proceed with the order. Use *False* if there are any problems.
func (r ApiAnswerPreCheckoutQueryPostRequest) Ok(ok bool) ApiAnswerPreCheckoutQueryPostRequest {
	r.ok = &ok
	return r
}

// Required if *ok* is *False*. Error message in human readable form that explains the reason for failure to proceed with the checkout (e.g. \\\&quot;Sorry, somebody just bought the last of our amazing black T-shirts while you were busy filling out your payment details. Please choose a different color or garment!\\\&quot;). Telegram will display this message to the user.
func (r ApiAnswerPreCheckoutQueryPostRequest) ErrorMessage(errorMessage string) ApiAnswerPreCheckoutQueryPostRequest {
	r.errorMessage = &errorMessage
	return r
}

func (r ApiAnswerPreCheckoutQueryPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.AnswerPreCheckoutQueryPostExecute(r)
}

/*
AnswerPreCheckoutQueryPost Method for AnswerPreCheckoutQueryPost

Once the user has confirmed their payment and shipping details, the Bot API sends the final confirmation in the form of an [Update](https://core.telegram.org/bots/api/#update) with the field *pre\_checkout\_query*. Use this method to respond to such pre-checkout queries. On success, *True* is returned. **Note:** The Bot API must receive an answer within 10 seconds after the pre-checkout query was sent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnswerPreCheckoutQueryPostRequest
*/
func (a *DefaultAPIService) AnswerPreCheckoutQueryPost(ctx context.Context) ApiAnswerPreCheckoutQueryPostRequest {
	return ApiAnswerPreCheckoutQueryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) AnswerPreCheckoutQueryPostExecute(r ApiAnswerPreCheckoutQueryPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.AnswerPreCheckoutQueryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/answerPreCheckoutQuery"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.preCheckoutQueryId == nil {
		return localVarReturnValue, nil, reportError("preCheckoutQueryId is required and must be specified")
	}
	if r.ok == nil {
		return localVarReturnValue, nil, reportError("ok is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "pre_checkout_query_id", r.preCheckoutQueryId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "ok", r.ok, "", "")
	if r.errorMessage != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "error_message", r.errorMessage, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAnswerShippingQueryPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	shippingQueryId *string
	ok *bool
	shippingOptions *[]ShippingOption
	errorMessage *string
}

// Unique identifier for the query to be answered
func (r ApiAnswerShippingQueryPostRequest) ShippingQueryId(shippingQueryId string) ApiAnswerShippingQueryPostRequest {
	r.shippingQueryId = &shippingQueryId
	return r
}

// Pass *True* if delivery to the specified address is possible and *False* if there are any problems (for example, if delivery to the specified address is not possible)
func (r ApiAnswerShippingQueryPostRequest) Ok(ok bool) ApiAnswerShippingQueryPostRequest {
	r.ok = &ok
	return r
}

// Required if *ok* is *True*. A JSON-serialized array of available shipping options.
func (r ApiAnswerShippingQueryPostRequest) ShippingOptions(shippingOptions []ShippingOption) ApiAnswerShippingQueryPostRequest {
	r.shippingOptions = &shippingOptions
	return r
}

// Required if *ok* is *False*. Error message in human readable form that explains why it is impossible to complete the order (e.g. “Sorry, delivery to your desired address is unavailable”). Telegram will display this message to the user.
func (r ApiAnswerShippingQueryPostRequest) ErrorMessage(errorMessage string) ApiAnswerShippingQueryPostRequest {
	r.errorMessage = &errorMessage
	return r
}

func (r ApiAnswerShippingQueryPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.AnswerShippingQueryPostExecute(r)
}

/*
AnswerShippingQueryPost Method for AnswerShippingQueryPost

If you sent an invoice requesting a shipping address and the parameter *is\_flexible* was specified, the Bot API will send an [Update](https://core.telegram.org/bots/api/#update) with a *shipping\_query* field to the bot. Use this method to reply to shipping queries. On success, *True* is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnswerShippingQueryPostRequest
*/
func (a *DefaultAPIService) AnswerShippingQueryPost(ctx context.Context) ApiAnswerShippingQueryPostRequest {
	return ApiAnswerShippingQueryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) AnswerShippingQueryPostExecute(r ApiAnswerShippingQueryPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.AnswerShippingQueryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/answerShippingQuery"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shippingQueryId == nil {
		return localVarReturnValue, nil, reportError("shippingQueryId is required and must be specified")
	}
	if r.ok == nil {
		return localVarReturnValue, nil, reportError("ok is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "shipping_query_id", r.shippingQueryId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "ok", r.ok, "", "")
	if r.shippingOptions != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "shipping_options", r.shippingOptions, "", "csv")
	}
	if r.errorMessage != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "error_message", r.errorMessage, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAnswerWebAppQueryPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	webAppQueryId *string
	result *InlineQueryResult
}

// Unique identifier for the query to be answered
func (r ApiAnswerWebAppQueryPostRequest) WebAppQueryId(webAppQueryId string) ApiAnswerWebAppQueryPostRequest {
	r.webAppQueryId = &webAppQueryId
	return r
}

func (r ApiAnswerWebAppQueryPostRequest) Result(result InlineQueryResult) ApiAnswerWebAppQueryPostRequest {
	r.result = &result
	return r
}

func (r ApiAnswerWebAppQueryPostRequest) Execute() (*AnswerWebAppQueryPost200Response, *http.Response, error) {
	return r.ApiService.AnswerWebAppQueryPostExecute(r)
}

/*
AnswerWebAppQueryPost Method for AnswerWebAppQueryPost

Use this method to set the result of an interaction with a [Web App](https://core.telegram.org/bots/webapps) and send a corresponding message on behalf of the user to the chat from which the query originated. On success, a [SentWebAppMessage](https://core.telegram.org/bots/api/#sentwebappmessage) object is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnswerWebAppQueryPostRequest
*/
func (a *DefaultAPIService) AnswerWebAppQueryPost(ctx context.Context) ApiAnswerWebAppQueryPostRequest {
	return ApiAnswerWebAppQueryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AnswerWebAppQueryPost200Response
func (a *DefaultAPIService) AnswerWebAppQueryPostExecute(r ApiAnswerWebAppQueryPostRequest) (*AnswerWebAppQueryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AnswerWebAppQueryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.AnswerWebAppQueryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/answerWebAppQuery"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.webAppQueryId == nil {
		return localVarReturnValue, nil, reportError("webAppQueryId is required and must be specified")
	}
	if r.result == nil {
		return localVarReturnValue, nil, reportError("result is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "web_app_query_id", r.webAppQueryId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "result", r.result, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApproveChatJoinRequestPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	userId *int32
}

func (r ApiApproveChatJoinRequestPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiApproveChatJoinRequestPostRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the target user
func (r ApiApproveChatJoinRequestPostRequest) UserId(userId int32) ApiApproveChatJoinRequestPostRequest {
	r.userId = &userId
	return r
}

func (r ApiApproveChatJoinRequestPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.ApproveChatJoinRequestPostExecute(r)
}

/*
ApproveChatJoinRequestPost Method for ApproveChatJoinRequestPost

Use this method to approve a chat join request. The bot must be an administrator in the chat for this to work and must have the *can\_invite\_users* administrator right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApproveChatJoinRequestPostRequest
*/
func (a *DefaultAPIService) ApproveChatJoinRequestPost(ctx context.Context) ApiApproveChatJoinRequestPostRequest {
	return ApiApproveChatJoinRequestPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) ApproveChatJoinRequestPostExecute(r ApiApproveChatJoinRequestPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ApproveChatJoinRequestPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/approveChatJoinRequest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBanChatMemberPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *BanChatMemberPostRequestChatId
	userId *int32
	untilDate *int32
	revokeMessages *bool
}

func (r ApiBanChatMemberPostRequest) ChatId(chatId BanChatMemberPostRequestChatId) ApiBanChatMemberPostRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the target user
func (r ApiBanChatMemberPostRequest) UserId(userId int32) ApiBanChatMemberPostRequest {
	r.userId = &userId
	return r
}

// Date when the user will be unbanned; Unix time. If user is banned for more than 366 days or less than 30 seconds from the current time they are considered to be banned forever. Applied for supergroups and channels only.
func (r ApiBanChatMemberPostRequest) UntilDate(untilDate int32) ApiBanChatMemberPostRequest {
	r.untilDate = &untilDate
	return r
}

// Pass *True* to delete all messages from the chat for the user that is being removed. If *False*, the user will be able to see messages in the group that were sent before the user was removed. Always *True* for supergroups and channels.
func (r ApiBanChatMemberPostRequest) RevokeMessages(revokeMessages bool) ApiBanChatMemberPostRequest {
	r.revokeMessages = &revokeMessages
	return r
}

func (r ApiBanChatMemberPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.BanChatMemberPostExecute(r)
}

/*
BanChatMemberPost Method for BanChatMemberPost

Use this method to ban a user in a group, a supergroup or a channel. In the case of supergroups and channels, the user will not be able to return to the chat on their own using invite links, etc., unless [unbanned](https://core.telegram.org/bots/api/#unbanchatmember) first. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBanChatMemberPostRequest
*/
func (a *DefaultAPIService) BanChatMemberPost(ctx context.Context) ApiBanChatMemberPostRequest {
	return ApiBanChatMemberPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) BanChatMemberPostExecute(r ApiBanChatMemberPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.BanChatMemberPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/banChatMember"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	if r.untilDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "until_date", r.untilDate, "", "")
	}
	if r.revokeMessages != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "revoke_messages", r.revokeMessages, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBanChatSenderChatPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	senderChatId *int32
}

func (r ApiBanChatSenderChatPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiBanChatSenderChatPostRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the target sender chat
func (r ApiBanChatSenderChatPostRequest) SenderChatId(senderChatId int32) ApiBanChatSenderChatPostRequest {
	r.senderChatId = &senderChatId
	return r
}

func (r ApiBanChatSenderChatPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.BanChatSenderChatPostExecute(r)
}

/*
BanChatSenderChatPost Method for BanChatSenderChatPost

Use this method to ban a channel chat in a supergroup or a channel. Until the chat is [unbanned](https://core.telegram.org/bots/api/#unbanchatsenderchat), the owner of the banned chat won't be able to send messages on behalf of **any of their channels**. The bot must be an administrator in the supergroup or channel for this to work and must have the appropriate administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBanChatSenderChatPostRequest
*/
func (a *DefaultAPIService) BanChatSenderChatPost(ctx context.Context) ApiBanChatSenderChatPostRequest {
	return ApiBanChatSenderChatPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) BanChatSenderChatPostExecute(r ApiBanChatSenderChatPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.BanChatSenderChatPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/banChatSenderChat"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.senderChatId == nil {
		return localVarReturnValue, nil, reportError("senderChatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "sender_chat_id", r.senderChatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCloseForumTopicPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *RestrictChatMemberPostRequestChatId
	messageThreadId *int32
}

func (r ApiCloseForumTopicPostRequest) ChatId(chatId RestrictChatMemberPostRequestChatId) ApiCloseForumTopicPostRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier for the target message thread of the forum topic
func (r ApiCloseForumTopicPostRequest) MessageThreadId(messageThreadId int32) ApiCloseForumTopicPostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

func (r ApiCloseForumTopicPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.CloseForumTopicPostExecute(r)
}

/*
CloseForumTopicPost Method for CloseForumTopicPost

Use this method to close an open topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights, unless it is the creator of the topic. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCloseForumTopicPostRequest
*/
func (a *DefaultAPIService) CloseForumTopicPost(ctx context.Context) ApiCloseForumTopicPostRequest {
	return ApiCloseForumTopicPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) CloseForumTopicPostExecute(r ApiCloseForumTopicPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CloseForumTopicPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/closeForumTopic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.messageThreadId == nil {
		return localVarReturnValue, nil, reportError("messageThreadId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCloseGeneralForumTopicPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *RestrictChatMemberPostRequestChatId
}

func (r ApiCloseGeneralForumTopicPostRequest) ChatId(chatId RestrictChatMemberPostRequestChatId) ApiCloseGeneralForumTopicPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiCloseGeneralForumTopicPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.CloseGeneralForumTopicPostExecute(r)
}

/*
CloseGeneralForumTopicPost Method for CloseGeneralForumTopicPost

Use this method to close an open 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCloseGeneralForumTopicPostRequest
*/
func (a *DefaultAPIService) CloseGeneralForumTopicPost(ctx context.Context) ApiCloseGeneralForumTopicPostRequest {
	return ApiCloseGeneralForumTopicPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) CloseGeneralForumTopicPostExecute(r ApiCloseGeneralForumTopicPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CloseGeneralForumTopicPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/closeGeneralForumTopic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClosePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiClosePostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.ClosePostExecute(r)
}

/*
ClosePost Method for ClosePost

Use this method to close the bot instance before moving it from one local server to another. You need to delete the webhook before calling this method to ensure that the bot isn't launched again after server restart. The method will return error 429 in the first 10 minutes after the bot is launched. Returns *True* on success. Requires no parameters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClosePostRequest
*/
func (a *DefaultAPIService) ClosePost(ctx context.Context) ApiClosePostRequest {
	return ApiClosePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) ClosePostExecute(r ApiClosePostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ClosePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/close"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConvertGiftToStarsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	ownedGiftId *string
}

// Unique identifier of the business connection
func (r ApiConvertGiftToStarsPostRequest) BusinessConnectionId(businessConnectionId string) ApiConvertGiftToStarsPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier of the regular gift that should be converted to Telegram Stars
func (r ApiConvertGiftToStarsPostRequest) OwnedGiftId(ownedGiftId string) ApiConvertGiftToStarsPostRequest {
	r.ownedGiftId = &ownedGiftId
	return r
}

func (r ApiConvertGiftToStarsPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.ConvertGiftToStarsPostExecute(r)
}

/*
ConvertGiftToStarsPost Method for ConvertGiftToStarsPost

Converts a given regular gift to Telegram Stars. Requires the *can\_convert\_gifts\_to\_stars* business bot right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConvertGiftToStarsPostRequest
*/
func (a *DefaultAPIService) ConvertGiftToStarsPost(ctx context.Context) ApiConvertGiftToStarsPostRequest {
	return ApiConvertGiftToStarsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) ConvertGiftToStarsPostExecute(r ApiConvertGiftToStarsPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConvertGiftToStarsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/convertGiftToStars"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.ownedGiftId == nil {
		return localVarReturnValue, nil, reportError("ownedGiftId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "owned_gift_id", r.ownedGiftId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCopyMessagePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	fromChatId *ForwardMessagePostRequestFromChatId
	messageId *int32
	messageThreadId *int32
	videoStartTimestamp *int32
	caption *string
	parseMode *string
	captionEntities *[]MessageEntity
	showCaptionAboveMedia *bool
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	replyParameters *ReplyParameters
	replyMarkup *SendMessagePostRequestReplyMarkup
}

func (r ApiCopyMessagePostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiCopyMessagePostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiCopyMessagePostRequest) FromChatId(fromChatId ForwardMessagePostRequestFromChatId) ApiCopyMessagePostRequest {
	r.fromChatId = &fromChatId
	return r
}

// Message identifier in the chat specified in *from\\\\_chat\\\\_id*
func (r ApiCopyMessagePostRequest) MessageId(messageId int32) ApiCopyMessagePostRequest {
	r.messageId = &messageId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiCopyMessagePostRequest) MessageThreadId(messageThreadId int32) ApiCopyMessagePostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// New start timestamp for the copied video in the message
func (r ApiCopyMessagePostRequest) VideoStartTimestamp(videoStartTimestamp int32) ApiCopyMessagePostRequest {
	r.videoStartTimestamp = &videoStartTimestamp
	return r
}

// New caption for media, 0-1024 characters after entities parsing. If not specified, the original caption is kept
func (r ApiCopyMessagePostRequest) Caption(caption string) ApiCopyMessagePostRequest {
	r.caption = &caption
	return r
}

// Mode for parsing entities in the new caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiCopyMessagePostRequest) ParseMode(parseMode string) ApiCopyMessagePostRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in the new caption, which can be specified instead of *parse\\\\_mode*
func (r ApiCopyMessagePostRequest) CaptionEntities(captionEntities []MessageEntity) ApiCopyMessagePostRequest {
	r.captionEntities = &captionEntities
	return r
}

// Pass *True*, if the caption must be shown above the message media. Ignored if a new caption isn&#39;t specified.
func (r ApiCopyMessagePostRequest) ShowCaptionAboveMedia(showCaptionAboveMedia bool) ApiCopyMessagePostRequest {
	r.showCaptionAboveMedia = &showCaptionAboveMedia
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiCopyMessagePostRequest) DisableNotification(disableNotification bool) ApiCopyMessagePostRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiCopyMessagePostRequest) ProtectContent(protectContent bool) ApiCopyMessagePostRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiCopyMessagePostRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiCopyMessagePostRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

func (r ApiCopyMessagePostRequest) ReplyParameters(replyParameters ReplyParameters) ApiCopyMessagePostRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiCopyMessagePostRequest) ReplyMarkup(replyMarkup SendMessagePostRequestReplyMarkup) ApiCopyMessagePostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiCopyMessagePostRequest) Execute() (*CopyMessagePost200Response, *http.Response, error) {
	return r.ApiService.CopyMessagePostExecute(r)
}

/*
CopyMessagePost Method for CopyMessagePost

Use this method to copy messages of any kind. Service messages, paid media messages, giveaway messages, giveaway winners messages, and invoice messages can't be copied. A quiz [poll](https://core.telegram.org/bots/api/#poll) can be copied only if the value of the field *correct\_option\_id* is known to the bot. The method is analogous to the method [forwardMessage](https://core.telegram.org/bots/api/#forwardmessage), but the copied message doesn't have a link to the original message. Returns the [MessageId](https://core.telegram.org/bots/api/#messageid) of the sent message on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCopyMessagePostRequest
*/
func (a *DefaultAPIService) CopyMessagePost(ctx context.Context) ApiCopyMessagePostRequest {
	return ApiCopyMessagePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CopyMessagePost200Response
func (a *DefaultAPIService) CopyMessagePostExecute(r ApiCopyMessagePostRequest) (*CopyMessagePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CopyMessagePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CopyMessagePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/copyMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.fromChatId == nil {
		return localVarReturnValue, nil, reportError("fromChatId is required and must be specified")
	}
	if r.messageId == nil {
		return localVarReturnValue, nil, reportError("messageId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "from_chat_id", r.fromChatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	if r.videoStartTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "video_start_timestamp", r.videoStartTimestamp, "", "")
	}
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption", r.caption, "", "")
	}
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.captionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption_entities", r.captionEntities, "", "csv")
	}
	if r.showCaptionAboveMedia != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "show_caption_above_media", r.showCaptionAboveMedia, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCopyMessagesPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	fromChatId *ForwardMessagesPostRequestFromChatId
	messageIds *[]int32
	messageThreadId *int32
	disableNotification *bool
	protectContent *bool
	removeCaption *bool
}

func (r ApiCopyMessagesPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiCopyMessagesPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiCopyMessagesPostRequest) FromChatId(fromChatId ForwardMessagesPostRequestFromChatId) ApiCopyMessagesPostRequest {
	r.fromChatId = &fromChatId
	return r
}

// A JSON-serialized list of 1-100 identifiers of messages in the chat *from\\\\_chat\\\\_id* to copy. The identifiers must be specified in a strictly increasing order.
func (r ApiCopyMessagesPostRequest) MessageIds(messageIds []int32) ApiCopyMessagesPostRequest {
	r.messageIds = &messageIds
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiCopyMessagesPostRequest) MessageThreadId(messageThreadId int32) ApiCopyMessagesPostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Sends the messages [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiCopyMessagesPostRequest) DisableNotification(disableNotification bool) ApiCopyMessagesPostRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent messages from forwarding and saving
func (r ApiCopyMessagesPostRequest) ProtectContent(protectContent bool) ApiCopyMessagesPostRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to copy the messages without their captions
func (r ApiCopyMessagesPostRequest) RemoveCaption(removeCaption bool) ApiCopyMessagesPostRequest {
	r.removeCaption = &removeCaption
	return r
}

func (r ApiCopyMessagesPostRequest) Execute() (*ForwardMessagesPost200Response, *http.Response, error) {
	return r.ApiService.CopyMessagesPostExecute(r)
}

/*
CopyMessagesPost Method for CopyMessagesPost

Use this method to copy messages of any kind. If some of the specified messages can't be found or copied, they are skipped. Service messages, paid media messages, giveaway messages, giveaway winners messages, and invoice messages can't be copied. A quiz [poll](https://core.telegram.org/bots/api/#poll) can be copied only if the value of the field *correct\_option\_id* is known to the bot. The method is analogous to the method [forwardMessages](https://core.telegram.org/bots/api/#forwardmessages), but the copied messages don't have a link to the original message. Album grouping is kept for copied messages. On success, an array of [MessageId](https://core.telegram.org/bots/api/#messageid) of the sent messages is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCopyMessagesPostRequest
*/
func (a *DefaultAPIService) CopyMessagesPost(ctx context.Context) ApiCopyMessagesPostRequest {
	return ApiCopyMessagesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ForwardMessagesPost200Response
func (a *DefaultAPIService) CopyMessagesPostExecute(r ApiCopyMessagesPostRequest) (*ForwardMessagesPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ForwardMessagesPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CopyMessagesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/copyMessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.fromChatId == nil {
		return localVarReturnValue, nil, reportError("fromChatId is required and must be specified")
	}
	if r.messageIds == nil {
		return localVarReturnValue, nil, reportError("messageIds is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "from_chat_id", r.fromChatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_ids", r.messageIds, "", "csv")
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.removeCaption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "remove_caption", r.removeCaption, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateChatInviteLinkPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	name *string
	expireDate *int32
	memberLimit *int32
	createsJoinRequest *bool
}

func (r ApiCreateChatInviteLinkPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiCreateChatInviteLinkPostRequest {
	r.chatId = &chatId
	return r
}

// Invite link name; 0-32 characters
func (r ApiCreateChatInviteLinkPostRequest) Name(name string) ApiCreateChatInviteLinkPostRequest {
	r.name = &name
	return r
}

// Point in time (Unix timestamp) when the link will expire
func (r ApiCreateChatInviteLinkPostRequest) ExpireDate(expireDate int32) ApiCreateChatInviteLinkPostRequest {
	r.expireDate = &expireDate
	return r
}

// The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999
func (r ApiCreateChatInviteLinkPostRequest) MemberLimit(memberLimit int32) ApiCreateChatInviteLinkPostRequest {
	r.memberLimit = &memberLimit
	return r
}

// *True*, if users joining the chat via the link need to be approved by chat administrators. If *True*, *member\\\\_limit* can&#39;t be specified
func (r ApiCreateChatInviteLinkPostRequest) CreatesJoinRequest(createsJoinRequest bool) ApiCreateChatInviteLinkPostRequest {
	r.createsJoinRequest = &createsJoinRequest
	return r
}

func (r ApiCreateChatInviteLinkPostRequest) Execute() (*CreateChatInviteLinkPost200Response, *http.Response, error) {
	return r.ApiService.CreateChatInviteLinkPostExecute(r)
}

/*
CreateChatInviteLinkPost Method for CreateChatInviteLinkPost

Use this method to create an additional invite link for a chat. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. The link can be revoked using the method [revokeChatInviteLink](https://core.telegram.org/bots/api/#revokechatinvitelink). Returns the new invite link as [ChatInviteLink](https://core.telegram.org/bots/api/#chatinvitelink) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateChatInviteLinkPostRequest
*/
func (a *DefaultAPIService) CreateChatInviteLinkPost(ctx context.Context) ApiCreateChatInviteLinkPostRequest {
	return ApiCreateChatInviteLinkPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateChatInviteLinkPost200Response
func (a *DefaultAPIService) CreateChatInviteLinkPostExecute(r ApiCreateChatInviteLinkPostRequest) (*CreateChatInviteLinkPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateChatInviteLinkPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateChatInviteLinkPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/createChatInviteLink"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	}
	if r.expireDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "expire_date", r.expireDate, "", "")
	}
	if r.memberLimit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "member_limit", r.memberLimit, "", "")
	}
	if r.createsJoinRequest != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "creates_join_request", r.createsJoinRequest, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateChatSubscriptionInviteLinkPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *CreateChatSubscriptionInviteLinkPostRequestChatId
	subscriptionPeriod *int32
	subscriptionPrice *int32
	name *string
}

func (r ApiCreateChatSubscriptionInviteLinkPostRequest) ChatId(chatId CreateChatSubscriptionInviteLinkPostRequestChatId) ApiCreateChatSubscriptionInviteLinkPostRequest {
	r.chatId = &chatId
	return r
}

// The number of seconds the subscription will be active for before the next payment. Currently, it must always be 2592000 (30 days).
func (r ApiCreateChatSubscriptionInviteLinkPostRequest) SubscriptionPeriod(subscriptionPeriod int32) ApiCreateChatSubscriptionInviteLinkPostRequest {
	r.subscriptionPeriod = &subscriptionPeriod
	return r
}

// The amount of Telegram Stars a user must pay initially and after each subsequent subscription period to be a member of the chat; 1-10000
func (r ApiCreateChatSubscriptionInviteLinkPostRequest) SubscriptionPrice(subscriptionPrice int32) ApiCreateChatSubscriptionInviteLinkPostRequest {
	r.subscriptionPrice = &subscriptionPrice
	return r
}

// Invite link name; 0-32 characters
func (r ApiCreateChatSubscriptionInviteLinkPostRequest) Name(name string) ApiCreateChatSubscriptionInviteLinkPostRequest {
	r.name = &name
	return r
}

func (r ApiCreateChatSubscriptionInviteLinkPostRequest) Execute() (*CreateChatInviteLinkPost200Response, *http.Response, error) {
	return r.ApiService.CreateChatSubscriptionInviteLinkPostExecute(r)
}

/*
CreateChatSubscriptionInviteLinkPost Method for CreateChatSubscriptionInviteLinkPost

Use this method to create a [subscription invite link](https://telegram.org/blog/superchannels-star-reactions-subscriptions#star-subscriptions) for a channel chat. The bot must have the *can\_invite\_users* administrator rights. The link can be edited using the method [editChatSubscriptionInviteLink](https://core.telegram.org/bots/api/#editchatsubscriptioninvitelink) or revoked using the method [revokeChatInviteLink](https://core.telegram.org/bots/api/#revokechatinvitelink). Returns the new invite link as a [ChatInviteLink](https://core.telegram.org/bots/api/#chatinvitelink) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateChatSubscriptionInviteLinkPostRequest
*/
func (a *DefaultAPIService) CreateChatSubscriptionInviteLinkPost(ctx context.Context) ApiCreateChatSubscriptionInviteLinkPostRequest {
	return ApiCreateChatSubscriptionInviteLinkPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateChatInviteLinkPost200Response
func (a *DefaultAPIService) CreateChatSubscriptionInviteLinkPostExecute(r ApiCreateChatSubscriptionInviteLinkPostRequest) (*CreateChatInviteLinkPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateChatInviteLinkPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateChatSubscriptionInviteLinkPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/createChatSubscriptionInviteLink"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.subscriptionPeriod == nil {
		return localVarReturnValue, nil, reportError("subscriptionPeriod is required and must be specified")
	}
	if r.subscriptionPrice == nil {
		return localVarReturnValue, nil, reportError("subscriptionPrice is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "subscription_period", r.subscriptionPeriod, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "subscription_price", r.subscriptionPrice, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateForumTopicPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *RestrictChatMemberPostRequestChatId
	name *string
	iconColor *int32
	iconCustomEmojiId *string
}

func (r ApiCreateForumTopicPostRequest) ChatId(chatId RestrictChatMemberPostRequestChatId) ApiCreateForumTopicPostRequest {
	r.chatId = &chatId
	return r
}

// Topic name, 1-128 characters
func (r ApiCreateForumTopicPostRequest) Name(name string) ApiCreateForumTopicPostRequest {
	r.name = &name
	return r
}

// Color of the topic icon in RGB format. Currently, must be one of 7322096 (0x6FB9F0), 16766590 (0xFFD67E), 13338331 (0xCB86DB), 9367192 (0x8EEE98), 16749490 (0xFF93B2), or 16478047 (0xFB6F5F)
func (r ApiCreateForumTopicPostRequest) IconColor(iconColor int32) ApiCreateForumTopicPostRequest {
	r.iconColor = &iconColor
	return r
}

// Unique identifier of the custom emoji shown as the topic icon. Use [getForumTopicIconStickers](https://core.telegram.org/bots/api/#getforumtopiciconstickers) to get all allowed custom emoji identifiers.
func (r ApiCreateForumTopicPostRequest) IconCustomEmojiId(iconCustomEmojiId string) ApiCreateForumTopicPostRequest {
	r.iconCustomEmojiId = &iconCustomEmojiId
	return r
}

func (r ApiCreateForumTopicPostRequest) Execute() (*CreateForumTopicPost200Response, *http.Response, error) {
	return r.ApiService.CreateForumTopicPostExecute(r)
}

/*
CreateForumTopicPost Method for CreateForumTopicPost

Use this method to create a topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. Returns information about the created topic as a [ForumTopic](https://core.telegram.org/bots/api/#forumtopic) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateForumTopicPostRequest
*/
func (a *DefaultAPIService) CreateForumTopicPost(ctx context.Context) ApiCreateForumTopicPostRequest {
	return ApiCreateForumTopicPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateForumTopicPost200Response
func (a *DefaultAPIService) CreateForumTopicPostExecute(r ApiCreateForumTopicPostRequest) (*CreateForumTopicPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateForumTopicPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateForumTopicPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/createForumTopic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if strlen(*r.name) < 1 {
		return localVarReturnValue, nil, reportError("name must have at least 1 elements")
	}
	if strlen(*r.name) > 128 {
		return localVarReturnValue, nil, reportError("name must have less than 128 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	if r.iconColor != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icon_color", r.iconColor, "", "")
	}
	if r.iconCustomEmojiId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icon_custom_emoji_id", r.iconCustomEmojiId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateInvoiceLinkPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	title *string
	description *string
	payload *string
	currency *string
	prices *[]LabeledPrice
	businessConnectionId *string
	providerToken *string
	subscriptionPeriod *int32
	maxTipAmount *int32
	suggestedTipAmounts *[]int32
	providerData *string
	photoUrl *string
	photoSize *int32
	photoWidth *int32
	photoHeight *int32
	needName *bool
	needPhoneNumber *bool
	needEmail *bool
	needShippingAddress *bool
	sendPhoneNumberToProvider *bool
	sendEmailToProvider *bool
	isFlexible *bool
}

// Product name, 1-32 characters
func (r ApiCreateInvoiceLinkPostRequest) Title(title string) ApiCreateInvoiceLinkPostRequest {
	r.title = &title
	return r
}

// Product description, 1-255 characters
func (r ApiCreateInvoiceLinkPostRequest) Description(description string) ApiCreateInvoiceLinkPostRequest {
	r.description = &description
	return r
}

// Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use it for your internal processes.
func (r ApiCreateInvoiceLinkPostRequest) Payload(payload string) ApiCreateInvoiceLinkPostRequest {
	r.payload = &payload
	return r
}

// Three-letter ISO 4217 currency code, see [more on currencies](https://core.telegram.org/bots/payments#supported-currencies). Pass “XTR” for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiCreateInvoiceLinkPostRequest) Currency(currency string) ApiCreateInvoiceLinkPostRequest {
	r.currency = &currency
	return r
}

// Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.). Must contain exactly one item for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiCreateInvoiceLinkPostRequest) Prices(prices []LabeledPrice) ApiCreateInvoiceLinkPostRequest {
	r.prices = &prices
	return r
}

// Unique identifier of the business connection on behalf of which the link will be created. For payments in [Telegram Stars](https://t.me/BotNews/90) only.
func (r ApiCreateInvoiceLinkPostRequest) BusinessConnectionId(businessConnectionId string) ApiCreateInvoiceLinkPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Payment provider token, obtained via [@BotFather](https://t.me/botfather). Pass an empty string for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiCreateInvoiceLinkPostRequest) ProviderToken(providerToken string) ApiCreateInvoiceLinkPostRequest {
	r.providerToken = &providerToken
	return r
}

// The number of seconds the subscription will be active for before the next payment. The currency must be set to “XTR” (Telegram Stars) if the parameter is used. Currently, it must always be 2592000 (30 days) if specified. Any number of subscriptions can be active for a given bot at the same time, including multiple concurrent subscriptions from the same user. Subscription price must no exceed 10000 Telegram Stars.
func (r ApiCreateInvoiceLinkPostRequest) SubscriptionPeriod(subscriptionPeriod int32) ApiCreateInvoiceLinkPostRequest {
	r.subscriptionPeriod = &subscriptionPeriod
	return r
}

// The maximum accepted amount for tips in the *smallest units* of the currency (integer, **not** float/double). For example, for a maximum tip of &#x60;US$ 1.45&#x60; pass &#x60;max_tip_amount &#x3D; 145&#x60;. See the *exp* parameter in [currencies.json](https://core.telegram.org/bots/payments/currencies.json), it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0. Not supported for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiCreateInvoiceLinkPostRequest) MaxTipAmount(maxTipAmount int32) ApiCreateInvoiceLinkPostRequest {
	r.maxTipAmount = &maxTipAmount
	return r
}

// A JSON-serialized array of suggested amounts of tips in the *smallest units* of the currency (integer, **not** float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed *max\\\\_tip\\\\_amount*.
func (r ApiCreateInvoiceLinkPostRequest) SuggestedTipAmounts(suggestedTipAmounts []int32) ApiCreateInvoiceLinkPostRequest {
	r.suggestedTipAmounts = &suggestedTipAmounts
	return r
}

// JSON-serialized data about the invoice, which will be shared with the payment provider. A detailed description of required fields should be provided by the payment provider.
func (r ApiCreateInvoiceLinkPostRequest) ProviderData(providerData string) ApiCreateInvoiceLinkPostRequest {
	r.providerData = &providerData
	return r
}

// URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service.
func (r ApiCreateInvoiceLinkPostRequest) PhotoUrl(photoUrl string) ApiCreateInvoiceLinkPostRequest {
	r.photoUrl = &photoUrl
	return r
}

// Photo size in bytes
func (r ApiCreateInvoiceLinkPostRequest) PhotoSize(photoSize int32) ApiCreateInvoiceLinkPostRequest {
	r.photoSize = &photoSize
	return r
}

// Photo width
func (r ApiCreateInvoiceLinkPostRequest) PhotoWidth(photoWidth int32) ApiCreateInvoiceLinkPostRequest {
	r.photoWidth = &photoWidth
	return r
}

// Photo height
func (r ApiCreateInvoiceLinkPostRequest) PhotoHeight(photoHeight int32) ApiCreateInvoiceLinkPostRequest {
	r.photoHeight = &photoHeight
	return r
}

// Pass *True* if you require the user&#39;s full name to complete the order. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiCreateInvoiceLinkPostRequest) NeedName(needName bool) ApiCreateInvoiceLinkPostRequest {
	r.needName = &needName
	return r
}

// Pass *True* if you require the user&#39;s phone number to complete the order. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiCreateInvoiceLinkPostRequest) NeedPhoneNumber(needPhoneNumber bool) ApiCreateInvoiceLinkPostRequest {
	r.needPhoneNumber = &needPhoneNumber
	return r
}

// Pass *True* if you require the user&#39;s email address to complete the order. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiCreateInvoiceLinkPostRequest) NeedEmail(needEmail bool) ApiCreateInvoiceLinkPostRequest {
	r.needEmail = &needEmail
	return r
}

// Pass *True* if you require the user&#39;s shipping address to complete the order. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiCreateInvoiceLinkPostRequest) NeedShippingAddress(needShippingAddress bool) ApiCreateInvoiceLinkPostRequest {
	r.needShippingAddress = &needShippingAddress
	return r
}

// Pass *True* if the user&#39;s phone number should be sent to the provider. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiCreateInvoiceLinkPostRequest) SendPhoneNumberToProvider(sendPhoneNumberToProvider bool) ApiCreateInvoiceLinkPostRequest {
	r.sendPhoneNumberToProvider = &sendPhoneNumberToProvider
	return r
}

// Pass *True* if the user&#39;s email address should be sent to the provider. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiCreateInvoiceLinkPostRequest) SendEmailToProvider(sendEmailToProvider bool) ApiCreateInvoiceLinkPostRequest {
	r.sendEmailToProvider = &sendEmailToProvider
	return r
}

// Pass *True* if the final price depends on the shipping method. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiCreateInvoiceLinkPostRequest) IsFlexible(isFlexible bool) ApiCreateInvoiceLinkPostRequest {
	r.isFlexible = &isFlexible
	return r
}

func (r ApiCreateInvoiceLinkPostRequest) Execute() (*ExportChatInviteLinkPost200Response, *http.Response, error) {
	return r.ApiService.CreateInvoiceLinkPostExecute(r)
}

/*
CreateInvoiceLinkPost Method for CreateInvoiceLinkPost

Use this method to create a link for an invoice. Returns the created invoice link as *String* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateInvoiceLinkPostRequest
*/
func (a *DefaultAPIService) CreateInvoiceLinkPost(ctx context.Context) ApiCreateInvoiceLinkPostRequest {
	return ApiCreateInvoiceLinkPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExportChatInviteLinkPost200Response
func (a *DefaultAPIService) CreateInvoiceLinkPostExecute(r ApiCreateInvoiceLinkPostRequest) (*ExportChatInviteLinkPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportChatInviteLinkPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateInvoiceLinkPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/createInvoiceLink"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if strlen(*r.title) < 1 {
		return localVarReturnValue, nil, reportError("title must have at least 1 elements")
	}
	if strlen(*r.title) > 32 {
		return localVarReturnValue, nil, reportError("title must have less than 32 elements")
	}
	if r.description == nil {
		return localVarReturnValue, nil, reportError("description is required and must be specified")
	}
	if strlen(*r.description) < 1 {
		return localVarReturnValue, nil, reportError("description must have at least 1 elements")
	}
	if strlen(*r.description) > 255 {
		return localVarReturnValue, nil, reportError("description must have less than 255 elements")
	}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}
	if r.currency == nil {
		return localVarReturnValue, nil, reportError("currency is required and must be specified")
	}
	if r.prices == nil {
		return localVarReturnValue, nil, reportError("prices is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "payload", r.payload, "", "")
	if r.providerToken != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "provider_token", r.providerToken, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "currency", r.currency, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "prices", r.prices, "", "csv")
	if r.subscriptionPeriod != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "subscription_period", r.subscriptionPeriod, "", "")
	}
	if r.maxTipAmount != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "max_tip_amount", r.maxTipAmount, "", "")
	}
	if r.suggestedTipAmounts != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "suggested_tip_amounts", r.suggestedTipAmounts, "", "csv")
	}
	if r.providerData != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "provider_data", r.providerData, "", "")
	}
	if r.photoUrl != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "photo_url", r.photoUrl, "", "")
	}
	if r.photoSize != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "photo_size", r.photoSize, "", "")
	}
	if r.photoWidth != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "photo_width", r.photoWidth, "", "")
	}
	if r.photoHeight != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "photo_height", r.photoHeight, "", "")
	}
	if r.needName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "need_name", r.needName, "", "")
	}
	if r.needPhoneNumber != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "need_phone_number", r.needPhoneNumber, "", "")
	}
	if r.needEmail != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "need_email", r.needEmail, "", "")
	}
	if r.needShippingAddress != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "need_shipping_address", r.needShippingAddress, "", "")
	}
	if r.sendPhoneNumberToProvider != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "send_phone_number_to_provider", r.sendPhoneNumberToProvider, "", "")
	}
	if r.sendEmailToProvider != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "send_email_to_provider", r.sendEmailToProvider, "", "")
	}
	if r.isFlexible != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_flexible", r.isFlexible, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateNewStickerSetPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	name *string
	title *string
	stickers *[]InputSticker
	stickerType *string
	needsRepainting *bool
}

// User identifier of created sticker set owner
func (r ApiCreateNewStickerSetPostRequest) UserId(userId int32) ApiCreateNewStickerSetPostRequest {
	r.userId = &userId
	return r
}

// Short name of sticker set, to be used in &#x60;t.me/addstickers/&#x60; URLs (e.g., *animals*). Can contain only English letters, digits and underscores. Must begin with a letter, can&#39;t contain consecutive underscores and must end in &#x60;\\\&quot;_by_&lt;bot_username&gt;\\\&quot;&#x60;. &#x60;&lt;bot_username&gt;&#x60; is case insensitive. 1-64 characters.
func (r ApiCreateNewStickerSetPostRequest) Name(name string) ApiCreateNewStickerSetPostRequest {
	r.name = &name
	return r
}

// Sticker set title, 1-64 characters
func (r ApiCreateNewStickerSetPostRequest) Title(title string) ApiCreateNewStickerSetPostRequest {
	r.title = &title
	return r
}

// A JSON-serialized list of 1-50 initial stickers to be added to the sticker set
func (r ApiCreateNewStickerSetPostRequest) Stickers(stickers []InputSticker) ApiCreateNewStickerSetPostRequest {
	r.stickers = &stickers
	return r
}

// Type of stickers in the set, pass “regular”, “mask”, or “custom\\\\_emoji”. By default, a regular sticker set is created.
func (r ApiCreateNewStickerSetPostRequest) StickerType(stickerType string) ApiCreateNewStickerSetPostRequest {
	r.stickerType = &stickerType
	return r
}

// Pass *True* if stickers in the sticker set must be repainted to the color of text when used in messages, the accent color if used as emoji status, white on chat photos, or another appropriate color based on context; for custom emoji sticker sets only
func (r ApiCreateNewStickerSetPostRequest) NeedsRepainting(needsRepainting bool) ApiCreateNewStickerSetPostRequest {
	r.needsRepainting = &needsRepainting
	return r
}

func (r ApiCreateNewStickerSetPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.CreateNewStickerSetPostExecute(r)
}

/*
CreateNewStickerSetPost Method for CreateNewStickerSetPost

Use this method to create a new sticker set owned by a user. The bot will be able to edit the sticker set thus created. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateNewStickerSetPostRequest
*/
func (a *DefaultAPIService) CreateNewStickerSetPost(ctx context.Context) ApiCreateNewStickerSetPostRequest {
	return ApiCreateNewStickerSetPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) CreateNewStickerSetPostExecute(r ApiCreateNewStickerSetPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateNewStickerSetPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/createNewStickerSet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if strlen(*r.name) < 1 {
		return localVarReturnValue, nil, reportError("name must have at least 1 elements")
	}
	if strlen(*r.name) > 64 {
		return localVarReturnValue, nil, reportError("name must have less than 64 elements")
	}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if strlen(*r.title) < 1 {
		return localVarReturnValue, nil, reportError("title must have at least 1 elements")
	}
	if strlen(*r.title) > 64 {
		return localVarReturnValue, nil, reportError("title must have less than 64 elements")
	}
	if r.stickers == nil {
		return localVarReturnValue, nil, reportError("stickers is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "stickers", r.stickers, "", "csv")
	if r.stickerType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "sticker_type", r.stickerType, "", "")
	}
	if r.needsRepainting != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "needs_repainting", r.needsRepainting, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeclineChatJoinRequestPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	userId *int32
}

func (r ApiDeclineChatJoinRequestPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiDeclineChatJoinRequestPostRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the target user
func (r ApiDeclineChatJoinRequestPostRequest) UserId(userId int32) ApiDeclineChatJoinRequestPostRequest {
	r.userId = &userId
	return r
}

func (r ApiDeclineChatJoinRequestPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.DeclineChatJoinRequestPostExecute(r)
}

/*
DeclineChatJoinRequestPost Method for DeclineChatJoinRequestPost

Use this method to decline a chat join request. The bot must be an administrator in the chat for this to work and must have the *can\_invite\_users* administrator right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeclineChatJoinRequestPostRequest
*/
func (a *DefaultAPIService) DeclineChatJoinRequestPost(ctx context.Context) ApiDeclineChatJoinRequestPostRequest {
	return ApiDeclineChatJoinRequestPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) DeclineChatJoinRequestPostExecute(r ApiDeclineChatJoinRequestPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeclineChatJoinRequestPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/declineChatJoinRequest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBusinessMessagesPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	messageIds *[]int32
}

// Unique identifier of the business connection on behalf of which to delete the messages
func (r ApiDeleteBusinessMessagesPostRequest) BusinessConnectionId(businessConnectionId string) ApiDeleteBusinessMessagesPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// A JSON-serialized list of 1-100 identifiers of messages to delete. All messages must be from the same chat. See [deleteMessage](https://core.telegram.org/bots/api/#deletemessage) for limitations on which messages can be deleted
func (r ApiDeleteBusinessMessagesPostRequest) MessageIds(messageIds []int32) ApiDeleteBusinessMessagesPostRequest {
	r.messageIds = &messageIds
	return r
}

func (r ApiDeleteBusinessMessagesPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.DeleteBusinessMessagesPostExecute(r)
}

/*
DeleteBusinessMessagesPost Method for DeleteBusinessMessagesPost

Delete messages on behalf of a business account. Requires the *can\_delete\_sent\_messages* business bot right to delete messages sent by the bot itself, or the *can\_delete\_all\_messages* business bot right to delete any message. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteBusinessMessagesPostRequest
*/
func (a *DefaultAPIService) DeleteBusinessMessagesPost(ctx context.Context) ApiDeleteBusinessMessagesPostRequest {
	return ApiDeleteBusinessMessagesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) DeleteBusinessMessagesPostExecute(r ApiDeleteBusinessMessagesPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteBusinessMessagesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteBusinessMessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.messageIds == nil {
		return localVarReturnValue, nil, reportError("messageIds is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_ids", r.messageIds, "", "csv")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChatPhotoPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
}

func (r ApiDeleteChatPhotoPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiDeleteChatPhotoPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiDeleteChatPhotoPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.DeleteChatPhotoPostExecute(r)
}

/*
DeleteChatPhotoPost Method for DeleteChatPhotoPost

Use this method to delete a chat photo. Photos can't be changed for private chats. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteChatPhotoPostRequest
*/
func (a *DefaultAPIService) DeleteChatPhotoPost(ctx context.Context) ApiDeleteChatPhotoPostRequest {
	return ApiDeleteChatPhotoPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) DeleteChatPhotoPostExecute(r ApiDeleteChatPhotoPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteChatPhotoPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteChatPhoto"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChatStickerSetPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *RestrictChatMemberPostRequestChatId
}

func (r ApiDeleteChatStickerSetPostRequest) ChatId(chatId RestrictChatMemberPostRequestChatId) ApiDeleteChatStickerSetPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiDeleteChatStickerSetPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.DeleteChatStickerSetPostExecute(r)
}

/*
DeleteChatStickerSetPost Method for DeleteChatStickerSetPost

Use this method to delete a group sticker set from a supergroup. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Use the field *can\_set\_sticker\_set* optionally returned in [getChat](https://core.telegram.org/bots/api/#getchat) requests to check if the bot can use this method. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteChatStickerSetPostRequest
*/
func (a *DefaultAPIService) DeleteChatStickerSetPost(ctx context.Context) ApiDeleteChatStickerSetPostRequest {
	return ApiDeleteChatStickerSetPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) DeleteChatStickerSetPostExecute(r ApiDeleteChatStickerSetPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteChatStickerSetPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteChatStickerSet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteForumTopicPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *RestrictChatMemberPostRequestChatId
	messageThreadId *int32
}

func (r ApiDeleteForumTopicPostRequest) ChatId(chatId RestrictChatMemberPostRequestChatId) ApiDeleteForumTopicPostRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier for the target message thread of the forum topic
func (r ApiDeleteForumTopicPostRequest) MessageThreadId(messageThreadId int32) ApiDeleteForumTopicPostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

func (r ApiDeleteForumTopicPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.DeleteForumTopicPostExecute(r)
}

/*
DeleteForumTopicPost Method for DeleteForumTopicPost

Use this method to delete a forum topic along with all its messages in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_delete\_messages* administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteForumTopicPostRequest
*/
func (a *DefaultAPIService) DeleteForumTopicPost(ctx context.Context) ApiDeleteForumTopicPostRequest {
	return ApiDeleteForumTopicPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) DeleteForumTopicPostExecute(r ApiDeleteForumTopicPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteForumTopicPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteForumTopic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.messageThreadId == nil {
		return localVarReturnValue, nil, reportError("messageThreadId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteMessagePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	messageId *int32
}

func (r ApiDeleteMessagePostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiDeleteMessagePostRequest {
	r.chatId = &chatId
	return r
}

// Identifier of the message to delete
func (r ApiDeleteMessagePostRequest) MessageId(messageId int32) ApiDeleteMessagePostRequest {
	r.messageId = &messageId
	return r
}

func (r ApiDeleteMessagePostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.DeleteMessagePostExecute(r)
}

/*
DeleteMessagePost Method for DeleteMessagePost

Use this method to delete a message, including service messages, with the following limitations:  
\- A message can only be deleted if it was sent less than 48 hours ago.  
\- Service messages about a supergroup, channel, or forum topic creation can't be deleted.  
\- A dice message in a private chat can only be deleted if it was sent more than 24 hours ago.  
\- Bots can delete outgoing messages in private chats, groups, and supergroups.  
\- Bots can delete incoming messages in private chats.  
\- Bots granted *can\_post\_messages* permissions can delete outgoing messages in channels.  
\- If the bot is an administrator of a group, it can delete any message there.  
\- If the bot has *can\_delete\_messages* permission in a supergroup or a channel, it can delete any message there.  
Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteMessagePostRequest
*/
func (a *DefaultAPIService) DeleteMessagePost(ctx context.Context) ApiDeleteMessagePostRequest {
	return ApiDeleteMessagePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) DeleteMessagePostExecute(r ApiDeleteMessagePostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteMessagePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.messageId == nil {
		return localVarReturnValue, nil, reportError("messageId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteMessagesPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	messageIds *[]int32
}

func (r ApiDeleteMessagesPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiDeleteMessagesPostRequest {
	r.chatId = &chatId
	return r
}

// A JSON-serialized list of 1-100 identifiers of messages to delete. See [deleteMessage](https://core.telegram.org/bots/api/#deletemessage) for limitations on which messages can be deleted
func (r ApiDeleteMessagesPostRequest) MessageIds(messageIds []int32) ApiDeleteMessagesPostRequest {
	r.messageIds = &messageIds
	return r
}

func (r ApiDeleteMessagesPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.DeleteMessagesPostExecute(r)
}

/*
DeleteMessagesPost Method for DeleteMessagesPost

Use this method to delete multiple messages simultaneously. If some of the specified messages can't be found, they are skipped. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteMessagesPostRequest
*/
func (a *DefaultAPIService) DeleteMessagesPost(ctx context.Context) ApiDeleteMessagesPostRequest {
	return ApiDeleteMessagesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) DeleteMessagesPostExecute(r ApiDeleteMessagesPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteMessagesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteMessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.messageIds == nil {
		return localVarReturnValue, nil, reportError("messageIds is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_ids", r.messageIds, "", "csv")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteMyCommandsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	scope *BotCommandScope
	languageCode *string
}

func (r ApiDeleteMyCommandsPostRequest) Scope(scope BotCommandScope) ApiDeleteMyCommandsPostRequest {
	r.scope = &scope
	return r
}

// A two-letter ISO 639-1 language code. If empty, commands will be applied to all users from the given scope, for whose language there are no dedicated commands
func (r ApiDeleteMyCommandsPostRequest) LanguageCode(languageCode string) ApiDeleteMyCommandsPostRequest {
	r.languageCode = &languageCode
	return r
}

func (r ApiDeleteMyCommandsPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.DeleteMyCommandsPostExecute(r)
}

/*
DeleteMyCommandsPost Method for DeleteMyCommandsPost

Use this method to delete the list of the bot's commands for the given scope and user language. After deletion, [higher level commands](https://core.telegram.org/bots/api/#determining-list-of-commands) will be shown to affected users. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteMyCommandsPostRequest
*/
func (a *DefaultAPIService) DeleteMyCommandsPost(ctx context.Context) ApiDeleteMyCommandsPostRequest {
	return ApiDeleteMyCommandsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) DeleteMyCommandsPostExecute(r ApiDeleteMyCommandsPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteMyCommandsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteMyCommands"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.scope != nil {
		paramJson, err := parameterToJson(*r.scope)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("scope", paramJson)
	}
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "language_code", r.languageCode, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteStickerFromSetPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	sticker *string
}

// File identifier of the sticker
func (r ApiDeleteStickerFromSetPostRequest) Sticker(sticker string) ApiDeleteStickerFromSetPostRequest {
	r.sticker = &sticker
	return r
}

func (r ApiDeleteStickerFromSetPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.DeleteStickerFromSetPostExecute(r)
}

/*
DeleteStickerFromSetPost Method for DeleteStickerFromSetPost

Use this method to delete a sticker from a set created by the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteStickerFromSetPostRequest
*/
func (a *DefaultAPIService) DeleteStickerFromSetPost(ctx context.Context) ApiDeleteStickerFromSetPostRequest {
	return ApiDeleteStickerFromSetPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) DeleteStickerFromSetPostExecute(r ApiDeleteStickerFromSetPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteStickerFromSetPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteStickerFromSet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sticker == nil {
		return localVarReturnValue, nil, reportError("sticker is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "sticker", r.sticker, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteStickerSetPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	name *string
}

// Sticker set name
func (r ApiDeleteStickerSetPostRequest) Name(name string) ApiDeleteStickerSetPostRequest {
	r.name = &name
	return r
}

func (r ApiDeleteStickerSetPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.DeleteStickerSetPostExecute(r)
}

/*
DeleteStickerSetPost Method for DeleteStickerSetPost

Use this method to delete a sticker set that was created by the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteStickerSetPostRequest
*/
func (a *DefaultAPIService) DeleteStickerSetPost(ctx context.Context) ApiDeleteStickerSetPostRequest {
	return ApiDeleteStickerSetPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) DeleteStickerSetPostExecute(r ApiDeleteStickerSetPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteStickerSetPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteStickerSet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteStoryPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	storyId *int32
}

// Unique identifier of the business connection
func (r ApiDeleteStoryPostRequest) BusinessConnectionId(businessConnectionId string) ApiDeleteStoryPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier of the story to delete
func (r ApiDeleteStoryPostRequest) StoryId(storyId int32) ApiDeleteStoryPostRequest {
	r.storyId = &storyId
	return r
}

func (r ApiDeleteStoryPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.DeleteStoryPostExecute(r)
}

/*
DeleteStoryPost Method for DeleteStoryPost

Deletes a story previously posted by the bot on behalf of a managed business account. Requires the *can\_manage\_stories* business bot right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteStoryPostRequest
*/
func (a *DefaultAPIService) DeleteStoryPost(ctx context.Context) ApiDeleteStoryPostRequest {
	return ApiDeleteStoryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) DeleteStoryPostExecute(r ApiDeleteStoryPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteStoryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteStory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.storyId == nil {
		return localVarReturnValue, nil, reportError("storyId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "story_id", r.storyId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteWebhookPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	dropPendingUpdates *bool
}

// Pass *True* to drop all pending updates
func (r ApiDeleteWebhookPostRequest) DropPendingUpdates(dropPendingUpdates bool) ApiDeleteWebhookPostRequest {
	r.dropPendingUpdates = &dropPendingUpdates
	return r
}

func (r ApiDeleteWebhookPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.DeleteWebhookPostExecute(r)
}

/*
DeleteWebhookPost Method for DeleteWebhookPost

Use this method to remove webhook integration if you decide to switch back to [getUpdates](https://core.telegram.org/bots/api/#getupdates). Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteWebhookPostRequest
*/
func (a *DefaultAPIService) DeleteWebhookPost(ctx context.Context) ApiDeleteWebhookPostRequest {
	return ApiDeleteWebhookPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) DeleteWebhookPostExecute(r ApiDeleteWebhookPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteWebhookPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteWebhook"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.dropPendingUpdates != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "drop_pending_updates", r.dropPendingUpdates, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEditChatInviteLinkPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	inviteLink *string
	name *string
	expireDate *int32
	memberLimit *int32
	createsJoinRequest *bool
}

func (r ApiEditChatInviteLinkPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiEditChatInviteLinkPostRequest {
	r.chatId = &chatId
	return r
}

// The invite link to edit
func (r ApiEditChatInviteLinkPostRequest) InviteLink(inviteLink string) ApiEditChatInviteLinkPostRequest {
	r.inviteLink = &inviteLink
	return r
}

// Invite link name; 0-32 characters
func (r ApiEditChatInviteLinkPostRequest) Name(name string) ApiEditChatInviteLinkPostRequest {
	r.name = &name
	return r
}

// Point in time (Unix timestamp) when the link will expire
func (r ApiEditChatInviteLinkPostRequest) ExpireDate(expireDate int32) ApiEditChatInviteLinkPostRequest {
	r.expireDate = &expireDate
	return r
}

// The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999
func (r ApiEditChatInviteLinkPostRequest) MemberLimit(memberLimit int32) ApiEditChatInviteLinkPostRequest {
	r.memberLimit = &memberLimit
	return r
}

// *True*, if users joining the chat via the link need to be approved by chat administrators. If *True*, *member\\\\_limit* can&#39;t be specified
func (r ApiEditChatInviteLinkPostRequest) CreatesJoinRequest(createsJoinRequest bool) ApiEditChatInviteLinkPostRequest {
	r.createsJoinRequest = &createsJoinRequest
	return r
}

func (r ApiEditChatInviteLinkPostRequest) Execute() (*CreateChatInviteLinkPost200Response, *http.Response, error) {
	return r.ApiService.EditChatInviteLinkPostExecute(r)
}

/*
EditChatInviteLinkPost Method for EditChatInviteLinkPost

Use this method to edit a non-primary invite link created by the bot. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns the edited invite link as a [ChatInviteLink](https://core.telegram.org/bots/api/#chatinvitelink) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEditChatInviteLinkPostRequest
*/
func (a *DefaultAPIService) EditChatInviteLinkPost(ctx context.Context) ApiEditChatInviteLinkPostRequest {
	return ApiEditChatInviteLinkPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateChatInviteLinkPost200Response
func (a *DefaultAPIService) EditChatInviteLinkPostExecute(r ApiEditChatInviteLinkPostRequest) (*CreateChatInviteLinkPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateChatInviteLinkPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EditChatInviteLinkPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editChatInviteLink"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.inviteLink == nil {
		return localVarReturnValue, nil, reportError("inviteLink is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "invite_link", r.inviteLink, "", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	}
	if r.expireDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "expire_date", r.expireDate, "", "")
	}
	if r.memberLimit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "member_limit", r.memberLimit, "", "")
	}
	if r.createsJoinRequest != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "creates_join_request", r.createsJoinRequest, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEditChatSubscriptionInviteLinkPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	inviteLink *string
	name *string
}

func (r ApiEditChatSubscriptionInviteLinkPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiEditChatSubscriptionInviteLinkPostRequest {
	r.chatId = &chatId
	return r
}

// The invite link to edit
func (r ApiEditChatSubscriptionInviteLinkPostRequest) InviteLink(inviteLink string) ApiEditChatSubscriptionInviteLinkPostRequest {
	r.inviteLink = &inviteLink
	return r
}

// Invite link name; 0-32 characters
func (r ApiEditChatSubscriptionInviteLinkPostRequest) Name(name string) ApiEditChatSubscriptionInviteLinkPostRequest {
	r.name = &name
	return r
}

func (r ApiEditChatSubscriptionInviteLinkPostRequest) Execute() (*CreateChatInviteLinkPost200Response, *http.Response, error) {
	return r.ApiService.EditChatSubscriptionInviteLinkPostExecute(r)
}

/*
EditChatSubscriptionInviteLinkPost Method for EditChatSubscriptionInviteLinkPost

Use this method to edit a subscription invite link created by the bot. The bot must have the *can\_invite\_users* administrator rights. Returns the edited invite link as a [ChatInviteLink](https://core.telegram.org/bots/api/#chatinvitelink) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEditChatSubscriptionInviteLinkPostRequest
*/
func (a *DefaultAPIService) EditChatSubscriptionInviteLinkPost(ctx context.Context) ApiEditChatSubscriptionInviteLinkPostRequest {
	return ApiEditChatSubscriptionInviteLinkPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateChatInviteLinkPost200Response
func (a *DefaultAPIService) EditChatSubscriptionInviteLinkPostExecute(r ApiEditChatSubscriptionInviteLinkPostRequest) (*CreateChatInviteLinkPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateChatInviteLinkPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EditChatSubscriptionInviteLinkPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editChatSubscriptionInviteLink"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.inviteLink == nil {
		return localVarReturnValue, nil, reportError("inviteLink is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "invite_link", r.inviteLink, "", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEditForumTopicPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *RestrictChatMemberPostRequestChatId
	messageThreadId *int32
	name *string
	iconCustomEmojiId *string
}

func (r ApiEditForumTopicPostRequest) ChatId(chatId RestrictChatMemberPostRequestChatId) ApiEditForumTopicPostRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier for the target message thread of the forum topic
func (r ApiEditForumTopicPostRequest) MessageThreadId(messageThreadId int32) ApiEditForumTopicPostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// New topic name, 0-128 characters. If not specified or empty, the current name of the topic will be kept
func (r ApiEditForumTopicPostRequest) Name(name string) ApiEditForumTopicPostRequest {
	r.name = &name
	return r
}

// New unique identifier of the custom emoji shown as the topic icon. Use [getForumTopicIconStickers](https://core.telegram.org/bots/api/#getforumtopiciconstickers) to get all allowed custom emoji identifiers. Pass an empty string to remove the icon. If not specified, the current icon will be kept
func (r ApiEditForumTopicPostRequest) IconCustomEmojiId(iconCustomEmojiId string) ApiEditForumTopicPostRequest {
	r.iconCustomEmojiId = &iconCustomEmojiId
	return r
}

func (r ApiEditForumTopicPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.EditForumTopicPostExecute(r)
}

/*
EditForumTopicPost Method for EditForumTopicPost

Use this method to edit name and icon of a topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights, unless it is the creator of the topic. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEditForumTopicPostRequest
*/
func (a *DefaultAPIService) EditForumTopicPost(ctx context.Context) ApiEditForumTopicPostRequest {
	return ApiEditForumTopicPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) EditForumTopicPostExecute(r ApiEditForumTopicPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EditForumTopicPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editForumTopic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.messageThreadId == nil {
		return localVarReturnValue, nil, reportError("messageThreadId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	}
	if r.iconCustomEmojiId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "icon_custom_emoji_id", r.iconCustomEmojiId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEditGeneralForumTopicPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *RestrictChatMemberPostRequestChatId
	name *string
}

func (r ApiEditGeneralForumTopicPostRequest) ChatId(chatId RestrictChatMemberPostRequestChatId) ApiEditGeneralForumTopicPostRequest {
	r.chatId = &chatId
	return r
}

// New topic name, 1-128 characters
func (r ApiEditGeneralForumTopicPostRequest) Name(name string) ApiEditGeneralForumTopicPostRequest {
	r.name = &name
	return r
}

func (r ApiEditGeneralForumTopicPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.EditGeneralForumTopicPostExecute(r)
}

/*
EditGeneralForumTopicPost Method for EditGeneralForumTopicPost

Use this method to edit the name of the 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEditGeneralForumTopicPostRequest
*/
func (a *DefaultAPIService) EditGeneralForumTopicPost(ctx context.Context) ApiEditGeneralForumTopicPostRequest {
	return ApiEditGeneralForumTopicPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) EditGeneralForumTopicPostExecute(r ApiEditGeneralForumTopicPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EditGeneralForumTopicPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editGeneralForumTopic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if strlen(*r.name) < 1 {
		return localVarReturnValue, nil, reportError("name must have at least 1 elements")
	}
	if strlen(*r.name) > 128 {
		return localVarReturnValue, nil, reportError("name must have less than 128 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEditMessageCaptionPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	chatId *EditMessageTextPostRequestChatId
	messageId *int32
	inlineMessageId *string
	caption *string
	parseMode *string
	captionEntities *[]MessageEntity
	showCaptionAboveMedia *bool
	replyMarkup *InlineKeyboardMarkup
}

// Unique identifier of the business connection on behalf of which the message to be edited was sent
func (r ApiEditMessageCaptionPostRequest) BusinessConnectionId(businessConnectionId string) ApiEditMessageCaptionPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

func (r ApiEditMessageCaptionPostRequest) ChatId(chatId EditMessageTextPostRequestChatId) ApiEditMessageCaptionPostRequest {
	r.chatId = &chatId
	return r
}

// Required if *inline\\\\_message\\\\_id* is not specified. Identifier of the message to edit
func (r ApiEditMessageCaptionPostRequest) MessageId(messageId int32) ApiEditMessageCaptionPostRequest {
	r.messageId = &messageId
	return r
}

// Required if *chat\\\\_id* and *message\\\\_id* are not specified. Identifier of the inline message
func (r ApiEditMessageCaptionPostRequest) InlineMessageId(inlineMessageId string) ApiEditMessageCaptionPostRequest {
	r.inlineMessageId = &inlineMessageId
	return r
}

// New caption of the message, 0-1024 characters after entities parsing
func (r ApiEditMessageCaptionPostRequest) Caption(caption string) ApiEditMessageCaptionPostRequest {
	r.caption = &caption
	return r
}

// Mode for parsing entities in the message caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiEditMessageCaptionPostRequest) ParseMode(parseMode string) ApiEditMessageCaptionPostRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of *parse\\\\_mode*
func (r ApiEditMessageCaptionPostRequest) CaptionEntities(captionEntities []MessageEntity) ApiEditMessageCaptionPostRequest {
	r.captionEntities = &captionEntities
	return r
}

// Pass *True*, if the caption must be shown above the message media. Supported only for animation, photo and video messages.
func (r ApiEditMessageCaptionPostRequest) ShowCaptionAboveMedia(showCaptionAboveMedia bool) ApiEditMessageCaptionPostRequest {
	r.showCaptionAboveMedia = &showCaptionAboveMedia
	return r
}

func (r ApiEditMessageCaptionPostRequest) ReplyMarkup(replyMarkup InlineKeyboardMarkup) ApiEditMessageCaptionPostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiEditMessageCaptionPostRequest) Execute() (*EditMessageTextPost200Response, *http.Response, error) {
	return r.ApiService.EditMessageCaptionPostExecute(r)
}

/*
EditMessageCaptionPost Method for EditMessageCaptionPost

Use this method to edit captions of messages. On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned. Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within **48 hours** from the time they were sent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEditMessageCaptionPostRequest
*/
func (a *DefaultAPIService) EditMessageCaptionPost(ctx context.Context) ApiEditMessageCaptionPostRequest {
	return ApiEditMessageCaptionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EditMessageTextPost200Response
func (a *DefaultAPIService) EditMessageCaptionPostExecute(r ApiEditMessageCaptionPostRequest) (*EditMessageTextPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EditMessageTextPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EditMessageCaptionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editMessageCaption"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	if r.chatId != nil {
		paramJson, err := parameterToJson(*r.chatId)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("chat_id", paramJson)
	}
	if r.messageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	}
	if r.inlineMessageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "inline_message_id", r.inlineMessageId, "", "")
	}
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption", r.caption, "", "")
	}
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.captionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption_entities", r.captionEntities, "", "csv")
	}
	if r.showCaptionAboveMedia != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "show_caption_above_media", r.showCaptionAboveMedia, "", "")
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEditMessageLiveLocationPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	latitude *float32
	longitude *float32
	businessConnectionId *string
	chatId *EditMessageTextPostRequestChatId
	messageId *int32
	inlineMessageId *string
	livePeriod *int32
	horizontalAccuracy *float32
	heading *int32
	proximityAlertRadius *int32
	replyMarkup *InlineKeyboardMarkup
}

// Latitude of new location
func (r ApiEditMessageLiveLocationPostRequest) Latitude(latitude float32) ApiEditMessageLiveLocationPostRequest {
	r.latitude = &latitude
	return r
}

// Longitude of new location
func (r ApiEditMessageLiveLocationPostRequest) Longitude(longitude float32) ApiEditMessageLiveLocationPostRequest {
	r.longitude = &longitude
	return r
}

// Unique identifier of the business connection on behalf of which the message to be edited was sent
func (r ApiEditMessageLiveLocationPostRequest) BusinessConnectionId(businessConnectionId string) ApiEditMessageLiveLocationPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

func (r ApiEditMessageLiveLocationPostRequest) ChatId(chatId EditMessageTextPostRequestChatId) ApiEditMessageLiveLocationPostRequest {
	r.chatId = &chatId
	return r
}

// Required if *inline\\\\_message\\\\_id* is not specified. Identifier of the message to edit
func (r ApiEditMessageLiveLocationPostRequest) MessageId(messageId int32) ApiEditMessageLiveLocationPostRequest {
	r.messageId = &messageId
	return r
}

// Required if *chat\\\\_id* and *message\\\\_id* are not specified. Identifier of the inline message
func (r ApiEditMessageLiveLocationPostRequest) InlineMessageId(inlineMessageId string) ApiEditMessageLiveLocationPostRequest {
	r.inlineMessageId = &inlineMessageId
	return r
}

// New period in seconds during which the location can be updated, starting from the message send date. If 0x7FFFFFFF is specified, then the location can be updated forever. Otherwise, the new value must not exceed the current *live\\\\_period* by more than a day, and the live location expiration date must remain within the next 90 days. If not specified, then *live\\\\_period* remains unchanged
func (r ApiEditMessageLiveLocationPostRequest) LivePeriod(livePeriod int32) ApiEditMessageLiveLocationPostRequest {
	r.livePeriod = &livePeriod
	return r
}

// The radius of uncertainty for the location, measured in meters; 0-1500
func (r ApiEditMessageLiveLocationPostRequest) HorizontalAccuracy(horizontalAccuracy float32) ApiEditMessageLiveLocationPostRequest {
	r.horizontalAccuracy = &horizontalAccuracy
	return r
}

// Direction in which the user is moving, in degrees. Must be between 1 and 360 if specified.
func (r ApiEditMessageLiveLocationPostRequest) Heading(heading int32) ApiEditMessageLiveLocationPostRequest {
	r.heading = &heading
	return r
}

// The maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified.
func (r ApiEditMessageLiveLocationPostRequest) ProximityAlertRadius(proximityAlertRadius int32) ApiEditMessageLiveLocationPostRequest {
	r.proximityAlertRadius = &proximityAlertRadius
	return r
}

func (r ApiEditMessageLiveLocationPostRequest) ReplyMarkup(replyMarkup InlineKeyboardMarkup) ApiEditMessageLiveLocationPostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiEditMessageLiveLocationPostRequest) Execute() (*EditMessageTextPost200Response, *http.Response, error) {
	return r.ApiService.EditMessageLiveLocationPostExecute(r)
}

/*
EditMessageLiveLocationPost Method for EditMessageLiveLocationPost

Use this method to edit live location messages. A location can be edited until its *live\_period* expires or editing is explicitly disabled by a call to [stopMessageLiveLocation](https://core.telegram.org/bots/api/#stopmessagelivelocation). On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEditMessageLiveLocationPostRequest
*/
func (a *DefaultAPIService) EditMessageLiveLocationPost(ctx context.Context) ApiEditMessageLiveLocationPostRequest {
	return ApiEditMessageLiveLocationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EditMessageTextPost200Response
func (a *DefaultAPIService) EditMessageLiveLocationPostExecute(r ApiEditMessageLiveLocationPostRequest) (*EditMessageTextPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EditMessageTextPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EditMessageLiveLocationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editMessageLiveLocation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.latitude == nil {
		return localVarReturnValue, nil, reportError("latitude is required and must be specified")
	}
	if r.longitude == nil {
		return localVarReturnValue, nil, reportError("longitude is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	if r.chatId != nil {
		paramJson, err := parameterToJson(*r.chatId)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("chat_id", paramJson)
	}
	if r.messageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	}
	if r.inlineMessageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "inline_message_id", r.inlineMessageId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "latitude", r.latitude, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "longitude", r.longitude, "", "")
	if r.livePeriod != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "live_period", r.livePeriod, "", "")
	}
	if r.horizontalAccuracy != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "horizontal_accuracy", r.horizontalAccuracy, "", "")
	}
	if r.heading != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "heading", r.heading, "", "")
	}
	if r.proximityAlertRadius != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "proximity_alert_radius", r.proximityAlertRadius, "", "")
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEditMessageMediaPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	media *InputMedia
	businessConnectionId *string
	chatId *EditMessageTextPostRequestChatId
	messageId *int32
	inlineMessageId *string
	replyMarkup *InlineKeyboardMarkup
}

func (r ApiEditMessageMediaPostRequest) Media(media InputMedia) ApiEditMessageMediaPostRequest {
	r.media = &media
	return r
}

// Unique identifier of the business connection on behalf of which the message to be edited was sent
func (r ApiEditMessageMediaPostRequest) BusinessConnectionId(businessConnectionId string) ApiEditMessageMediaPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

func (r ApiEditMessageMediaPostRequest) ChatId(chatId EditMessageTextPostRequestChatId) ApiEditMessageMediaPostRequest {
	r.chatId = &chatId
	return r
}

// Required if *inline\\\\_message\\\\_id* is not specified. Identifier of the message to edit
func (r ApiEditMessageMediaPostRequest) MessageId(messageId int32) ApiEditMessageMediaPostRequest {
	r.messageId = &messageId
	return r
}

// Required if *chat\\\\_id* and *message\\\\_id* are not specified. Identifier of the inline message
func (r ApiEditMessageMediaPostRequest) InlineMessageId(inlineMessageId string) ApiEditMessageMediaPostRequest {
	r.inlineMessageId = &inlineMessageId
	return r
}

func (r ApiEditMessageMediaPostRequest) ReplyMarkup(replyMarkup InlineKeyboardMarkup) ApiEditMessageMediaPostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiEditMessageMediaPostRequest) Execute() (*EditMessageTextPost200Response, *http.Response, error) {
	return r.ApiService.EditMessageMediaPostExecute(r)
}

/*
EditMessageMediaPost Method for EditMessageMediaPost

Use this method to edit animation, audio, document, photo, or video messages, or to add media to text messages. If a message is part of a message album, then it can be edited only to an audio for audio albums, only to a document for document albums and to a photo or a video otherwise. When an inline message is edited, a new file can't be uploaded; use a previously uploaded file via its file\_id or specify a URL. On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned. Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within **48 hours** from the time they were sent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEditMessageMediaPostRequest
*/
func (a *DefaultAPIService) EditMessageMediaPost(ctx context.Context) ApiEditMessageMediaPostRequest {
	return ApiEditMessageMediaPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EditMessageTextPost200Response
func (a *DefaultAPIService) EditMessageMediaPostExecute(r ApiEditMessageMediaPostRequest) (*EditMessageTextPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EditMessageTextPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EditMessageMediaPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editMessageMedia"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.media == nil {
		return localVarReturnValue, nil, reportError("media is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	if r.chatId != nil {
		paramJson, err := parameterToJson(*r.chatId)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("chat_id", paramJson)
	}
	if r.messageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	}
	if r.inlineMessageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "inline_message_id", r.inlineMessageId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "media", r.media, "", "")
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEditMessageReplyMarkupPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	chatId *EditMessageTextPostRequestChatId
	messageId *int32
	inlineMessageId *string
	replyMarkup *InlineKeyboardMarkup
}

// Unique identifier of the business connection on behalf of which the message to be edited was sent
func (r ApiEditMessageReplyMarkupPostRequest) BusinessConnectionId(businessConnectionId string) ApiEditMessageReplyMarkupPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

func (r ApiEditMessageReplyMarkupPostRequest) ChatId(chatId EditMessageTextPostRequestChatId) ApiEditMessageReplyMarkupPostRequest {
	r.chatId = &chatId
	return r
}

// Required if *inline\\\\_message\\\\_id* is not specified. Identifier of the message to edit
func (r ApiEditMessageReplyMarkupPostRequest) MessageId(messageId int32) ApiEditMessageReplyMarkupPostRequest {
	r.messageId = &messageId
	return r
}

// Required if *chat\\\\_id* and *message\\\\_id* are not specified. Identifier of the inline message
func (r ApiEditMessageReplyMarkupPostRequest) InlineMessageId(inlineMessageId string) ApiEditMessageReplyMarkupPostRequest {
	r.inlineMessageId = &inlineMessageId
	return r
}

func (r ApiEditMessageReplyMarkupPostRequest) ReplyMarkup(replyMarkup InlineKeyboardMarkup) ApiEditMessageReplyMarkupPostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiEditMessageReplyMarkupPostRequest) Execute() (*EditMessageTextPost200Response, *http.Response, error) {
	return r.ApiService.EditMessageReplyMarkupPostExecute(r)
}

/*
EditMessageReplyMarkupPost Method for EditMessageReplyMarkupPost

Use this method to edit only the reply markup of messages. On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned. Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within **48 hours** from the time they were sent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEditMessageReplyMarkupPostRequest
*/
func (a *DefaultAPIService) EditMessageReplyMarkupPost(ctx context.Context) ApiEditMessageReplyMarkupPostRequest {
	return ApiEditMessageReplyMarkupPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EditMessageTextPost200Response
func (a *DefaultAPIService) EditMessageReplyMarkupPostExecute(r ApiEditMessageReplyMarkupPostRequest) (*EditMessageTextPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EditMessageTextPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EditMessageReplyMarkupPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editMessageReplyMarkup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	if r.chatId != nil {
		paramJson, err := parameterToJson(*r.chatId)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("chat_id", paramJson)
	}
	if r.messageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	}
	if r.inlineMessageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "inline_message_id", r.inlineMessageId, "", "")
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEditMessageTextPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	text *string
	businessConnectionId *string
	chatId *EditMessageTextPostRequestChatId
	messageId *int32
	inlineMessageId *string
	parseMode *string
	entities *[]MessageEntity
	linkPreviewOptions *LinkPreviewOptions
	replyMarkup *InlineKeyboardMarkup
}

// New text of the message, 1-4096 characters after entities parsing
func (r ApiEditMessageTextPostRequest) Text(text string) ApiEditMessageTextPostRequest {
	r.text = &text
	return r
}

// Unique identifier of the business connection on behalf of which the message to be edited was sent
func (r ApiEditMessageTextPostRequest) BusinessConnectionId(businessConnectionId string) ApiEditMessageTextPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

func (r ApiEditMessageTextPostRequest) ChatId(chatId EditMessageTextPostRequestChatId) ApiEditMessageTextPostRequest {
	r.chatId = &chatId
	return r
}

// Required if *inline\\\\_message\\\\_id* is not specified. Identifier of the message to edit
func (r ApiEditMessageTextPostRequest) MessageId(messageId int32) ApiEditMessageTextPostRequest {
	r.messageId = &messageId
	return r
}

// Required if *chat\\\\_id* and *message\\\\_id* are not specified. Identifier of the inline message
func (r ApiEditMessageTextPostRequest) InlineMessageId(inlineMessageId string) ApiEditMessageTextPostRequest {
	r.inlineMessageId = &inlineMessageId
	return r
}

// Mode for parsing entities in the message text. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiEditMessageTextPostRequest) ParseMode(parseMode string) ApiEditMessageTextPostRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in message text, which can be specified instead of *parse\\\\_mode*
func (r ApiEditMessageTextPostRequest) Entities(entities []MessageEntity) ApiEditMessageTextPostRequest {
	r.entities = &entities
	return r
}

func (r ApiEditMessageTextPostRequest) LinkPreviewOptions(linkPreviewOptions LinkPreviewOptions) ApiEditMessageTextPostRequest {
	r.linkPreviewOptions = &linkPreviewOptions
	return r
}

func (r ApiEditMessageTextPostRequest) ReplyMarkup(replyMarkup InlineKeyboardMarkup) ApiEditMessageTextPostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiEditMessageTextPostRequest) Execute() (*EditMessageTextPost200Response, *http.Response, error) {
	return r.ApiService.EditMessageTextPostExecute(r)
}

/*
EditMessageTextPost Method for EditMessageTextPost

Use this method to edit text and [game](https://core.telegram.org/bots/api/#games) messages. On success, if the edited message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned. Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within **48 hours** from the time they were sent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEditMessageTextPostRequest
*/
func (a *DefaultAPIService) EditMessageTextPost(ctx context.Context) ApiEditMessageTextPostRequest {
	return ApiEditMessageTextPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EditMessageTextPost200Response
func (a *DefaultAPIService) EditMessageTextPostExecute(r ApiEditMessageTextPostRequest) (*EditMessageTextPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EditMessageTextPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EditMessageTextPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editMessageText"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}
	if strlen(*r.text) < 1 {
		return localVarReturnValue, nil, reportError("text must have at least 1 elements")
	}
	if strlen(*r.text) > 4096 {
		return localVarReturnValue, nil, reportError("text must have less than 4096 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	if r.chatId != nil {
		paramJson, err := parameterToJson(*r.chatId)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("chat_id", paramJson)
	}
	if r.messageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	}
	if r.inlineMessageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "inline_message_id", r.inlineMessageId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "text", r.text, "", "")
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.entities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "entities", r.entities, "", "csv")
	}
	if r.linkPreviewOptions != nil {
		paramJson, err := parameterToJson(*r.linkPreviewOptions)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("link_preview_options", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEditStoryPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	storyId *int32
	content *InputStoryContent
	caption *string
	parseMode *string
	captionEntities *[]MessageEntity
	areas *[]StoryArea
}

// Unique identifier of the business connection
func (r ApiEditStoryPostRequest) BusinessConnectionId(businessConnectionId string) ApiEditStoryPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier of the story to edit
func (r ApiEditStoryPostRequest) StoryId(storyId int32) ApiEditStoryPostRequest {
	r.storyId = &storyId
	return r
}

func (r ApiEditStoryPostRequest) Content(content InputStoryContent) ApiEditStoryPostRequest {
	r.content = &content
	return r
}

// Caption of the story, 0-2048 characters after entities parsing
func (r ApiEditStoryPostRequest) Caption(caption string) ApiEditStoryPostRequest {
	r.caption = &caption
	return r
}

// Mode for parsing entities in the story caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiEditStoryPostRequest) ParseMode(parseMode string) ApiEditStoryPostRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of *parse\\\\_mode*
func (r ApiEditStoryPostRequest) CaptionEntities(captionEntities []MessageEntity) ApiEditStoryPostRequest {
	r.captionEntities = &captionEntities
	return r
}

// A JSON-serialized list of clickable areas to be shown on the story
func (r ApiEditStoryPostRequest) Areas(areas []StoryArea) ApiEditStoryPostRequest {
	r.areas = &areas
	return r
}

func (r ApiEditStoryPostRequest) Execute() (*PostStoryPost200Response, *http.Response, error) {
	return r.ApiService.EditStoryPostExecute(r)
}

/*
EditStoryPost Method for EditStoryPost

Edits a story previously posted by the bot on behalf of a managed business account. Requires the *can\_manage\_stories* business bot right. Returns [Story](https://core.telegram.org/bots/api/#story) on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEditStoryPostRequest
*/
func (a *DefaultAPIService) EditStoryPost(ctx context.Context) ApiEditStoryPostRequest {
	return ApiEditStoryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostStoryPost200Response
func (a *DefaultAPIService) EditStoryPostExecute(r ApiEditStoryPostRequest) (*PostStoryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostStoryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EditStoryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editStory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.storyId == nil {
		return localVarReturnValue, nil, reportError("storyId is required and must be specified")
	}
	if r.content == nil {
		return localVarReturnValue, nil, reportError("content is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "story_id", r.storyId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "content", r.content, "", "")
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption", r.caption, "", "")
	}
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.captionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption_entities", r.captionEntities, "", "csv")
	}
	if r.areas != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "areas", r.areas, "", "csv")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEditUserStarSubscriptionPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	telegramPaymentChargeId *string
	isCanceled *bool
}

// Identifier of the user whose subscription will be edited
func (r ApiEditUserStarSubscriptionPostRequest) UserId(userId int32) ApiEditUserStarSubscriptionPostRequest {
	r.userId = &userId
	return r
}

// Telegram payment identifier for the subscription
func (r ApiEditUserStarSubscriptionPostRequest) TelegramPaymentChargeId(telegramPaymentChargeId string) ApiEditUserStarSubscriptionPostRequest {
	r.telegramPaymentChargeId = &telegramPaymentChargeId
	return r
}

// Pass *True* to cancel extension of the user subscription; the subscription must be active up to the end of the current subscription period. Pass *False* to allow the user to re-enable a subscription that was previously canceled by the bot.
func (r ApiEditUserStarSubscriptionPostRequest) IsCanceled(isCanceled bool) ApiEditUserStarSubscriptionPostRequest {
	r.isCanceled = &isCanceled
	return r
}

func (r ApiEditUserStarSubscriptionPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.EditUserStarSubscriptionPostExecute(r)
}

/*
EditUserStarSubscriptionPost Method for EditUserStarSubscriptionPost

Allows the bot to cancel or re-enable extension of a subscription paid in Telegram Stars. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEditUserStarSubscriptionPostRequest
*/
func (a *DefaultAPIService) EditUserStarSubscriptionPost(ctx context.Context) ApiEditUserStarSubscriptionPostRequest {
	return ApiEditUserStarSubscriptionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) EditUserStarSubscriptionPostExecute(r ApiEditUserStarSubscriptionPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EditUserStarSubscriptionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/editUserStarSubscription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.telegramPaymentChargeId == nil {
		return localVarReturnValue, nil, reportError("telegramPaymentChargeId is required and must be specified")
	}
	if r.isCanceled == nil {
		return localVarReturnValue, nil, reportError("isCanceled is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "telegram_payment_charge_id", r.telegramPaymentChargeId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "is_canceled", r.isCanceled, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportChatInviteLinkPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
}

func (r ApiExportChatInviteLinkPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiExportChatInviteLinkPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiExportChatInviteLinkPostRequest) Execute() (*ExportChatInviteLinkPost200Response, *http.Response, error) {
	return r.ApiService.ExportChatInviteLinkPostExecute(r)
}

/*
ExportChatInviteLinkPost Method for ExportChatInviteLinkPost

Use this method to generate a new primary invite link for a chat; any previously generated primary link is revoked. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns the new invite link as *String* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExportChatInviteLinkPostRequest
*/
func (a *DefaultAPIService) ExportChatInviteLinkPost(ctx context.Context) ApiExportChatInviteLinkPostRequest {
	return ApiExportChatInviteLinkPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExportChatInviteLinkPost200Response
func (a *DefaultAPIService) ExportChatInviteLinkPostExecute(r ApiExportChatInviteLinkPostRequest) (*ExportChatInviteLinkPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportChatInviteLinkPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ExportChatInviteLinkPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exportChatInviteLink"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiForwardMessagePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	fromChatId *ForwardMessagePostRequestFromChatId
	messageId *int32
	messageThreadId *int32
	videoStartTimestamp *int32
	disableNotification *bool
	protectContent *bool
}

func (r ApiForwardMessagePostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiForwardMessagePostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiForwardMessagePostRequest) FromChatId(fromChatId ForwardMessagePostRequestFromChatId) ApiForwardMessagePostRequest {
	r.fromChatId = &fromChatId
	return r
}

// Message identifier in the chat specified in *from\\\\_chat\\\\_id*
func (r ApiForwardMessagePostRequest) MessageId(messageId int32) ApiForwardMessagePostRequest {
	r.messageId = &messageId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiForwardMessagePostRequest) MessageThreadId(messageThreadId int32) ApiForwardMessagePostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// New start timestamp for the forwarded video in the message
func (r ApiForwardMessagePostRequest) VideoStartTimestamp(videoStartTimestamp int32) ApiForwardMessagePostRequest {
	r.videoStartTimestamp = &videoStartTimestamp
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiForwardMessagePostRequest) DisableNotification(disableNotification bool) ApiForwardMessagePostRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the forwarded message from forwarding and saving
func (r ApiForwardMessagePostRequest) ProtectContent(protectContent bool) ApiForwardMessagePostRequest {
	r.protectContent = &protectContent
	return r
}

func (r ApiForwardMessagePostRequest) Execute() (*SendMessagePost200Response, *http.Response, error) {
	return r.ApiService.ForwardMessagePostExecute(r)
}

/*
ForwardMessagePost Method for ForwardMessagePost

Use this method to forward messages of any kind. Service messages and messages with protected content can't be forwarded. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiForwardMessagePostRequest
*/
func (a *DefaultAPIService) ForwardMessagePost(ctx context.Context) ApiForwardMessagePostRequest {
	return ApiForwardMessagePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendMessagePost200Response
func (a *DefaultAPIService) ForwardMessagePostExecute(r ApiForwardMessagePostRequest) (*SendMessagePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendMessagePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ForwardMessagePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forwardMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.fromChatId == nil {
		return localVarReturnValue, nil, reportError("fromChatId is required and must be specified")
	}
	if r.messageId == nil {
		return localVarReturnValue, nil, reportError("messageId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "from_chat_id", r.fromChatId, "", "")
	if r.videoStartTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "video_start_timestamp", r.videoStartTimestamp, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiForwardMessagesPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	fromChatId *ForwardMessagesPostRequestFromChatId
	messageIds *[]int32
	messageThreadId *int32
	disableNotification *bool
	protectContent *bool
}

func (r ApiForwardMessagesPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiForwardMessagesPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiForwardMessagesPostRequest) FromChatId(fromChatId ForwardMessagesPostRequestFromChatId) ApiForwardMessagesPostRequest {
	r.fromChatId = &fromChatId
	return r
}

// A JSON-serialized list of 1-100 identifiers of messages in the chat *from\\\\_chat\\\\_id* to forward. The identifiers must be specified in a strictly increasing order.
func (r ApiForwardMessagesPostRequest) MessageIds(messageIds []int32) ApiForwardMessagesPostRequest {
	r.messageIds = &messageIds
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiForwardMessagesPostRequest) MessageThreadId(messageThreadId int32) ApiForwardMessagesPostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Sends the messages [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiForwardMessagesPostRequest) DisableNotification(disableNotification bool) ApiForwardMessagesPostRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the forwarded messages from forwarding and saving
func (r ApiForwardMessagesPostRequest) ProtectContent(protectContent bool) ApiForwardMessagesPostRequest {
	r.protectContent = &protectContent
	return r
}

func (r ApiForwardMessagesPostRequest) Execute() (*ForwardMessagesPost200Response, *http.Response, error) {
	return r.ApiService.ForwardMessagesPostExecute(r)
}

/*
ForwardMessagesPost Method for ForwardMessagesPost

Use this method to forward multiple messages of any kind. If some of the specified messages can't be found or forwarded, they are skipped. Service messages and messages with protected content can't be forwarded. Album grouping is kept for forwarded messages. On success, an array of [MessageId](https://core.telegram.org/bots/api/#messageid) of the sent messages is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiForwardMessagesPostRequest
*/
func (a *DefaultAPIService) ForwardMessagesPost(ctx context.Context) ApiForwardMessagesPostRequest {
	return ApiForwardMessagesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ForwardMessagesPost200Response
func (a *DefaultAPIService) ForwardMessagesPostExecute(r ApiForwardMessagesPostRequest) (*ForwardMessagesPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ForwardMessagesPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ForwardMessagesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forwardMessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.fromChatId == nil {
		return localVarReturnValue, nil, reportError("fromChatId is required and must be specified")
	}
	if r.messageIds == nil {
		return localVarReturnValue, nil, reportError("messageIds is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "from_chat_id", r.fromChatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_ids", r.messageIds, "", "csv")
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAvailableGiftsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiGetAvailableGiftsPostRequest) Execute() (*GetAvailableGiftsPost200Response, *http.Response, error) {
	return r.ApiService.GetAvailableGiftsPostExecute(r)
}

/*
GetAvailableGiftsPost Method for GetAvailableGiftsPost

Returns the list of gifts that can be sent by the bot to users and channel chats. Requires no parameters. Returns a [Gifts](https://core.telegram.org/bots/api/#gifts) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAvailableGiftsPostRequest
*/
func (a *DefaultAPIService) GetAvailableGiftsPost(ctx context.Context) ApiGetAvailableGiftsPostRequest {
	return ApiGetAvailableGiftsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAvailableGiftsPost200Response
func (a *DefaultAPIService) GetAvailableGiftsPostExecute(r ApiGetAvailableGiftsPostRequest) (*GetAvailableGiftsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAvailableGiftsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetAvailableGiftsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getAvailableGifts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBusinessAccountGiftsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	excludeUnsaved *bool
	excludeSaved *bool
	excludeUnlimited *bool
	excludeLimited *bool
	excludeUnique *bool
	sortByPrice *bool
	offset *string
	limit *int32
}

// Unique identifier of the business connection
func (r ApiGetBusinessAccountGiftsPostRequest) BusinessConnectionId(businessConnectionId string) ApiGetBusinessAccountGiftsPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Pass True to exclude gifts that aren&#39;t saved to the account&#39;s profile page
func (r ApiGetBusinessAccountGiftsPostRequest) ExcludeUnsaved(excludeUnsaved bool) ApiGetBusinessAccountGiftsPostRequest {
	r.excludeUnsaved = &excludeUnsaved
	return r
}

// Pass True to exclude gifts that are saved to the account&#39;s profile page
func (r ApiGetBusinessAccountGiftsPostRequest) ExcludeSaved(excludeSaved bool) ApiGetBusinessAccountGiftsPostRequest {
	r.excludeSaved = &excludeSaved
	return r
}

// Pass True to exclude gifts that can be purchased an unlimited number of times
func (r ApiGetBusinessAccountGiftsPostRequest) ExcludeUnlimited(excludeUnlimited bool) ApiGetBusinessAccountGiftsPostRequest {
	r.excludeUnlimited = &excludeUnlimited
	return r
}

// Pass True to exclude gifts that can be purchased a limited number of times
func (r ApiGetBusinessAccountGiftsPostRequest) ExcludeLimited(excludeLimited bool) ApiGetBusinessAccountGiftsPostRequest {
	r.excludeLimited = &excludeLimited
	return r
}

// Pass True to exclude unique gifts
func (r ApiGetBusinessAccountGiftsPostRequest) ExcludeUnique(excludeUnique bool) ApiGetBusinessAccountGiftsPostRequest {
	r.excludeUnique = &excludeUnique
	return r
}

// Pass True to sort results by gift price instead of send date. Sorting is applied before pagination.
func (r ApiGetBusinessAccountGiftsPostRequest) SortByPrice(sortByPrice bool) ApiGetBusinessAccountGiftsPostRequest {
	r.sortByPrice = &sortByPrice
	return r
}

// Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
func (r ApiGetBusinessAccountGiftsPostRequest) Offset(offset string) ApiGetBusinessAccountGiftsPostRequest {
	r.offset = &offset
	return r
}

// The maximum number of gifts to be returned; 1-100. Defaults to 100
func (r ApiGetBusinessAccountGiftsPostRequest) Limit(limit int32) ApiGetBusinessAccountGiftsPostRequest {
	r.limit = &limit
	return r
}

func (r ApiGetBusinessAccountGiftsPostRequest) Execute() (*GetBusinessAccountGiftsPost200Response, *http.Response, error) {
	return r.ApiService.GetBusinessAccountGiftsPostExecute(r)
}

/*
GetBusinessAccountGiftsPost Method for GetBusinessAccountGiftsPost

Returns the gifts received and owned by a managed business account. Requires the *can\_view\_gifts\_and\_stars* business bot right. Returns [OwnedGifts](https://core.telegram.org/bots/api/#ownedgifts) on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBusinessAccountGiftsPostRequest
*/
func (a *DefaultAPIService) GetBusinessAccountGiftsPost(ctx context.Context) ApiGetBusinessAccountGiftsPostRequest {
	return ApiGetBusinessAccountGiftsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetBusinessAccountGiftsPost200Response
func (a *DefaultAPIService) GetBusinessAccountGiftsPostExecute(r ApiGetBusinessAccountGiftsPostRequest) (*GetBusinessAccountGiftsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBusinessAccountGiftsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetBusinessAccountGiftsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getBusinessAccountGifts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	if r.excludeUnsaved != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "exclude_unsaved", r.excludeUnsaved, "", "")
	}
	if r.excludeSaved != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "exclude_saved", r.excludeSaved, "", "")
	}
	if r.excludeUnlimited != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "exclude_unlimited", r.excludeUnlimited, "", "")
	}
	if r.excludeLimited != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "exclude_limited", r.excludeLimited, "", "")
	}
	if r.excludeUnique != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "exclude_unique", r.excludeUnique, "", "")
	}
	if r.sortByPrice != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "sort_by_price", r.sortByPrice, "", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "offset", r.offset, "", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limit", r.limit, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBusinessAccountStarBalancePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
}

// Unique identifier of the business connection
func (r ApiGetBusinessAccountStarBalancePostRequest) BusinessConnectionId(businessConnectionId string) ApiGetBusinessAccountStarBalancePostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

func (r ApiGetBusinessAccountStarBalancePostRequest) Execute() (*GetBusinessAccountStarBalancePost200Response, *http.Response, error) {
	return r.ApiService.GetBusinessAccountStarBalancePostExecute(r)
}

/*
GetBusinessAccountStarBalancePost Method for GetBusinessAccountStarBalancePost

Returns the amount of Telegram Stars owned by a managed business account. Requires the *can\_view\_gifts\_and\_stars* business bot right. Returns [StarAmount](https://core.telegram.org/bots/api/#staramount) on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBusinessAccountStarBalancePostRequest
*/
func (a *DefaultAPIService) GetBusinessAccountStarBalancePost(ctx context.Context) ApiGetBusinessAccountStarBalancePostRequest {
	return ApiGetBusinessAccountStarBalancePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetBusinessAccountStarBalancePost200Response
func (a *DefaultAPIService) GetBusinessAccountStarBalancePostExecute(r ApiGetBusinessAccountStarBalancePostRequest) (*GetBusinessAccountStarBalancePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBusinessAccountStarBalancePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetBusinessAccountStarBalancePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getBusinessAccountStarBalance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBusinessConnectionPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
}

// Unique identifier of the business connection
func (r ApiGetBusinessConnectionPostRequest) BusinessConnectionId(businessConnectionId string) ApiGetBusinessConnectionPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

func (r ApiGetBusinessConnectionPostRequest) Execute() (*GetBusinessConnectionPost200Response, *http.Response, error) {
	return r.ApiService.GetBusinessConnectionPostExecute(r)
}

/*
GetBusinessConnectionPost Method for GetBusinessConnectionPost

Use this method to get information about the connection of the bot with a business account. Returns a [BusinessConnection](https://core.telegram.org/bots/api/#businessconnection) object on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBusinessConnectionPostRequest
*/
func (a *DefaultAPIService) GetBusinessConnectionPost(ctx context.Context) ApiGetBusinessConnectionPostRequest {
	return ApiGetBusinessConnectionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetBusinessConnectionPost200Response
func (a *DefaultAPIService) GetBusinessConnectionPostExecute(r ApiGetBusinessConnectionPostRequest) (*GetBusinessConnectionPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBusinessConnectionPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetBusinessConnectionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getBusinessConnection"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChatAdministratorsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *LeaveChatPostRequestChatId
}

func (r ApiGetChatAdministratorsPostRequest) ChatId(chatId LeaveChatPostRequestChatId) ApiGetChatAdministratorsPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiGetChatAdministratorsPostRequest) Execute() (*GetChatAdministratorsPost200Response, *http.Response, error) {
	return r.ApiService.GetChatAdministratorsPostExecute(r)
}

/*
GetChatAdministratorsPost Method for GetChatAdministratorsPost

Use this method to get a list of administrators in a chat, which aren't bots. Returns an Array of [ChatMember](https://core.telegram.org/bots/api/#chatmember) objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetChatAdministratorsPostRequest
*/
func (a *DefaultAPIService) GetChatAdministratorsPost(ctx context.Context) ApiGetChatAdministratorsPostRequest {
	return ApiGetChatAdministratorsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetChatAdministratorsPost200Response
func (a *DefaultAPIService) GetChatAdministratorsPostExecute(r ApiGetChatAdministratorsPostRequest) (*GetChatAdministratorsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetChatAdministratorsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetChatAdministratorsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getChatAdministrators"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChatMemberCountPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *LeaveChatPostRequestChatId
}

func (r ApiGetChatMemberCountPostRequest) ChatId(chatId LeaveChatPostRequestChatId) ApiGetChatMemberCountPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiGetChatMemberCountPostRequest) Execute() (*GetChatMemberCountPost200Response, *http.Response, error) {
	return r.ApiService.GetChatMemberCountPostExecute(r)
}

/*
GetChatMemberCountPost Method for GetChatMemberCountPost

Use this method to get the number of members in a chat. Returns *Int* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetChatMemberCountPostRequest
*/
func (a *DefaultAPIService) GetChatMemberCountPost(ctx context.Context) ApiGetChatMemberCountPostRequest {
	return ApiGetChatMemberCountPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetChatMemberCountPost200Response
func (a *DefaultAPIService) GetChatMemberCountPostExecute(r ApiGetChatMemberCountPostRequest) (*GetChatMemberCountPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetChatMemberCountPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetChatMemberCountPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getChatMemberCount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChatMemberPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *LeaveChatPostRequestChatId
	userId *int32
}

func (r ApiGetChatMemberPostRequest) ChatId(chatId LeaveChatPostRequestChatId) ApiGetChatMemberPostRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the target user
func (r ApiGetChatMemberPostRequest) UserId(userId int32) ApiGetChatMemberPostRequest {
	r.userId = &userId
	return r
}

func (r ApiGetChatMemberPostRequest) Execute() (*GetChatMemberPost200Response, *http.Response, error) {
	return r.ApiService.GetChatMemberPostExecute(r)
}

/*
GetChatMemberPost Method for GetChatMemberPost

Use this method to get information about a member of a chat. The method is only guaranteed to work for other users if the bot is an administrator in the chat. Returns a [ChatMember](https://core.telegram.org/bots/api/#chatmember) object on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetChatMemberPostRequest
*/
func (a *DefaultAPIService) GetChatMemberPost(ctx context.Context) ApiGetChatMemberPostRequest {
	return ApiGetChatMemberPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetChatMemberPost200Response
func (a *DefaultAPIService) GetChatMemberPostExecute(r ApiGetChatMemberPostRequest) (*GetChatMemberPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetChatMemberPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetChatMemberPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getChatMember"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChatMenuButtonPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *int32
}

// Unique identifier for the target private chat. If not specified, default bot&#39;s menu button will be returned
func (r ApiGetChatMenuButtonPostRequest) ChatId(chatId int32) ApiGetChatMenuButtonPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiGetChatMenuButtonPostRequest) Execute() (*GetChatMenuButtonPost200Response, *http.Response, error) {
	return r.ApiService.GetChatMenuButtonPostExecute(r)
}

/*
GetChatMenuButtonPost Method for GetChatMenuButtonPost

Use this method to get the current value of the bot's menu button in a private chat, or the default menu button. Returns [MenuButton](https://core.telegram.org/bots/api/#menubutton) on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetChatMenuButtonPostRequest
*/
func (a *DefaultAPIService) GetChatMenuButtonPost(ctx context.Context) ApiGetChatMenuButtonPostRequest {
	return ApiGetChatMenuButtonPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetChatMenuButtonPost200Response
func (a *DefaultAPIService) GetChatMenuButtonPostExecute(r ApiGetChatMenuButtonPostRequest) (*GetChatMenuButtonPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetChatMenuButtonPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetChatMenuButtonPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getChatMenuButton"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.chatId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChatPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *LeaveChatPostRequestChatId
}

func (r ApiGetChatPostRequest) ChatId(chatId LeaveChatPostRequestChatId) ApiGetChatPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiGetChatPostRequest) Execute() (*GetChatPost200Response, *http.Response, error) {
	return r.ApiService.GetChatPostExecute(r)
}

/*
GetChatPost Method for GetChatPost

Use this method to get up-to-date information about the chat. Returns a [ChatFullInfo](https://core.telegram.org/bots/api/#chatfullinfo) object on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetChatPostRequest
*/
func (a *DefaultAPIService) GetChatPost(ctx context.Context) ApiGetChatPostRequest {
	return ApiGetChatPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetChatPost200Response
func (a *DefaultAPIService) GetChatPostExecute(r ApiGetChatPostRequest) (*GetChatPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetChatPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetChatPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getChat"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCustomEmojiStickersPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	customEmojiIds *[]string
}

// A JSON-serialized list of custom emoji identifiers. At most 200 custom emoji identifiers can be specified.
func (r ApiGetCustomEmojiStickersPostRequest) CustomEmojiIds(customEmojiIds []string) ApiGetCustomEmojiStickersPostRequest {
	r.customEmojiIds = &customEmojiIds
	return r
}

func (r ApiGetCustomEmojiStickersPostRequest) Execute() (*GetForumTopicIconStickersPost200Response, *http.Response, error) {
	return r.ApiService.GetCustomEmojiStickersPostExecute(r)
}

/*
GetCustomEmojiStickersPost Method for GetCustomEmojiStickersPost

Use this method to get information about custom emoji stickers by their identifiers. Returns an Array of [Sticker](https://core.telegram.org/bots/api/#sticker) objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCustomEmojiStickersPostRequest
*/
func (a *DefaultAPIService) GetCustomEmojiStickersPost(ctx context.Context) ApiGetCustomEmojiStickersPostRequest {
	return ApiGetCustomEmojiStickersPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetForumTopicIconStickersPost200Response
func (a *DefaultAPIService) GetCustomEmojiStickersPostExecute(r ApiGetCustomEmojiStickersPostRequest) (*GetForumTopicIconStickersPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetForumTopicIconStickersPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetCustomEmojiStickersPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getCustomEmojiStickers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.customEmojiIds == nil {
		return localVarReturnValue, nil, reportError("customEmojiIds is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "custom_emoji_ids", r.customEmojiIds, "", "csv")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFilePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	fileId *string
}

// File identifier to get information about
func (r ApiGetFilePostRequest) FileId(fileId string) ApiGetFilePostRequest {
	r.fileId = &fileId
	return r
}

func (r ApiGetFilePostRequest) Execute() (*GetFilePost200Response, *http.Response, error) {
	return r.ApiService.GetFilePostExecute(r)
}

/*
GetFilePost Method for GetFilePost

Use this method to get basic information about a file and prepare it for downloading. For the moment, bots can download files of up to 20MB in size. On success, a [File](https://core.telegram.org/bots/api/#file) object is returned. The file can then be downloaded via the link `https://api.telegram.org/file/bot<token>/<file_path>`, where `<file_path>` is taken from the response. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling [getFile](https://core.telegram.org/bots/api/#getfile) again.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFilePostRequest
*/
func (a *DefaultAPIService) GetFilePost(ctx context.Context) ApiGetFilePostRequest {
	return ApiGetFilePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetFilePost200Response
func (a *DefaultAPIService) GetFilePostExecute(r ApiGetFilePostRequest) (*GetFilePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetFilePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetFilePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getFile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileId == nil {
		return localVarReturnValue, nil, reportError("fileId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "file_id", r.fileId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetForumTopicIconStickersPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiGetForumTopicIconStickersPostRequest) Execute() (*GetForumTopicIconStickersPost200Response, *http.Response, error) {
	return r.ApiService.GetForumTopicIconStickersPostExecute(r)
}

/*
GetForumTopicIconStickersPost Method for GetForumTopicIconStickersPost

Use this method to get custom emoji stickers, which can be used as a forum topic icon by any user. Requires no parameters. Returns an Array of [Sticker](https://core.telegram.org/bots/api/#sticker) objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetForumTopicIconStickersPostRequest
*/
func (a *DefaultAPIService) GetForumTopicIconStickersPost(ctx context.Context) ApiGetForumTopicIconStickersPostRequest {
	return ApiGetForumTopicIconStickersPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetForumTopicIconStickersPost200Response
func (a *DefaultAPIService) GetForumTopicIconStickersPostExecute(r ApiGetForumTopicIconStickersPostRequest) (*GetForumTopicIconStickersPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetForumTopicIconStickersPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetForumTopicIconStickersPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getForumTopicIconStickers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGameHighScoresPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	chatId *int32
	messageId *int32
	inlineMessageId *string
}

// Target user id
func (r ApiGetGameHighScoresPostRequest) UserId(userId int32) ApiGetGameHighScoresPostRequest {
	r.userId = &userId
	return r
}

// Required if *inline\\\\_message\\\\_id* is not specified. Unique identifier for the target chat
func (r ApiGetGameHighScoresPostRequest) ChatId(chatId int32) ApiGetGameHighScoresPostRequest {
	r.chatId = &chatId
	return r
}

// Required if *inline\\\\_message\\\\_id* is not specified. Identifier of the sent message
func (r ApiGetGameHighScoresPostRequest) MessageId(messageId int32) ApiGetGameHighScoresPostRequest {
	r.messageId = &messageId
	return r
}

// Required if *chat\\\\_id* and *message\\\\_id* are not specified. Identifier of the inline message
func (r ApiGetGameHighScoresPostRequest) InlineMessageId(inlineMessageId string) ApiGetGameHighScoresPostRequest {
	r.inlineMessageId = &inlineMessageId
	return r
}

func (r ApiGetGameHighScoresPostRequest) Execute() (*GetGameHighScoresPost200Response, *http.Response, error) {
	return r.ApiService.GetGameHighScoresPostExecute(r)
}

/*
GetGameHighScoresPost Method for GetGameHighScoresPost

Use this method to get data for high score tables. Will return the score of the specified user and several of their neighbors in a game. Returns an Array of [GameHighScore](https://core.telegram.org/bots/api/#gamehighscore) objects.

This method will currently return scores for the target user, plus two of their closest neighbors on each side. Will also return the top three users if the user and their neighbors are not among them. Please note that this behavior is subject to change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGameHighScoresPostRequest
*/
func (a *DefaultAPIService) GetGameHighScoresPost(ctx context.Context) ApiGetGameHighScoresPostRequest {
	return ApiGetGameHighScoresPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetGameHighScoresPost200Response
func (a *DefaultAPIService) GetGameHighScoresPostExecute(r ApiGetGameHighScoresPostRequest) (*GetGameHighScoresPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetGameHighScoresPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetGameHighScoresPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getGameHighScores"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	if r.chatId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	}
	if r.messageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	}
	if r.inlineMessageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "inline_message_id", r.inlineMessageId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiGetMePostRequest) Execute() (*GetMePost200Response, *http.Response, error) {
	return r.ApiService.GetMePostExecute(r)
}

/*
GetMePost Method for GetMePost

A simple method for testing your bot's authentication token. Requires no parameters. Returns basic information about the bot in form of a [User](https://core.telegram.org/bots/api/#user) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMePostRequest
*/
func (a *DefaultAPIService) GetMePost(ctx context.Context) ApiGetMePostRequest {
	return ApiGetMePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMePost200Response
func (a *DefaultAPIService) GetMePostExecute(r ApiGetMePostRequest) (*GetMePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetMePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getMe"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMyCommandsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	scope *BotCommandScope
	languageCode *string
}

func (r ApiGetMyCommandsPostRequest) Scope(scope BotCommandScope) ApiGetMyCommandsPostRequest {
	r.scope = &scope
	return r
}

// A two-letter ISO 639-1 language code or an empty string
func (r ApiGetMyCommandsPostRequest) LanguageCode(languageCode string) ApiGetMyCommandsPostRequest {
	r.languageCode = &languageCode
	return r
}

func (r ApiGetMyCommandsPostRequest) Execute() (*GetMyCommandsPost200Response, *http.Response, error) {
	return r.ApiService.GetMyCommandsPostExecute(r)
}

/*
GetMyCommandsPost Method for GetMyCommandsPost

Use this method to get the current list of the bot's commands for the given scope and user language. Returns an Array of [BotCommand](https://core.telegram.org/bots/api/#botcommand) objects. If commands aren't set, an empty list is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMyCommandsPostRequest
*/
func (a *DefaultAPIService) GetMyCommandsPost(ctx context.Context) ApiGetMyCommandsPostRequest {
	return ApiGetMyCommandsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMyCommandsPost200Response
func (a *DefaultAPIService) GetMyCommandsPostExecute(r ApiGetMyCommandsPostRequest) (*GetMyCommandsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMyCommandsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetMyCommandsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getMyCommands"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.scope != nil {
		paramJson, err := parameterToJson(*r.scope)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("scope", paramJson)
	}
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "language_code", r.languageCode, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMyDefaultAdministratorRightsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	forChannels *bool
}

// Pass *True* to get default administrator rights of the bot in channels. Otherwise, default administrator rights of the bot for groups and supergroups will be returned.
func (r ApiGetMyDefaultAdministratorRightsPostRequest) ForChannels(forChannels bool) ApiGetMyDefaultAdministratorRightsPostRequest {
	r.forChannels = &forChannels
	return r
}

func (r ApiGetMyDefaultAdministratorRightsPostRequest) Execute() (*GetMyDefaultAdministratorRightsPost200Response, *http.Response, error) {
	return r.ApiService.GetMyDefaultAdministratorRightsPostExecute(r)
}

/*
GetMyDefaultAdministratorRightsPost Method for GetMyDefaultAdministratorRightsPost

Use this method to get the current default administrator rights of the bot. Returns [ChatAdministratorRights](https://core.telegram.org/bots/api/#chatadministratorrights) on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMyDefaultAdministratorRightsPostRequest
*/
func (a *DefaultAPIService) GetMyDefaultAdministratorRightsPost(ctx context.Context) ApiGetMyDefaultAdministratorRightsPostRequest {
	return ApiGetMyDefaultAdministratorRightsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMyDefaultAdministratorRightsPost200Response
func (a *DefaultAPIService) GetMyDefaultAdministratorRightsPostExecute(r ApiGetMyDefaultAdministratorRightsPostRequest) (*GetMyDefaultAdministratorRightsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMyDefaultAdministratorRightsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetMyDefaultAdministratorRightsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getMyDefaultAdministratorRights"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.forChannels != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "for_channels", r.forChannels, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMyDescriptionPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	languageCode *string
}

// A two-letter ISO 639-1 language code or an empty string
func (r ApiGetMyDescriptionPostRequest) LanguageCode(languageCode string) ApiGetMyDescriptionPostRequest {
	r.languageCode = &languageCode
	return r
}

func (r ApiGetMyDescriptionPostRequest) Execute() (*GetMyDescriptionPost200Response, *http.Response, error) {
	return r.ApiService.GetMyDescriptionPostExecute(r)
}

/*
GetMyDescriptionPost Method for GetMyDescriptionPost

Use this method to get the current bot description for the given user language. Returns [BotDescription](https://core.telegram.org/bots/api/#botdescription) on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMyDescriptionPostRequest
*/
func (a *DefaultAPIService) GetMyDescriptionPost(ctx context.Context) ApiGetMyDescriptionPostRequest {
	return ApiGetMyDescriptionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMyDescriptionPost200Response
func (a *DefaultAPIService) GetMyDescriptionPostExecute(r ApiGetMyDescriptionPostRequest) (*GetMyDescriptionPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMyDescriptionPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetMyDescriptionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getMyDescription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "language_code", r.languageCode, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMyNamePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	languageCode *string
}

// A two-letter ISO 639-1 language code or an empty string
func (r ApiGetMyNamePostRequest) LanguageCode(languageCode string) ApiGetMyNamePostRequest {
	r.languageCode = &languageCode
	return r
}

func (r ApiGetMyNamePostRequest) Execute() (*GetMyNamePost200Response, *http.Response, error) {
	return r.ApiService.GetMyNamePostExecute(r)
}

/*
GetMyNamePost Method for GetMyNamePost

Use this method to get the current bot name for the given user language. Returns [BotName](https://core.telegram.org/bots/api/#botname) on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMyNamePostRequest
*/
func (a *DefaultAPIService) GetMyNamePost(ctx context.Context) ApiGetMyNamePostRequest {
	return ApiGetMyNamePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMyNamePost200Response
func (a *DefaultAPIService) GetMyNamePostExecute(r ApiGetMyNamePostRequest) (*GetMyNamePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMyNamePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetMyNamePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getMyName"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "language_code", r.languageCode, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMyShortDescriptionPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	languageCode *string
}

// A two-letter ISO 639-1 language code or an empty string
func (r ApiGetMyShortDescriptionPostRequest) LanguageCode(languageCode string) ApiGetMyShortDescriptionPostRequest {
	r.languageCode = &languageCode
	return r
}

func (r ApiGetMyShortDescriptionPostRequest) Execute() (*GetMyShortDescriptionPost200Response, *http.Response, error) {
	return r.ApiService.GetMyShortDescriptionPostExecute(r)
}

/*
GetMyShortDescriptionPost Method for GetMyShortDescriptionPost

Use this method to get the current bot short description for the given user language. Returns [BotShortDescription](https://core.telegram.org/bots/api/#botshortdescription) on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMyShortDescriptionPostRequest
*/
func (a *DefaultAPIService) GetMyShortDescriptionPost(ctx context.Context) ApiGetMyShortDescriptionPostRequest {
	return ApiGetMyShortDescriptionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMyShortDescriptionPost200Response
func (a *DefaultAPIService) GetMyShortDescriptionPostExecute(r ApiGetMyShortDescriptionPostRequest) (*GetMyShortDescriptionPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMyShortDescriptionPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetMyShortDescriptionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getMyShortDescription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "language_code", r.languageCode, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStarTransactionsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	offset *int32
	limit *int32
}

// Number of transactions to skip in the response
func (r ApiGetStarTransactionsPostRequest) Offset(offset int32) ApiGetStarTransactionsPostRequest {
	r.offset = &offset
	return r
}

// The maximum number of transactions to be retrieved. Values between 1-100 are accepted. Defaults to 100.
func (r ApiGetStarTransactionsPostRequest) Limit(limit int32) ApiGetStarTransactionsPostRequest {
	r.limit = &limit
	return r
}

func (r ApiGetStarTransactionsPostRequest) Execute() (*GetStarTransactionsPost200Response, *http.Response, error) {
	return r.ApiService.GetStarTransactionsPostExecute(r)
}

/*
GetStarTransactionsPost Method for GetStarTransactionsPost

Returns the bot's Telegram Star transactions in chronological order. On success, returns a [StarTransactions](https://core.telegram.org/bots/api/#startransactions) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetStarTransactionsPostRequest
*/
func (a *DefaultAPIService) GetStarTransactionsPost(ctx context.Context) ApiGetStarTransactionsPostRequest {
	return ApiGetStarTransactionsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetStarTransactionsPost200Response
func (a *DefaultAPIService) GetStarTransactionsPostExecute(r ApiGetStarTransactionsPostRequest) (*GetStarTransactionsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetStarTransactionsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetStarTransactionsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getStarTransactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "offset", r.offset, "", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limit", r.limit, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStickerSetPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	name *string
}

// Name of the sticker set
func (r ApiGetStickerSetPostRequest) Name(name string) ApiGetStickerSetPostRequest {
	r.name = &name
	return r
}

func (r ApiGetStickerSetPostRequest) Execute() (*GetStickerSetPost200Response, *http.Response, error) {
	return r.ApiService.GetStickerSetPostExecute(r)
}

/*
GetStickerSetPost Method for GetStickerSetPost

Use this method to get a sticker set. On success, a [StickerSet](https://core.telegram.org/bots/api/#stickerset) object is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetStickerSetPostRequest
*/
func (a *DefaultAPIService) GetStickerSetPost(ctx context.Context) ApiGetStickerSetPostRequest {
	return ApiGetStickerSetPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetStickerSetPost200Response
func (a *DefaultAPIService) GetStickerSetPostExecute(r ApiGetStickerSetPostRequest) (*GetStickerSetPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetStickerSetPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetStickerSetPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getStickerSet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUpdatesPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	offset *int32
	limit *int32
	timeout *int32
	allowedUpdates *[]string
}

// Identifier of the first update to be returned. Must be greater by one than the highest among the identifiers of previously received updates. By default, updates starting with the earliest unconfirmed update are returned. An update is considered confirmed as soon as [getUpdates](https://core.telegram.org/bots/api/#getupdates) is called with an *offset* higher than its *update\\\\_id*. The negative offset can be specified to retrieve updates starting from *-offset* update from the end of the updates queue. All previous updates will be forgotten.
func (r ApiGetUpdatesPostRequest) Offset(offset int32) ApiGetUpdatesPostRequest {
	r.offset = &offset
	return r
}

// Limits the number of updates to be retrieved. Values between 1-100 are accepted. Defaults to 100.
func (r ApiGetUpdatesPostRequest) Limit(limit int32) ApiGetUpdatesPostRequest {
	r.limit = &limit
	return r
}

// Timeout in seconds for long polling. Defaults to 0, i.e. usual short polling. Should be positive, short polling should be used for testing purposes only.
func (r ApiGetUpdatesPostRequest) Timeout(timeout int32) ApiGetUpdatesPostRequest {
	r.timeout = &timeout
	return r
}

// A JSON-serialized list of the update types you want your bot to receive. For example, specify &#x60;[\\\&quot;message\\\&quot;, \\\&quot;edited_channel_post\\\&quot;, \\\&quot;callback_query\\\&quot;]&#x60; to only receive updates of these types. See [Update](https://core.telegram.org/bots/api/#update) for a complete list of available update types. Specify an empty list to receive all update types except *chat\\\\_member*, *message\\\\_reaction*, and *message\\\\_reaction\\\\_count* (default). If not specified, the previous setting will be used.    Please note that this parameter doesn&#39;t affect updates created before the call to getUpdates, so unwanted updates may be received for a short period of time.
func (r ApiGetUpdatesPostRequest) AllowedUpdates(allowedUpdates []string) ApiGetUpdatesPostRequest {
	r.allowedUpdates = &allowedUpdates
	return r
}

func (r ApiGetUpdatesPostRequest) Execute() (*GetUpdatesPost200Response, *http.Response, error) {
	return r.ApiService.GetUpdatesPostExecute(r)
}

/*
GetUpdatesPost Method for GetUpdatesPost

Use this method to receive incoming updates using long polling ([wiki](https://en.wikipedia.org/wiki/Push_technology#Long_polling)). Returns an Array of [Update](https://core.telegram.org/bots/api/#update) objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUpdatesPostRequest
*/
func (a *DefaultAPIService) GetUpdatesPost(ctx context.Context) ApiGetUpdatesPostRequest {
	return ApiGetUpdatesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetUpdatesPost200Response
func (a *DefaultAPIService) GetUpdatesPostExecute(r ApiGetUpdatesPostRequest) (*GetUpdatesPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetUpdatesPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetUpdatesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getUpdates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "offset", r.offset, "", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limit", r.limit, "", "")
	}
	if r.timeout != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "timeout", r.timeout, "", "")
	}
	if r.allowedUpdates != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allowed_updates", r.allowedUpdates, "", "csv")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserChatBoostsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *GetUserChatBoostsPostRequestChatId
	userId *int32
}

func (r ApiGetUserChatBoostsPostRequest) ChatId(chatId GetUserChatBoostsPostRequestChatId) ApiGetUserChatBoostsPostRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the target user
func (r ApiGetUserChatBoostsPostRequest) UserId(userId int32) ApiGetUserChatBoostsPostRequest {
	r.userId = &userId
	return r
}

func (r ApiGetUserChatBoostsPostRequest) Execute() (*GetUserChatBoostsPost200Response, *http.Response, error) {
	return r.ApiService.GetUserChatBoostsPostExecute(r)
}

/*
GetUserChatBoostsPost Method for GetUserChatBoostsPost

Use this method to get the list of boosts added to a chat by a user. Requires administrator rights in the chat. Returns a [UserChatBoosts](https://core.telegram.org/bots/api/#userchatboosts) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserChatBoostsPostRequest
*/
func (a *DefaultAPIService) GetUserChatBoostsPost(ctx context.Context) ApiGetUserChatBoostsPostRequest {
	return ApiGetUserChatBoostsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetUserChatBoostsPost200Response
func (a *DefaultAPIService) GetUserChatBoostsPostExecute(r ApiGetUserChatBoostsPostRequest) (*GetUserChatBoostsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetUserChatBoostsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetUserChatBoostsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getUserChatBoosts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserProfilePhotosPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	offset *int32
	limit *int32
}

// Unique identifier of the target user
func (r ApiGetUserProfilePhotosPostRequest) UserId(userId int32) ApiGetUserProfilePhotosPostRequest {
	r.userId = &userId
	return r
}

// Sequential number of the first photo to be returned. By default, all photos are returned.
func (r ApiGetUserProfilePhotosPostRequest) Offset(offset int32) ApiGetUserProfilePhotosPostRequest {
	r.offset = &offset
	return r
}

// Limits the number of photos to be retrieved. Values between 1-100 are accepted. Defaults to 100.
func (r ApiGetUserProfilePhotosPostRequest) Limit(limit int32) ApiGetUserProfilePhotosPostRequest {
	r.limit = &limit
	return r
}

func (r ApiGetUserProfilePhotosPostRequest) Execute() (*GetUserProfilePhotosPost200Response, *http.Response, error) {
	return r.ApiService.GetUserProfilePhotosPostExecute(r)
}

/*
GetUserProfilePhotosPost Method for GetUserProfilePhotosPost

Use this method to get a list of profile pictures for a user. Returns a [UserProfilePhotos](https://core.telegram.org/bots/api/#userprofilephotos) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserProfilePhotosPostRequest
*/
func (a *DefaultAPIService) GetUserProfilePhotosPost(ctx context.Context) ApiGetUserProfilePhotosPostRequest {
	return ApiGetUserProfilePhotosPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetUserProfilePhotosPost200Response
func (a *DefaultAPIService) GetUserProfilePhotosPostExecute(r ApiGetUserProfilePhotosPostRequest) (*GetUserProfilePhotosPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetUserProfilePhotosPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetUserProfilePhotosPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getUserProfilePhotos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "offset", r.offset, "", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "limit", r.limit, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWebhookInfoPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiGetWebhookInfoPostRequest) Execute() (*GetWebhookInfoPost200Response, *http.Response, error) {
	return r.ApiService.GetWebhookInfoPostExecute(r)
}

/*
GetWebhookInfoPost Method for GetWebhookInfoPost

Use this method to get current webhook status. Requires no parameters. On success, returns a [WebhookInfo](https://core.telegram.org/bots/api/#webhookinfo) object. If the bot is using [getUpdates](https://core.telegram.org/bots/api/#getupdates), will return an object with the *url* field empty.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetWebhookInfoPostRequest
*/
func (a *DefaultAPIService) GetWebhookInfoPost(ctx context.Context) ApiGetWebhookInfoPostRequest {
	return ApiGetWebhookInfoPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetWebhookInfoPost200Response
func (a *DefaultAPIService) GetWebhookInfoPostExecute(r ApiGetWebhookInfoPostRequest) (*GetWebhookInfoPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetWebhookInfoPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetWebhookInfoPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getWebhookInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGiftPremiumSubscriptionPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	monthCount *int32
	starCount *int32
	text *string
	textParseMode *string
	textEntities *[]MessageEntity
}

// Unique identifier of the target user who will receive a Telegram Premium subscription
func (r ApiGiftPremiumSubscriptionPostRequest) UserId(userId int32) ApiGiftPremiumSubscriptionPostRequest {
	r.userId = &userId
	return r
}

// Number of months the Telegram Premium subscription will be active for the user; must be one of 3, 6, or 12
func (r ApiGiftPremiumSubscriptionPostRequest) MonthCount(monthCount int32) ApiGiftPremiumSubscriptionPostRequest {
	r.monthCount = &monthCount
	return r
}

// Number of Telegram Stars to pay for the Telegram Premium subscription; must be 1000 for 3 months, 1500 for 6 months, and 2500 for 12 months
func (r ApiGiftPremiumSubscriptionPostRequest) StarCount(starCount int32) ApiGiftPremiumSubscriptionPostRequest {
	r.starCount = &starCount
	return r
}

// Text that will be shown along with the service message about the subscription; 0-128 characters
func (r ApiGiftPremiumSubscriptionPostRequest) Text(text string) ApiGiftPremiumSubscriptionPostRequest {
	r.text = &text
	return r
}

// Mode for parsing entities in the text. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details. Entities other than “bold”, “italic”, “underline”, “strikethrough”, “spoiler”, and “custom\\\\_emoji” are ignored.
func (r ApiGiftPremiumSubscriptionPostRequest) TextParseMode(textParseMode string) ApiGiftPremiumSubscriptionPostRequest {
	r.textParseMode = &textParseMode
	return r
}

// A JSON-serialized list of special entities that appear in the gift text. It can be specified instead of *text\\\\_parse\\\\_mode*. Entities other than “bold”, “italic”, “underline”, “strikethrough”, “spoiler”, and “custom\\\\_emoji” are ignored.
func (r ApiGiftPremiumSubscriptionPostRequest) TextEntities(textEntities []MessageEntity) ApiGiftPremiumSubscriptionPostRequest {
	r.textEntities = &textEntities
	return r
}

func (r ApiGiftPremiumSubscriptionPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.GiftPremiumSubscriptionPostExecute(r)
}

/*
GiftPremiumSubscriptionPost Method for GiftPremiumSubscriptionPost

Gifts a Telegram Premium subscription to the given user. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGiftPremiumSubscriptionPostRequest
*/
func (a *DefaultAPIService) GiftPremiumSubscriptionPost(ctx context.Context) ApiGiftPremiumSubscriptionPostRequest {
	return ApiGiftPremiumSubscriptionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) GiftPremiumSubscriptionPostExecute(r ApiGiftPremiumSubscriptionPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GiftPremiumSubscriptionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/giftPremiumSubscription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.monthCount == nil {
		return localVarReturnValue, nil, reportError("monthCount is required and must be specified")
	}
	if r.starCount == nil {
		return localVarReturnValue, nil, reportError("starCount is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "month_count", r.monthCount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "star_count", r.starCount, "", "")
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "text", r.text, "", "")
	}
	if r.textParseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "text_parse_mode", r.textParseMode, "", "")
	}
	if r.textEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "text_entities", r.textEntities, "", "csv")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHideGeneralForumTopicPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *RestrictChatMemberPostRequestChatId
}

func (r ApiHideGeneralForumTopicPostRequest) ChatId(chatId RestrictChatMemberPostRequestChatId) ApiHideGeneralForumTopicPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiHideGeneralForumTopicPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.HideGeneralForumTopicPostExecute(r)
}

/*
HideGeneralForumTopicPost Method for HideGeneralForumTopicPost

Use this method to hide the 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. The topic will be automatically closed if it was open. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHideGeneralForumTopicPostRequest
*/
func (a *DefaultAPIService) HideGeneralForumTopicPost(ctx context.Context) ApiHideGeneralForumTopicPostRequest {
	return ApiHideGeneralForumTopicPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) HideGeneralForumTopicPostExecute(r ApiHideGeneralForumTopicPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.HideGeneralForumTopicPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hideGeneralForumTopic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLeaveChatPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *LeaveChatPostRequestChatId
}

func (r ApiLeaveChatPostRequest) ChatId(chatId LeaveChatPostRequestChatId) ApiLeaveChatPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiLeaveChatPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.LeaveChatPostExecute(r)
}

/*
LeaveChatPost Method for LeaveChatPost

Use this method for your bot to leave a group, supergroup or channel. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLeaveChatPostRequest
*/
func (a *DefaultAPIService) LeaveChatPost(ctx context.Context) ApiLeaveChatPostRequest {
	return ApiLeaveChatPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) LeaveChatPostExecute(r ApiLeaveChatPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.LeaveChatPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/leaveChat"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLogOutPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiLogOutPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.LogOutPostExecute(r)
}

/*
LogOutPost Method for LogOutPost

Use this method to log out from the cloud Bot API server before launching the bot locally. You **must** log out the bot before running it locally, otherwise there is no guarantee that the bot will receive updates. After a successful call, you can immediately log in on a local server, but will not be able to log in back to the cloud Bot API server for 10 minutes. Returns *True* on success. Requires no parameters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLogOutPostRequest
*/
func (a *DefaultAPIService) LogOutPost(ctx context.Context) ApiLogOutPostRequest {
	return ApiLogOutPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) LogOutPostExecute(r ApiLogOutPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.LogOutPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/logOut"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPinChatMessagePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	messageId *int32
	businessConnectionId *string
	disableNotification *bool
}

func (r ApiPinChatMessagePostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiPinChatMessagePostRequest {
	r.chatId = &chatId
	return r
}

// Identifier of a message to pin
func (r ApiPinChatMessagePostRequest) MessageId(messageId int32) ApiPinChatMessagePostRequest {
	r.messageId = &messageId
	return r
}

// Unique identifier of the business connection on behalf of which the message will be pinned
func (r ApiPinChatMessagePostRequest) BusinessConnectionId(businessConnectionId string) ApiPinChatMessagePostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Pass *True* if it is not necessary to send a notification to all chat members about the new pinned message. Notifications are always disabled in channels and private chats.
func (r ApiPinChatMessagePostRequest) DisableNotification(disableNotification bool) ApiPinChatMessagePostRequest {
	r.disableNotification = &disableNotification
	return r
}

func (r ApiPinChatMessagePostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.PinChatMessagePostExecute(r)
}

/*
PinChatMessagePost Method for PinChatMessagePost

Use this method to add a message to the list of pinned messages in a chat. If the chat is not a private chat, the bot must be an administrator in the chat for this to work and must have the 'can\_pin\_messages' administrator right in a supergroup or 'can\_edit\_messages' administrator right in a channel. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPinChatMessagePostRequest
*/
func (a *DefaultAPIService) PinChatMessagePost(ctx context.Context) ApiPinChatMessagePostRequest {
	return ApiPinChatMessagePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) PinChatMessagePostExecute(r ApiPinChatMessagePostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PinChatMessagePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pinChatMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.messageId == nil {
		return localVarReturnValue, nil, reportError("messageId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostStoryPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	content *InputStoryContent
	activePeriod *int32
	caption *string
	parseMode *string
	captionEntities *[]MessageEntity
	areas *[]StoryArea
	postToChatPage *bool
	protectContent *bool
}

// Unique identifier of the business connection
func (r ApiPostStoryPostRequest) BusinessConnectionId(businessConnectionId string) ApiPostStoryPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

func (r ApiPostStoryPostRequest) Content(content InputStoryContent) ApiPostStoryPostRequest {
	r.content = &content
	return r
}

// Period after which the story is moved to the archive, in seconds; must be one of &#x60;6 * 3600&#x60;, &#x60;12 * 3600&#x60;, &#x60;86400&#x60;, or &#x60;2 * 86400&#x60;
func (r ApiPostStoryPostRequest) ActivePeriod(activePeriod int32) ApiPostStoryPostRequest {
	r.activePeriod = &activePeriod
	return r
}

// Caption of the story, 0-2048 characters after entities parsing
func (r ApiPostStoryPostRequest) Caption(caption string) ApiPostStoryPostRequest {
	r.caption = &caption
	return r
}

// Mode for parsing entities in the story caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiPostStoryPostRequest) ParseMode(parseMode string) ApiPostStoryPostRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of *parse\\\\_mode*
func (r ApiPostStoryPostRequest) CaptionEntities(captionEntities []MessageEntity) ApiPostStoryPostRequest {
	r.captionEntities = &captionEntities
	return r
}

// A JSON-serialized list of clickable areas to be shown on the story
func (r ApiPostStoryPostRequest) Areas(areas []StoryArea) ApiPostStoryPostRequest {
	r.areas = &areas
	return r
}

// Pass *True* to keep the story accessible after it expires
func (r ApiPostStoryPostRequest) PostToChatPage(postToChatPage bool) ApiPostStoryPostRequest {
	r.postToChatPage = &postToChatPage
	return r
}

// Pass *True* if the content of the story must be protected from forwarding and screenshotting
func (r ApiPostStoryPostRequest) ProtectContent(protectContent bool) ApiPostStoryPostRequest {
	r.protectContent = &protectContent
	return r
}

func (r ApiPostStoryPostRequest) Execute() (*PostStoryPost200Response, *http.Response, error) {
	return r.ApiService.PostStoryPostExecute(r)
}

/*
PostStoryPost Method for PostStoryPost

Posts a story on behalf of a managed business account. Requires the *can\_manage\_stories* business bot right. Returns [Story](https://core.telegram.org/bots/api/#story) on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostStoryPostRequest
*/
func (a *DefaultAPIService) PostStoryPost(ctx context.Context) ApiPostStoryPostRequest {
	return ApiPostStoryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostStoryPost200Response
func (a *DefaultAPIService) PostStoryPostExecute(r ApiPostStoryPostRequest) (*PostStoryPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostStoryPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PostStoryPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/postStory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.content == nil {
		return localVarReturnValue, nil, reportError("content is required and must be specified")
	}
	if r.activePeriod == nil {
		return localVarReturnValue, nil, reportError("activePeriod is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "content", r.content, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "active_period", r.activePeriod, "", "")
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption", r.caption, "", "")
	}
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.captionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption_entities", r.captionEntities, "", "csv")
	}
	if r.areas != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "areas", r.areas, "", "csv")
	}
	if r.postToChatPage != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "post_to_chat_page", r.postToChatPage, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPromoteChatMemberPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	userId *int32
	isAnonymous *bool
	canManageChat *bool
	canDeleteMessages *bool
	canManageVideoChats *bool
	canRestrictMembers *bool
	canPromoteMembers *bool
	canChangeInfo *bool
	canInviteUsers *bool
	canPostStories *bool
	canEditStories *bool
	canDeleteStories *bool
	canPostMessages *bool
	canEditMessages *bool
	canPinMessages *bool
	canManageTopics *bool
}

func (r ApiPromoteChatMemberPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiPromoteChatMemberPostRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the target user
func (r ApiPromoteChatMemberPostRequest) UserId(userId int32) ApiPromoteChatMemberPostRequest {
	r.userId = &userId
	return r
}

// Pass *True* if the administrator&#39;s presence in the chat is hidden
func (r ApiPromoteChatMemberPostRequest) IsAnonymous(isAnonymous bool) ApiPromoteChatMemberPostRequest {
	r.isAnonymous = &isAnonymous
	return r
}

// Pass *True* if the administrator can access the chat event log, get boost list, see hidden supergroup and channel members, report spam messages and ignore slow mode. Implied by any other administrator privilege.
func (r ApiPromoteChatMemberPostRequest) CanManageChat(canManageChat bool) ApiPromoteChatMemberPostRequest {
	r.canManageChat = &canManageChat
	return r
}

// Pass *True* if the administrator can delete messages of other users
func (r ApiPromoteChatMemberPostRequest) CanDeleteMessages(canDeleteMessages bool) ApiPromoteChatMemberPostRequest {
	r.canDeleteMessages = &canDeleteMessages
	return r
}

// Pass *True* if the administrator can manage video chats
func (r ApiPromoteChatMemberPostRequest) CanManageVideoChats(canManageVideoChats bool) ApiPromoteChatMemberPostRequest {
	r.canManageVideoChats = &canManageVideoChats
	return r
}

// Pass *True* if the administrator can restrict, ban or unban chat members, or access supergroup statistics
func (r ApiPromoteChatMemberPostRequest) CanRestrictMembers(canRestrictMembers bool) ApiPromoteChatMemberPostRequest {
	r.canRestrictMembers = &canRestrictMembers
	return r
}

// Pass *True* if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by him)
func (r ApiPromoteChatMemberPostRequest) CanPromoteMembers(canPromoteMembers bool) ApiPromoteChatMemberPostRequest {
	r.canPromoteMembers = &canPromoteMembers
	return r
}

// Pass *True* if the administrator can change chat title, photo and other settings
func (r ApiPromoteChatMemberPostRequest) CanChangeInfo(canChangeInfo bool) ApiPromoteChatMemberPostRequest {
	r.canChangeInfo = &canChangeInfo
	return r
}

// Pass *True* if the administrator can invite new users to the chat
func (r ApiPromoteChatMemberPostRequest) CanInviteUsers(canInviteUsers bool) ApiPromoteChatMemberPostRequest {
	r.canInviteUsers = &canInviteUsers
	return r
}

// Pass *True* if the administrator can post stories to the chat
func (r ApiPromoteChatMemberPostRequest) CanPostStories(canPostStories bool) ApiPromoteChatMemberPostRequest {
	r.canPostStories = &canPostStories
	return r
}

// Pass *True* if the administrator can edit stories posted by other users, post stories to the chat page, pin chat stories, and access the chat&#39;s story archive
func (r ApiPromoteChatMemberPostRequest) CanEditStories(canEditStories bool) ApiPromoteChatMemberPostRequest {
	r.canEditStories = &canEditStories
	return r
}

// Pass *True* if the administrator can delete stories posted by other users
func (r ApiPromoteChatMemberPostRequest) CanDeleteStories(canDeleteStories bool) ApiPromoteChatMemberPostRequest {
	r.canDeleteStories = &canDeleteStories
	return r
}

// Pass *True* if the administrator can post messages in the channel, or access channel statistics; for channels only
func (r ApiPromoteChatMemberPostRequest) CanPostMessages(canPostMessages bool) ApiPromoteChatMemberPostRequest {
	r.canPostMessages = &canPostMessages
	return r
}

// Pass *True* if the administrator can edit messages of other users and can pin messages; for channels only
func (r ApiPromoteChatMemberPostRequest) CanEditMessages(canEditMessages bool) ApiPromoteChatMemberPostRequest {
	r.canEditMessages = &canEditMessages
	return r
}

// Pass *True* if the administrator can pin messages; for supergroups only
func (r ApiPromoteChatMemberPostRequest) CanPinMessages(canPinMessages bool) ApiPromoteChatMemberPostRequest {
	r.canPinMessages = &canPinMessages
	return r
}

// Pass *True* if the user is allowed to create, rename, close, and reopen forum topics; for supergroups only
func (r ApiPromoteChatMemberPostRequest) CanManageTopics(canManageTopics bool) ApiPromoteChatMemberPostRequest {
	r.canManageTopics = &canManageTopics
	return r
}

func (r ApiPromoteChatMemberPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.PromoteChatMemberPostExecute(r)
}

/*
PromoteChatMemberPost Method for PromoteChatMemberPost

Use this method to promote or demote a user in a supergroup or a channel. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Pass *False* for all boolean parameters to demote a user. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPromoteChatMemberPostRequest
*/
func (a *DefaultAPIService) PromoteChatMemberPost(ctx context.Context) ApiPromoteChatMemberPostRequest {
	return ApiPromoteChatMemberPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) PromoteChatMemberPostExecute(r ApiPromoteChatMemberPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PromoteChatMemberPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/promoteChatMember"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	if r.isAnonymous != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_anonymous", r.isAnonymous, "", "")
	}
	if r.canManageChat != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_manage_chat", r.canManageChat, "", "")
	}
	if r.canDeleteMessages != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_delete_messages", r.canDeleteMessages, "", "")
	}
	if r.canManageVideoChats != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_manage_video_chats", r.canManageVideoChats, "", "")
	}
	if r.canRestrictMembers != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_restrict_members", r.canRestrictMembers, "", "")
	}
	if r.canPromoteMembers != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_promote_members", r.canPromoteMembers, "", "")
	}
	if r.canChangeInfo != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_change_info", r.canChangeInfo, "", "")
	}
	if r.canInviteUsers != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_invite_users", r.canInviteUsers, "", "")
	}
	if r.canPostStories != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_post_stories", r.canPostStories, "", "")
	}
	if r.canEditStories != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_edit_stories", r.canEditStories, "", "")
	}
	if r.canDeleteStories != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_delete_stories", r.canDeleteStories, "", "")
	}
	if r.canPostMessages != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_post_messages", r.canPostMessages, "", "")
	}
	if r.canEditMessages != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_edit_messages", r.canEditMessages, "", "")
	}
	if r.canPinMessages != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_pin_messages", r.canPinMessages, "", "")
	}
	if r.canManageTopics != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "can_manage_topics", r.canManageTopics, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadBusinessMessagePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	chatId *int32
	messageId *int32
}

// Unique identifier of the business connection on behalf of which to read the message
func (r ApiReadBusinessMessagePostRequest) BusinessConnectionId(businessConnectionId string) ApiReadBusinessMessagePostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier of the chat in which the message was received. The chat must have been active in the last 24 hours.
func (r ApiReadBusinessMessagePostRequest) ChatId(chatId int32) ApiReadBusinessMessagePostRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the message to mark as read
func (r ApiReadBusinessMessagePostRequest) MessageId(messageId int32) ApiReadBusinessMessagePostRequest {
	r.messageId = &messageId
	return r
}

func (r ApiReadBusinessMessagePostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.ReadBusinessMessagePostExecute(r)
}

/*
ReadBusinessMessagePost Method for ReadBusinessMessagePost

Marks incoming message as read on behalf of a business account. Requires the *can\_read\_messages* business bot right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReadBusinessMessagePostRequest
*/
func (a *DefaultAPIService) ReadBusinessMessagePost(ctx context.Context) ApiReadBusinessMessagePostRequest {
	return ApiReadBusinessMessagePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) ReadBusinessMessagePostExecute(r ApiReadBusinessMessagePostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ReadBusinessMessagePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/readBusinessMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.messageId == nil {
		return localVarReturnValue, nil, reportError("messageId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRefundStarPaymentPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	telegramPaymentChargeId *string
}

// Identifier of the user whose payment will be refunded
func (r ApiRefundStarPaymentPostRequest) UserId(userId int32) ApiRefundStarPaymentPostRequest {
	r.userId = &userId
	return r
}

// Telegram payment identifier
func (r ApiRefundStarPaymentPostRequest) TelegramPaymentChargeId(telegramPaymentChargeId string) ApiRefundStarPaymentPostRequest {
	r.telegramPaymentChargeId = &telegramPaymentChargeId
	return r
}

func (r ApiRefundStarPaymentPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.RefundStarPaymentPostExecute(r)
}

/*
RefundStarPaymentPost Method for RefundStarPaymentPost

Refunds a successful payment in [Telegram Stars](https://t.me/BotNews/90). Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRefundStarPaymentPostRequest
*/
func (a *DefaultAPIService) RefundStarPaymentPost(ctx context.Context) ApiRefundStarPaymentPostRequest {
	return ApiRefundStarPaymentPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) RefundStarPaymentPostExecute(r ApiRefundStarPaymentPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RefundStarPaymentPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/refundStarPayment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.telegramPaymentChargeId == nil {
		return localVarReturnValue, nil, reportError("telegramPaymentChargeId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "telegram_payment_charge_id", r.telegramPaymentChargeId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveBusinessAccountProfilePhotoPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	isPublic *bool
}

// Unique identifier of the business connection
func (r ApiRemoveBusinessAccountProfilePhotoPostRequest) BusinessConnectionId(businessConnectionId string) ApiRemoveBusinessAccountProfilePhotoPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Pass True to remove the public photo, which is visible even if the main photo is hidden by the business account&#39;s privacy settings. After the main photo is removed, the previous profile photo (if present) becomes the main photo.
func (r ApiRemoveBusinessAccountProfilePhotoPostRequest) IsPublic(isPublic bool) ApiRemoveBusinessAccountProfilePhotoPostRequest {
	r.isPublic = &isPublic
	return r
}

func (r ApiRemoveBusinessAccountProfilePhotoPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.RemoveBusinessAccountProfilePhotoPostExecute(r)
}

/*
RemoveBusinessAccountProfilePhotoPost Method for RemoveBusinessAccountProfilePhotoPost

Removes the current profile photo of a managed business account. Requires the *can\_edit\_profile\_photo* business bot right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRemoveBusinessAccountProfilePhotoPostRequest
*/
func (a *DefaultAPIService) RemoveBusinessAccountProfilePhotoPost(ctx context.Context) ApiRemoveBusinessAccountProfilePhotoPostRequest {
	return ApiRemoveBusinessAccountProfilePhotoPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) RemoveBusinessAccountProfilePhotoPostExecute(r ApiRemoveBusinessAccountProfilePhotoPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RemoveBusinessAccountProfilePhotoPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/removeBusinessAccountProfilePhoto"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	if r.isPublic != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_public", r.isPublic, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveChatVerificationPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
}

func (r ApiRemoveChatVerificationPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiRemoveChatVerificationPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiRemoveChatVerificationPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.RemoveChatVerificationPostExecute(r)
}

/*
RemoveChatVerificationPost Method for RemoveChatVerificationPost

Removes verification from a chat that is currently verified [on behalf of the organization](https://telegram.org/verify#third-party-verification) represented by the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRemoveChatVerificationPostRequest
*/
func (a *DefaultAPIService) RemoveChatVerificationPost(ctx context.Context) ApiRemoveChatVerificationPostRequest {
	return ApiRemoveChatVerificationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) RemoveChatVerificationPostExecute(r ApiRemoveChatVerificationPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RemoveChatVerificationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/removeChatVerification"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveUserVerificationPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
}

// Unique identifier of the target user
func (r ApiRemoveUserVerificationPostRequest) UserId(userId int32) ApiRemoveUserVerificationPostRequest {
	r.userId = &userId
	return r
}

func (r ApiRemoveUserVerificationPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.RemoveUserVerificationPostExecute(r)
}

/*
RemoveUserVerificationPost Method for RemoveUserVerificationPost

Removes verification from a user who is currently verified [on behalf of the organization](https://telegram.org/verify#third-party-verification) represented by the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRemoveUserVerificationPostRequest
*/
func (a *DefaultAPIService) RemoveUserVerificationPost(ctx context.Context) ApiRemoveUserVerificationPostRequest {
	return ApiRemoveUserVerificationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) RemoveUserVerificationPostExecute(r ApiRemoveUserVerificationPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RemoveUserVerificationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/removeUserVerification"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReopenForumTopicPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *RestrictChatMemberPostRequestChatId
	messageThreadId *int32
}

func (r ApiReopenForumTopicPostRequest) ChatId(chatId RestrictChatMemberPostRequestChatId) ApiReopenForumTopicPostRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier for the target message thread of the forum topic
func (r ApiReopenForumTopicPostRequest) MessageThreadId(messageThreadId int32) ApiReopenForumTopicPostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

func (r ApiReopenForumTopicPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.ReopenForumTopicPostExecute(r)
}

/*
ReopenForumTopicPost Method for ReopenForumTopicPost

Use this method to reopen a closed topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights, unless it is the creator of the topic. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReopenForumTopicPostRequest
*/
func (a *DefaultAPIService) ReopenForumTopicPost(ctx context.Context) ApiReopenForumTopicPostRequest {
	return ApiReopenForumTopicPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) ReopenForumTopicPostExecute(r ApiReopenForumTopicPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ReopenForumTopicPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reopenForumTopic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.messageThreadId == nil {
		return localVarReturnValue, nil, reportError("messageThreadId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReopenGeneralForumTopicPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *RestrictChatMemberPostRequestChatId
}

func (r ApiReopenGeneralForumTopicPostRequest) ChatId(chatId RestrictChatMemberPostRequestChatId) ApiReopenGeneralForumTopicPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiReopenGeneralForumTopicPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.ReopenGeneralForumTopicPostExecute(r)
}

/*
ReopenGeneralForumTopicPost Method for ReopenGeneralForumTopicPost

Use this method to reopen a closed 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. The topic will be automatically unhidden if it was hidden. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReopenGeneralForumTopicPostRequest
*/
func (a *DefaultAPIService) ReopenGeneralForumTopicPost(ctx context.Context) ApiReopenGeneralForumTopicPostRequest {
	return ApiReopenGeneralForumTopicPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) ReopenGeneralForumTopicPostExecute(r ApiReopenGeneralForumTopicPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ReopenGeneralForumTopicPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/reopenGeneralForumTopic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceStickerInSetPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	name *string
	oldSticker *string
	sticker *InputSticker
}

// User identifier of the sticker set owner
func (r ApiReplaceStickerInSetPostRequest) UserId(userId int32) ApiReplaceStickerInSetPostRequest {
	r.userId = &userId
	return r
}

// Sticker set name
func (r ApiReplaceStickerInSetPostRequest) Name(name string) ApiReplaceStickerInSetPostRequest {
	r.name = &name
	return r
}

// File identifier of the replaced sticker
func (r ApiReplaceStickerInSetPostRequest) OldSticker(oldSticker string) ApiReplaceStickerInSetPostRequest {
	r.oldSticker = &oldSticker
	return r
}

func (r ApiReplaceStickerInSetPostRequest) Sticker(sticker InputSticker) ApiReplaceStickerInSetPostRequest {
	r.sticker = &sticker
	return r
}

func (r ApiReplaceStickerInSetPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.ReplaceStickerInSetPostExecute(r)
}

/*
ReplaceStickerInSetPost Method for ReplaceStickerInSetPost

Use this method to replace an existing sticker in a sticker set with a new one. The method is equivalent to calling [deleteStickerFromSet](https://core.telegram.org/bots/api/#deletestickerfromset), then [addStickerToSet](https://core.telegram.org/bots/api/#addstickertoset), then [setStickerPositionInSet](https://core.telegram.org/bots/api/#setstickerpositioninset). Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReplaceStickerInSetPostRequest
*/
func (a *DefaultAPIService) ReplaceStickerInSetPost(ctx context.Context) ApiReplaceStickerInSetPostRequest {
	return ApiReplaceStickerInSetPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) ReplaceStickerInSetPostExecute(r ApiReplaceStickerInSetPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ReplaceStickerInSetPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/replaceStickerInSet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.oldSticker == nil {
		return localVarReturnValue, nil, reportError("oldSticker is required and must be specified")
	}
	if r.sticker == nil {
		return localVarReturnValue, nil, reportError("sticker is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "old_sticker", r.oldSticker, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "sticker", r.sticker, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestrictChatMemberPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *RestrictChatMemberPostRequestChatId
	userId *int32
	permissions *ChatPermissions
	useIndependentChatPermissions *bool
	untilDate *int32
}

func (r ApiRestrictChatMemberPostRequest) ChatId(chatId RestrictChatMemberPostRequestChatId) ApiRestrictChatMemberPostRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the target user
func (r ApiRestrictChatMemberPostRequest) UserId(userId int32) ApiRestrictChatMemberPostRequest {
	r.userId = &userId
	return r
}

func (r ApiRestrictChatMemberPostRequest) Permissions(permissions ChatPermissions) ApiRestrictChatMemberPostRequest {
	r.permissions = &permissions
	return r
}

// Pass *True* if chat permissions are set independently. Otherwise, the *can\\\\_send\\\\_other\\\\_messages* and *can\\\\_add\\\\_web\\\\_page\\\\_previews* permissions will imply the *can\\\\_send\\\\_messages*, *can\\\\_send\\\\_audios*, *can\\\\_send\\\\_documents*, *can\\\\_send\\\\_photos*, *can\\\\_send\\\\_videos*, *can\\\\_send\\\\_video\\\\_notes*, and *can\\\\_send\\\\_voice\\\\_notes* permissions; the *can\\\\_send\\\\_polls* permission will imply the *can\\\\_send\\\\_messages* permission.
func (r ApiRestrictChatMemberPostRequest) UseIndependentChatPermissions(useIndependentChatPermissions bool) ApiRestrictChatMemberPostRequest {
	r.useIndependentChatPermissions = &useIndependentChatPermissions
	return r
}

// Date when restrictions will be lifted for the user; Unix time. If user is restricted for more than 366 days or less than 30 seconds from the current time, they are considered to be restricted forever
func (r ApiRestrictChatMemberPostRequest) UntilDate(untilDate int32) ApiRestrictChatMemberPostRequest {
	r.untilDate = &untilDate
	return r
}

func (r ApiRestrictChatMemberPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.RestrictChatMemberPostExecute(r)
}

/*
RestrictChatMemberPost Method for RestrictChatMemberPost

Use this method to restrict a user in a supergroup. The bot must be an administrator in the supergroup for this to work and must have the appropriate administrator rights. Pass *True* for all permissions to lift restrictions from a user. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRestrictChatMemberPostRequest
*/
func (a *DefaultAPIService) RestrictChatMemberPost(ctx context.Context) ApiRestrictChatMemberPostRequest {
	return ApiRestrictChatMemberPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) RestrictChatMemberPostExecute(r ApiRestrictChatMemberPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RestrictChatMemberPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/restrictChatMember"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.permissions == nil {
		return localVarReturnValue, nil, reportError("permissions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "permissions", r.permissions, "", "")
	if r.useIndependentChatPermissions != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "use_independent_chat_permissions", r.useIndependentChatPermissions, "", "")
	}
	if r.untilDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "until_date", r.untilDate, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRevokeChatInviteLinkPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *RevokeChatInviteLinkPostRequestChatId
	inviteLink *string
}

func (r ApiRevokeChatInviteLinkPostRequest) ChatId(chatId RevokeChatInviteLinkPostRequestChatId) ApiRevokeChatInviteLinkPostRequest {
	r.chatId = &chatId
	return r
}

// The invite link to revoke
func (r ApiRevokeChatInviteLinkPostRequest) InviteLink(inviteLink string) ApiRevokeChatInviteLinkPostRequest {
	r.inviteLink = &inviteLink
	return r
}

func (r ApiRevokeChatInviteLinkPostRequest) Execute() (*CreateChatInviteLinkPost200Response, *http.Response, error) {
	return r.ApiService.RevokeChatInviteLinkPostExecute(r)
}

/*
RevokeChatInviteLinkPost Method for RevokeChatInviteLinkPost

Use this method to revoke an invite link created by the bot. If the primary link is revoked, a new link is automatically generated. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns the revoked invite link as [ChatInviteLink](https://core.telegram.org/bots/api/#chatinvitelink) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRevokeChatInviteLinkPostRequest
*/
func (a *DefaultAPIService) RevokeChatInviteLinkPost(ctx context.Context) ApiRevokeChatInviteLinkPostRequest {
	return ApiRevokeChatInviteLinkPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateChatInviteLinkPost200Response
func (a *DefaultAPIService) RevokeChatInviteLinkPostExecute(r ApiRevokeChatInviteLinkPostRequest) (*CreateChatInviteLinkPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateChatInviteLinkPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RevokeChatInviteLinkPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revokeChatInviteLink"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.inviteLink == nil {
		return localVarReturnValue, nil, reportError("inviteLink is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "invite_link", r.inviteLink, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSavePreparedInlineMessagePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	result *InlineQueryResult
	allowUserChats *bool
	allowBotChats *bool
	allowGroupChats *bool
	allowChannelChats *bool
}

// Unique identifier of the target user that can use the prepared message
func (r ApiSavePreparedInlineMessagePostRequest) UserId(userId int32) ApiSavePreparedInlineMessagePostRequest {
	r.userId = &userId
	return r
}

func (r ApiSavePreparedInlineMessagePostRequest) Result(result InlineQueryResult) ApiSavePreparedInlineMessagePostRequest {
	r.result = &result
	return r
}

// Pass *True* if the message can be sent to private chats with users
func (r ApiSavePreparedInlineMessagePostRequest) AllowUserChats(allowUserChats bool) ApiSavePreparedInlineMessagePostRequest {
	r.allowUserChats = &allowUserChats
	return r
}

// Pass *True* if the message can be sent to private chats with bots
func (r ApiSavePreparedInlineMessagePostRequest) AllowBotChats(allowBotChats bool) ApiSavePreparedInlineMessagePostRequest {
	r.allowBotChats = &allowBotChats
	return r
}

// Pass *True* if the message can be sent to group and supergroup chats
func (r ApiSavePreparedInlineMessagePostRequest) AllowGroupChats(allowGroupChats bool) ApiSavePreparedInlineMessagePostRequest {
	r.allowGroupChats = &allowGroupChats
	return r
}

// Pass *True* if the message can be sent to channel chats
func (r ApiSavePreparedInlineMessagePostRequest) AllowChannelChats(allowChannelChats bool) ApiSavePreparedInlineMessagePostRequest {
	r.allowChannelChats = &allowChannelChats
	return r
}

func (r ApiSavePreparedInlineMessagePostRequest) Execute() (*SavePreparedInlineMessagePost200Response, *http.Response, error) {
	return r.ApiService.SavePreparedInlineMessagePostExecute(r)
}

/*
SavePreparedInlineMessagePost Method for SavePreparedInlineMessagePost

Stores a message that can be sent by a user of a Mini App. Returns a [PreparedInlineMessage](https://core.telegram.org/bots/api/#preparedinlinemessage) object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSavePreparedInlineMessagePostRequest
*/
func (a *DefaultAPIService) SavePreparedInlineMessagePost(ctx context.Context) ApiSavePreparedInlineMessagePostRequest {
	return ApiSavePreparedInlineMessagePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SavePreparedInlineMessagePost200Response
func (a *DefaultAPIService) SavePreparedInlineMessagePostExecute(r ApiSavePreparedInlineMessagePostRequest) (*SavePreparedInlineMessagePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SavePreparedInlineMessagePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SavePreparedInlineMessagePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/savePreparedInlineMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.result == nil {
		return localVarReturnValue, nil, reportError("result is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "result", r.result, "", "")
	if r.allowUserChats != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_user_chats", r.allowUserChats, "", "")
	}
	if r.allowBotChats != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_bot_chats", r.allowBotChats, "", "")
	}
	if r.allowGroupChats != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_group_chats", r.allowGroupChats, "", "")
	}
	if r.allowChannelChats != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_channel_chats", r.allowChannelChats, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendAnimationPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	animation *SendAnimationPostRequestAnimation
	businessConnectionId *string
	messageThreadId *int32
	duration *int32
	width *int32
	height *int32
	thumbnail *SendAudioPostRequestThumbnail
	caption *string
	parseMode *string
	captionEntities *[]MessageEntity
	showCaptionAboveMedia *bool
	hasSpoiler *bool
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessagePostRequestReplyMarkup
}

func (r ApiSendAnimationPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiSendAnimationPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiSendAnimationPostRequest) Animation(animation SendAnimationPostRequestAnimation) ApiSendAnimationPostRequest {
	r.animation = &animation
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiSendAnimationPostRequest) BusinessConnectionId(businessConnectionId string) ApiSendAnimationPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiSendAnimationPostRequest) MessageThreadId(messageThreadId int32) ApiSendAnimationPostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Duration of sent animation in seconds
func (r ApiSendAnimationPostRequest) Duration(duration int32) ApiSendAnimationPostRequest {
	r.duration = &duration
	return r
}

// Animation width
func (r ApiSendAnimationPostRequest) Width(width int32) ApiSendAnimationPostRequest {
	r.width = &width
	return r
}

// Animation height
func (r ApiSendAnimationPostRequest) Height(height int32) ApiSendAnimationPostRequest {
	r.height = &height
	return r
}

func (r ApiSendAnimationPostRequest) Thumbnail(thumbnail SendAudioPostRequestThumbnail) ApiSendAnimationPostRequest {
	r.thumbnail = &thumbnail
	return r
}

// Animation caption (may also be used when resending animation by *file\\\\_id*), 0-1024 characters after entities parsing
func (r ApiSendAnimationPostRequest) Caption(caption string) ApiSendAnimationPostRequest {
	r.caption = &caption
	return r
}

// Mode for parsing entities in the animation caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiSendAnimationPostRequest) ParseMode(parseMode string) ApiSendAnimationPostRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of *parse\\\\_mode*
func (r ApiSendAnimationPostRequest) CaptionEntities(captionEntities []MessageEntity) ApiSendAnimationPostRequest {
	r.captionEntities = &captionEntities
	return r
}

// Pass *True*, if the caption must be shown above the message media
func (r ApiSendAnimationPostRequest) ShowCaptionAboveMedia(showCaptionAboveMedia bool) ApiSendAnimationPostRequest {
	r.showCaptionAboveMedia = &showCaptionAboveMedia
	return r
}

// Pass *True* if the animation needs to be covered with a spoiler animation
func (r ApiSendAnimationPostRequest) HasSpoiler(hasSpoiler bool) ApiSendAnimationPostRequest {
	r.hasSpoiler = &hasSpoiler
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiSendAnimationPostRequest) DisableNotification(disableNotification bool) ApiSendAnimationPostRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiSendAnimationPostRequest) ProtectContent(protectContent bool) ApiSendAnimationPostRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiSendAnimationPostRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiSendAnimationPostRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiSendAnimationPostRequest) MessageEffectId(messageEffectId string) ApiSendAnimationPostRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiSendAnimationPostRequest) ReplyParameters(replyParameters ReplyParameters) ApiSendAnimationPostRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiSendAnimationPostRequest) ReplyMarkup(replyMarkup SendMessagePostRequestReplyMarkup) ApiSendAnimationPostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiSendAnimationPostRequest) Execute() (*SendMessagePost200Response, *http.Response, error) {
	return r.ApiService.SendAnimationPostExecute(r)
}

/*
SendAnimationPost Method for SendAnimationPost

Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without sound). On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned. Bots can currently send animation files of up to 50 MB in size, this limit may be changed in the future.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendAnimationPostRequest
*/
func (a *DefaultAPIService) SendAnimationPost(ctx context.Context) ApiSendAnimationPostRequest {
	return ApiSendAnimationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendMessagePost200Response
func (a *DefaultAPIService) SendAnimationPostExecute(r ApiSendAnimationPostRequest) (*SendMessagePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendMessagePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SendAnimationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendAnimation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.animation == nil {
		return localVarReturnValue, nil, reportError("animation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "animation", r.animation, "", "")
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "duration", r.duration, "", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "width", r.width, "", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "height", r.height, "", "")
	}
	if r.thumbnail != nil {
		paramJson, err := parameterToJson(*r.thumbnail)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("thumbnail", paramJson)
	}
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption", r.caption, "", "")
	}
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.captionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption_entities", r.captionEntities, "", "csv")
	}
	if r.showCaptionAboveMedia != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "show_caption_above_media", r.showCaptionAboveMedia, "", "")
	}
	if r.hasSpoiler != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "has_spoiler", r.hasSpoiler, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendAudioPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	audio *SendAudioPostRequestAudio
	businessConnectionId *string
	messageThreadId *int32
	caption *string
	parseMode *string
	captionEntities *[]MessageEntity
	duration *int32
	performer *string
	title *string
	thumbnail *SendAudioPostRequestThumbnail
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessagePostRequestReplyMarkup
}

func (r ApiSendAudioPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiSendAudioPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiSendAudioPostRequest) Audio(audio SendAudioPostRequestAudio) ApiSendAudioPostRequest {
	r.audio = &audio
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiSendAudioPostRequest) BusinessConnectionId(businessConnectionId string) ApiSendAudioPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiSendAudioPostRequest) MessageThreadId(messageThreadId int32) ApiSendAudioPostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Audio caption, 0-1024 characters after entities parsing
func (r ApiSendAudioPostRequest) Caption(caption string) ApiSendAudioPostRequest {
	r.caption = &caption
	return r
}

// Mode for parsing entities in the audio caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiSendAudioPostRequest) ParseMode(parseMode string) ApiSendAudioPostRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of *parse\\\\_mode*
func (r ApiSendAudioPostRequest) CaptionEntities(captionEntities []MessageEntity) ApiSendAudioPostRequest {
	r.captionEntities = &captionEntities
	return r
}

// Duration of the audio in seconds
func (r ApiSendAudioPostRequest) Duration(duration int32) ApiSendAudioPostRequest {
	r.duration = &duration
	return r
}

// Performer
func (r ApiSendAudioPostRequest) Performer(performer string) ApiSendAudioPostRequest {
	r.performer = &performer
	return r
}

// Track name
func (r ApiSendAudioPostRequest) Title(title string) ApiSendAudioPostRequest {
	r.title = &title
	return r
}

func (r ApiSendAudioPostRequest) Thumbnail(thumbnail SendAudioPostRequestThumbnail) ApiSendAudioPostRequest {
	r.thumbnail = &thumbnail
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiSendAudioPostRequest) DisableNotification(disableNotification bool) ApiSendAudioPostRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiSendAudioPostRequest) ProtectContent(protectContent bool) ApiSendAudioPostRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiSendAudioPostRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiSendAudioPostRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiSendAudioPostRequest) MessageEffectId(messageEffectId string) ApiSendAudioPostRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiSendAudioPostRequest) ReplyParameters(replyParameters ReplyParameters) ApiSendAudioPostRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiSendAudioPostRequest) ReplyMarkup(replyMarkup SendMessagePostRequestReplyMarkup) ApiSendAudioPostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiSendAudioPostRequest) Execute() (*SendMessagePost200Response, *http.Response, error) {
	return r.ApiService.SendAudioPostExecute(r)
}

/*
SendAudioPost Method for SendAudioPost

Use this method to send audio files, if you want Telegram clients to display them in the music player. Your audio must be in the .MP3 or .M4A format. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned. Bots can currently send audio files of up to 50 MB in size, this limit may be changed in the future.

For sending voice messages, use the [sendVoice](https://core.telegram.org/bots/api/#sendvoice) method instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendAudioPostRequest
*/
func (a *DefaultAPIService) SendAudioPost(ctx context.Context) ApiSendAudioPostRequest {
	return ApiSendAudioPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendMessagePost200Response
func (a *DefaultAPIService) SendAudioPostExecute(r ApiSendAudioPostRequest) (*SendMessagePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendMessagePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SendAudioPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendAudio"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.audio == nil {
		return localVarReturnValue, nil, reportError("audio is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "audio", r.audio, "", "")
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption", r.caption, "", "")
	}
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.captionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption_entities", r.captionEntities, "", "csv")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "duration", r.duration, "", "")
	}
	if r.performer != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "performer", r.performer, "", "")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "", "")
	}
	if r.thumbnail != nil {
		paramJson, err := parameterToJson(*r.thumbnail)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("thumbnail", paramJson)
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendChatActionPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	action *string
	businessConnectionId *string
	messageThreadId *int32
}

func (r ApiSendChatActionPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiSendChatActionPostRequest {
	r.chatId = &chatId
	return r
}

// Type of action to broadcast. Choose one, depending on what the user is about to receive: *typing* for [text messages](https://core.telegram.org/bots/api/#sendmessage), *upload\\\\_photo* for [photos](https://core.telegram.org/bots/api/#sendphoto), *record\\\\_video* or *upload\\\\_video* for [videos](https://core.telegram.org/bots/api/#sendvideo), *record\\\\_voice* or *upload\\\\_voice* for [voice notes](https://core.telegram.org/bots/api/#sendvoice), *upload\\\\_document* for [general files](https://core.telegram.org/bots/api/#senddocument), *choose\\\\_sticker* for [stickers](https://core.telegram.org/bots/api/#sendsticker), *find\\\\_location* for [location data](https://core.telegram.org/bots/api/#sendlocation), *record\\\\_video\\\\_note* or *upload\\\\_video\\\\_note* for [video notes](https://core.telegram.org/bots/api/#sendvideonote).
func (r ApiSendChatActionPostRequest) Action(action string) ApiSendChatActionPostRequest {
	r.action = &action
	return r
}

// Unique identifier of the business connection on behalf of which the action will be sent
func (r ApiSendChatActionPostRequest) BusinessConnectionId(businessConnectionId string) ApiSendChatActionPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread; for supergroups only
func (r ApiSendChatActionPostRequest) MessageThreadId(messageThreadId int32) ApiSendChatActionPostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

func (r ApiSendChatActionPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SendChatActionPostExecute(r)
}

/*
SendChatActionPost Method for SendChatActionPost

Use this method when you need to tell the user that something is happening on the bot's side. The status is set for 5 seconds or less (when a message arrives from your bot, Telegram clients clear its typing status). Returns *True* on success.

Example: The [ImageBot](https://t.me/imagebot) needs some time to process a request and upload the image. Instead of sending a text message along the lines of “Retrieving image, please wait…”, the bot may use [sendChatAction](https://core.telegram.org/bots/api/#sendchataction) with *action* = *upload\_photo*. The user will see a “sending photo” status for the bot.

We only recommend using this method when a response from the bot will take a **noticeable** amount of time to arrive.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendChatActionPostRequest
*/
func (a *DefaultAPIService) SendChatActionPost(ctx context.Context) ApiSendChatActionPostRequest {
	return ApiSendChatActionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SendChatActionPostExecute(r ApiSendChatActionPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SendChatActionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendChatAction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.action == nil {
		return localVarReturnValue, nil, reportError("action is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "action", r.action, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendContactPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	phoneNumber *string
	firstName *string
	businessConnectionId *string
	messageThreadId *int32
	lastName *string
	vcard *string
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessagePostRequestReplyMarkup
}

func (r ApiSendContactPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiSendContactPostRequest {
	r.chatId = &chatId
	return r
}

// Contact&#39;s phone number
func (r ApiSendContactPostRequest) PhoneNumber(phoneNumber string) ApiSendContactPostRequest {
	r.phoneNumber = &phoneNumber
	return r
}

// Contact&#39;s first name
func (r ApiSendContactPostRequest) FirstName(firstName string) ApiSendContactPostRequest {
	r.firstName = &firstName
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiSendContactPostRequest) BusinessConnectionId(businessConnectionId string) ApiSendContactPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiSendContactPostRequest) MessageThreadId(messageThreadId int32) ApiSendContactPostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Contact&#39;s last name
func (r ApiSendContactPostRequest) LastName(lastName string) ApiSendContactPostRequest {
	r.lastName = &lastName
	return r
}

// Additional data about the contact in the form of a [vCard](https://en.wikipedia.org/wiki/VCard), 0-2048 bytes
func (r ApiSendContactPostRequest) Vcard(vcard string) ApiSendContactPostRequest {
	r.vcard = &vcard
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiSendContactPostRequest) DisableNotification(disableNotification bool) ApiSendContactPostRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiSendContactPostRequest) ProtectContent(protectContent bool) ApiSendContactPostRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiSendContactPostRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiSendContactPostRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiSendContactPostRequest) MessageEffectId(messageEffectId string) ApiSendContactPostRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiSendContactPostRequest) ReplyParameters(replyParameters ReplyParameters) ApiSendContactPostRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiSendContactPostRequest) ReplyMarkup(replyMarkup SendMessagePostRequestReplyMarkup) ApiSendContactPostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiSendContactPostRequest) Execute() (*SendMessagePost200Response, *http.Response, error) {
	return r.ApiService.SendContactPostExecute(r)
}

/*
SendContactPost Method for SendContactPost

Use this method to send phone contacts. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendContactPostRequest
*/
func (a *DefaultAPIService) SendContactPost(ctx context.Context) ApiSendContactPostRequest {
	return ApiSendContactPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendMessagePost200Response
func (a *DefaultAPIService) SendContactPostExecute(r ApiSendContactPostRequest) (*SendMessagePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendMessagePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SendContactPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendContact"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.phoneNumber == nil {
		return localVarReturnValue, nil, reportError("phoneNumber is required and must be specified")
	}
	if r.firstName == nil {
		return localVarReturnValue, nil, reportError("firstName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "phone_number", r.phoneNumber, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "first_name", r.firstName, "", "")
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "last_name", r.lastName, "", "")
	}
	if r.vcard != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "vcard", r.vcard, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendDicePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	businessConnectionId *string
	messageThreadId *int32
	emoji *string
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessagePostRequestReplyMarkup
}

func (r ApiSendDicePostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiSendDicePostRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiSendDicePostRequest) BusinessConnectionId(businessConnectionId string) ApiSendDicePostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiSendDicePostRequest) MessageThreadId(messageThreadId int32) ApiSendDicePostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Emoji on which the dice throw animation is based. Currently, must be one of “🎲”, “🎯”, “🏀”, “⚽”, “🎳”, or “🎰”. Dice can have values 1-6 for “🎲”, “🎯” and “🎳”, values 1-5 for “🏀” and “⚽”, and values 1-64 for “🎰”. Defaults to “🎲”
func (r ApiSendDicePostRequest) Emoji(emoji string) ApiSendDicePostRequest {
	r.emoji = &emoji
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiSendDicePostRequest) DisableNotification(disableNotification bool) ApiSendDicePostRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding
func (r ApiSendDicePostRequest) ProtectContent(protectContent bool) ApiSendDicePostRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiSendDicePostRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiSendDicePostRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiSendDicePostRequest) MessageEffectId(messageEffectId string) ApiSendDicePostRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiSendDicePostRequest) ReplyParameters(replyParameters ReplyParameters) ApiSendDicePostRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiSendDicePostRequest) ReplyMarkup(replyMarkup SendMessagePostRequestReplyMarkup) ApiSendDicePostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiSendDicePostRequest) Execute() (*SendMessagePost200Response, *http.Response, error) {
	return r.ApiService.SendDicePostExecute(r)
}

/*
SendDicePost Method for SendDicePost

Use this method to send an animated emoji that will display a random value. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendDicePostRequest
*/
func (a *DefaultAPIService) SendDicePost(ctx context.Context) ApiSendDicePostRequest {
	return ApiSendDicePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendMessagePost200Response
func (a *DefaultAPIService) SendDicePostExecute(r ApiSendDicePostRequest) (*SendMessagePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendMessagePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SendDicePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendDice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	if r.emoji != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "emoji", r.emoji, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendDocumentPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	document *SendDocumentPostRequestDocument
	businessConnectionId *string
	messageThreadId *int32
	thumbnail *SendAudioPostRequestThumbnail
	caption *string
	parseMode *string
	captionEntities *[]MessageEntity
	disableContentTypeDetection *bool
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessagePostRequestReplyMarkup
}

func (r ApiSendDocumentPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiSendDocumentPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiSendDocumentPostRequest) Document(document SendDocumentPostRequestDocument) ApiSendDocumentPostRequest {
	r.document = &document
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiSendDocumentPostRequest) BusinessConnectionId(businessConnectionId string) ApiSendDocumentPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiSendDocumentPostRequest) MessageThreadId(messageThreadId int32) ApiSendDocumentPostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

func (r ApiSendDocumentPostRequest) Thumbnail(thumbnail SendAudioPostRequestThumbnail) ApiSendDocumentPostRequest {
	r.thumbnail = &thumbnail
	return r
}

// Document caption (may also be used when resending documents by *file\\\\_id*), 0-1024 characters after entities parsing
func (r ApiSendDocumentPostRequest) Caption(caption string) ApiSendDocumentPostRequest {
	r.caption = &caption
	return r
}

// Mode for parsing entities in the document caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiSendDocumentPostRequest) ParseMode(parseMode string) ApiSendDocumentPostRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of *parse\\\\_mode*
func (r ApiSendDocumentPostRequest) CaptionEntities(captionEntities []MessageEntity) ApiSendDocumentPostRequest {
	r.captionEntities = &captionEntities
	return r
}

// Disables automatic server-side content type detection for files uploaded using multipart/form-data
func (r ApiSendDocumentPostRequest) DisableContentTypeDetection(disableContentTypeDetection bool) ApiSendDocumentPostRequest {
	r.disableContentTypeDetection = &disableContentTypeDetection
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiSendDocumentPostRequest) DisableNotification(disableNotification bool) ApiSendDocumentPostRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiSendDocumentPostRequest) ProtectContent(protectContent bool) ApiSendDocumentPostRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiSendDocumentPostRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiSendDocumentPostRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiSendDocumentPostRequest) MessageEffectId(messageEffectId string) ApiSendDocumentPostRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiSendDocumentPostRequest) ReplyParameters(replyParameters ReplyParameters) ApiSendDocumentPostRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiSendDocumentPostRequest) ReplyMarkup(replyMarkup SendMessagePostRequestReplyMarkup) ApiSendDocumentPostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiSendDocumentPostRequest) Execute() (*SendMessagePost200Response, *http.Response, error) {
	return r.ApiService.SendDocumentPostExecute(r)
}

/*
SendDocumentPost Method for SendDocumentPost

Use this method to send general files. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned. Bots can currently send files of any type of up to 50 MB in size, this limit may be changed in the future.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendDocumentPostRequest
*/
func (a *DefaultAPIService) SendDocumentPost(ctx context.Context) ApiSendDocumentPostRequest {
	return ApiSendDocumentPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendMessagePost200Response
func (a *DefaultAPIService) SendDocumentPostExecute(r ApiSendDocumentPostRequest) (*SendMessagePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendMessagePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SendDocumentPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendDocument"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.document == nil {
		return localVarReturnValue, nil, reportError("document is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "document", r.document, "", "")
	if r.thumbnail != nil {
		paramJson, err := parameterToJson(*r.thumbnail)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("thumbnail", paramJson)
	}
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption", r.caption, "", "")
	}
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.captionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption_entities", r.captionEntities, "", "csv")
	}
	if r.disableContentTypeDetection != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_content_type_detection", r.disableContentTypeDetection, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendGamePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *int32
	gameShortName *string
	businessConnectionId *string
	messageThreadId *int32
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *InlineKeyboardMarkup
}

// Unique identifier for the target chat
func (r ApiSendGamePostRequest) ChatId(chatId int32) ApiSendGamePostRequest {
	r.chatId = &chatId
	return r
}

// Short name of the game, serves as the unique identifier for the game. Set up your games via [@BotFather](https://t.me/botfather).
func (r ApiSendGamePostRequest) GameShortName(gameShortName string) ApiSendGamePostRequest {
	r.gameShortName = &gameShortName
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiSendGamePostRequest) BusinessConnectionId(businessConnectionId string) ApiSendGamePostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiSendGamePostRequest) MessageThreadId(messageThreadId int32) ApiSendGamePostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiSendGamePostRequest) DisableNotification(disableNotification bool) ApiSendGamePostRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiSendGamePostRequest) ProtectContent(protectContent bool) ApiSendGamePostRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiSendGamePostRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiSendGamePostRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiSendGamePostRequest) MessageEffectId(messageEffectId string) ApiSendGamePostRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiSendGamePostRequest) ReplyParameters(replyParameters ReplyParameters) ApiSendGamePostRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiSendGamePostRequest) ReplyMarkup(replyMarkup InlineKeyboardMarkup) ApiSendGamePostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiSendGamePostRequest) Execute() (*SendMessagePost200Response, *http.Response, error) {
	return r.ApiService.SendGamePostExecute(r)
}

/*
SendGamePost Method for SendGamePost

Use this method to send a game. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendGamePostRequest
*/
func (a *DefaultAPIService) SendGamePost(ctx context.Context) ApiSendGamePostRequest {
	return ApiSendGamePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendMessagePost200Response
func (a *DefaultAPIService) SendGamePostExecute(r ApiSendGamePostRequest) (*SendMessagePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendMessagePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SendGamePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendGame"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.gameShortName == nil {
		return localVarReturnValue, nil, reportError("gameShortName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "game_short_name", r.gameShortName, "", "")
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendGiftPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	giftId *string
	userId *int32
	chatId *SendGiftPostRequestChatId
	payForUpgrade *bool
	text *string
	textParseMode *string
	textEntities *[]MessageEntity
}

// Identifier of the gift
func (r ApiSendGiftPostRequest) GiftId(giftId string) ApiSendGiftPostRequest {
	r.giftId = &giftId
	return r
}

// Required if *chat\\\\_id* is not specified. Unique identifier of the target user who will receive the gift.
func (r ApiSendGiftPostRequest) UserId(userId int32) ApiSendGiftPostRequest {
	r.userId = &userId
	return r
}

func (r ApiSendGiftPostRequest) ChatId(chatId SendGiftPostRequestChatId) ApiSendGiftPostRequest {
	r.chatId = &chatId
	return r
}

// Pass *True* to pay for the gift upgrade from the bot&#39;s balance, thereby making the upgrade free for the receiver
func (r ApiSendGiftPostRequest) PayForUpgrade(payForUpgrade bool) ApiSendGiftPostRequest {
	r.payForUpgrade = &payForUpgrade
	return r
}

// Text that will be shown along with the gift; 0-128 characters
func (r ApiSendGiftPostRequest) Text(text string) ApiSendGiftPostRequest {
	r.text = &text
	return r
}

// Mode for parsing entities in the text. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details. Entities other than “bold”, “italic”, “underline”, “strikethrough”, “spoiler”, and “custom\\\\_emoji” are ignored.
func (r ApiSendGiftPostRequest) TextParseMode(textParseMode string) ApiSendGiftPostRequest {
	r.textParseMode = &textParseMode
	return r
}

// A JSON-serialized list of special entities that appear in the gift text. It can be specified instead of *text\\\\_parse\\\\_mode*. Entities other than “bold”, “italic”, “underline”, “strikethrough”, “spoiler”, and “custom\\\\_emoji” are ignored.
func (r ApiSendGiftPostRequest) TextEntities(textEntities []MessageEntity) ApiSendGiftPostRequest {
	r.textEntities = &textEntities
	return r
}

func (r ApiSendGiftPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SendGiftPostExecute(r)
}

/*
SendGiftPost Method for SendGiftPost

Sends a gift to the given user or channel chat. The gift can't be converted to Telegram Stars by the receiver. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendGiftPostRequest
*/
func (a *DefaultAPIService) SendGiftPost(ctx context.Context) ApiSendGiftPostRequest {
	return ApiSendGiftPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SendGiftPostExecute(r ApiSendGiftPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SendGiftPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendGift"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.giftId == nil {
		return localVarReturnValue, nil, reportError("giftId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	}
	if r.chatId != nil {
		paramJson, err := parameterToJson(*r.chatId)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("chat_id", paramJson)
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "gift_id", r.giftId, "", "")
	if r.payForUpgrade != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pay_for_upgrade", r.payForUpgrade, "", "")
	}
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "text", r.text, "", "")
	}
	if r.textParseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "text_parse_mode", r.textParseMode, "", "")
	}
	if r.textEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "text_entities", r.textEntities, "", "csv")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendInvoicePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	title *string
	description *string
	payload *string
	currency *string
	prices *[]LabeledPrice
	messageThreadId *int32
	providerToken *string
	maxTipAmount *int32
	suggestedTipAmounts *[]int32
	startParameter *string
	providerData *string
	photoUrl *string
	photoSize *int32
	photoWidth *int32
	photoHeight *int32
	needName *bool
	needPhoneNumber *bool
	needEmail *bool
	needShippingAddress *bool
	sendPhoneNumberToProvider *bool
	sendEmailToProvider *bool
	isFlexible *bool
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *InlineKeyboardMarkup
}

func (r ApiSendInvoicePostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiSendInvoicePostRequest {
	r.chatId = &chatId
	return r
}

// Product name, 1-32 characters
func (r ApiSendInvoicePostRequest) Title(title string) ApiSendInvoicePostRequest {
	r.title = &title
	return r
}

// Product description, 1-255 characters
func (r ApiSendInvoicePostRequest) Description(description string) ApiSendInvoicePostRequest {
	r.description = &description
	return r
}

// Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use it for your internal processes.
func (r ApiSendInvoicePostRequest) Payload(payload string) ApiSendInvoicePostRequest {
	r.payload = &payload
	return r
}

// Three-letter ISO 4217 currency code, see [more on currencies](https://core.telegram.org/bots/payments#supported-currencies). Pass “XTR” for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiSendInvoicePostRequest) Currency(currency string) ApiSendInvoicePostRequest {
	r.currency = &currency
	return r
}

// Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.). Must contain exactly one item for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiSendInvoicePostRequest) Prices(prices []LabeledPrice) ApiSendInvoicePostRequest {
	r.prices = &prices
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiSendInvoicePostRequest) MessageThreadId(messageThreadId int32) ApiSendInvoicePostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Payment provider token, obtained via [@BotFather](https://t.me/botfather). Pass an empty string for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiSendInvoicePostRequest) ProviderToken(providerToken string) ApiSendInvoicePostRequest {
	r.providerToken = &providerToken
	return r
}

// The maximum accepted amount for tips in the *smallest units* of the currency (integer, **not** float/double). For example, for a maximum tip of &#x60;US$ 1.45&#x60; pass &#x60;max_tip_amount &#x3D; 145&#x60;. See the *exp* parameter in [currencies.json](https://core.telegram.org/bots/payments/currencies.json), it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0. Not supported for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiSendInvoicePostRequest) MaxTipAmount(maxTipAmount int32) ApiSendInvoicePostRequest {
	r.maxTipAmount = &maxTipAmount
	return r
}

// A JSON-serialized array of suggested amounts of tips in the *smallest units* of the currency (integer, **not** float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed *max\\\\_tip\\\\_amount*.
func (r ApiSendInvoicePostRequest) SuggestedTipAmounts(suggestedTipAmounts []int32) ApiSendInvoicePostRequest {
	r.suggestedTipAmounts = &suggestedTipAmounts
	return r
}

// Unique deep-linking parameter. If left empty, **forwarded copies** of the sent message will have a *Pay* button, allowing multiple users to pay directly from the forwarded message, using the same invoice. If non-empty, forwarded copies of the sent message will have a *URL* button with a deep link to the bot (instead of a *Pay* button), with the value used as the start parameter
func (r ApiSendInvoicePostRequest) StartParameter(startParameter string) ApiSendInvoicePostRequest {
	r.startParameter = &startParameter
	return r
}

// JSON-serialized data about the invoice, which will be shared with the payment provider. A detailed description of required fields should be provided by the payment provider.
func (r ApiSendInvoicePostRequest) ProviderData(providerData string) ApiSendInvoicePostRequest {
	r.providerData = &providerData
	return r
}

// URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service. People like it better when they see what they are paying for.
func (r ApiSendInvoicePostRequest) PhotoUrl(photoUrl string) ApiSendInvoicePostRequest {
	r.photoUrl = &photoUrl
	return r
}

// Photo size in bytes
func (r ApiSendInvoicePostRequest) PhotoSize(photoSize int32) ApiSendInvoicePostRequest {
	r.photoSize = &photoSize
	return r
}

// Photo width
func (r ApiSendInvoicePostRequest) PhotoWidth(photoWidth int32) ApiSendInvoicePostRequest {
	r.photoWidth = &photoWidth
	return r
}

// Photo height
func (r ApiSendInvoicePostRequest) PhotoHeight(photoHeight int32) ApiSendInvoicePostRequest {
	r.photoHeight = &photoHeight
	return r
}

// Pass *True* if you require the user&#39;s full name to complete the order. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiSendInvoicePostRequest) NeedName(needName bool) ApiSendInvoicePostRequest {
	r.needName = &needName
	return r
}

// Pass *True* if you require the user&#39;s phone number to complete the order. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiSendInvoicePostRequest) NeedPhoneNumber(needPhoneNumber bool) ApiSendInvoicePostRequest {
	r.needPhoneNumber = &needPhoneNumber
	return r
}

// Pass *True* if you require the user&#39;s email address to complete the order. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiSendInvoicePostRequest) NeedEmail(needEmail bool) ApiSendInvoicePostRequest {
	r.needEmail = &needEmail
	return r
}

// Pass *True* if you require the user&#39;s shipping address to complete the order. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiSendInvoicePostRequest) NeedShippingAddress(needShippingAddress bool) ApiSendInvoicePostRequest {
	r.needShippingAddress = &needShippingAddress
	return r
}

// Pass *True* if the user&#39;s phone number should be sent to the provider. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiSendInvoicePostRequest) SendPhoneNumberToProvider(sendPhoneNumberToProvider bool) ApiSendInvoicePostRequest {
	r.sendPhoneNumberToProvider = &sendPhoneNumberToProvider
	return r
}

// Pass *True* if the user&#39;s email address should be sent to the provider. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiSendInvoicePostRequest) SendEmailToProvider(sendEmailToProvider bool) ApiSendInvoicePostRequest {
	r.sendEmailToProvider = &sendEmailToProvider
	return r
}

// Pass *True* if the final price depends on the shipping method. Ignored for payments in [Telegram Stars](https://t.me/BotNews/90).
func (r ApiSendInvoicePostRequest) IsFlexible(isFlexible bool) ApiSendInvoicePostRequest {
	r.isFlexible = &isFlexible
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiSendInvoicePostRequest) DisableNotification(disableNotification bool) ApiSendInvoicePostRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiSendInvoicePostRequest) ProtectContent(protectContent bool) ApiSendInvoicePostRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiSendInvoicePostRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiSendInvoicePostRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiSendInvoicePostRequest) MessageEffectId(messageEffectId string) ApiSendInvoicePostRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiSendInvoicePostRequest) ReplyParameters(replyParameters ReplyParameters) ApiSendInvoicePostRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiSendInvoicePostRequest) ReplyMarkup(replyMarkup InlineKeyboardMarkup) ApiSendInvoicePostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiSendInvoicePostRequest) Execute() (*SendMessagePost200Response, *http.Response, error) {
	return r.ApiService.SendInvoicePostExecute(r)
}

/*
SendInvoicePost Method for SendInvoicePost

Use this method to send invoices. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendInvoicePostRequest
*/
func (a *DefaultAPIService) SendInvoicePost(ctx context.Context) ApiSendInvoicePostRequest {
	return ApiSendInvoicePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendMessagePost200Response
func (a *DefaultAPIService) SendInvoicePostExecute(r ApiSendInvoicePostRequest) (*SendMessagePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendMessagePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SendInvoicePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendInvoice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if strlen(*r.title) < 1 {
		return localVarReturnValue, nil, reportError("title must have at least 1 elements")
	}
	if strlen(*r.title) > 32 {
		return localVarReturnValue, nil, reportError("title must have less than 32 elements")
	}
	if r.description == nil {
		return localVarReturnValue, nil, reportError("description is required and must be specified")
	}
	if strlen(*r.description) < 1 {
		return localVarReturnValue, nil, reportError("description must have at least 1 elements")
	}
	if strlen(*r.description) > 255 {
		return localVarReturnValue, nil, reportError("description must have less than 255 elements")
	}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}
	if r.currency == nil {
		return localVarReturnValue, nil, reportError("currency is required and must be specified")
	}
	if r.prices == nil {
		return localVarReturnValue, nil, reportError("prices is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "payload", r.payload, "", "")
	if r.providerToken != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "provider_token", r.providerToken, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "currency", r.currency, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "prices", r.prices, "", "csv")
	if r.maxTipAmount != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "max_tip_amount", r.maxTipAmount, "", "")
	}
	if r.suggestedTipAmounts != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "suggested_tip_amounts", r.suggestedTipAmounts, "", "csv")
	}
	if r.startParameter != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "start_parameter", r.startParameter, "", "")
	}
	if r.providerData != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "provider_data", r.providerData, "", "")
	}
	if r.photoUrl != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "photo_url", r.photoUrl, "", "")
	}
	if r.photoSize != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "photo_size", r.photoSize, "", "")
	}
	if r.photoWidth != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "photo_width", r.photoWidth, "", "")
	}
	if r.photoHeight != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "photo_height", r.photoHeight, "", "")
	}
	if r.needName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "need_name", r.needName, "", "")
	}
	if r.needPhoneNumber != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "need_phone_number", r.needPhoneNumber, "", "")
	}
	if r.needEmail != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "need_email", r.needEmail, "", "")
	}
	if r.needShippingAddress != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "need_shipping_address", r.needShippingAddress, "", "")
	}
	if r.sendPhoneNumberToProvider != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "send_phone_number_to_provider", r.sendPhoneNumberToProvider, "", "")
	}
	if r.sendEmailToProvider != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "send_email_to_provider", r.sendEmailToProvider, "", "")
	}
	if r.isFlexible != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_flexible", r.isFlexible, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendLocationPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	latitude *float32
	longitude *float32
	businessConnectionId *string
	messageThreadId *int32
	horizontalAccuracy *float32
	livePeriod *int32
	heading *int32
	proximityAlertRadius *int32
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessagePostRequestReplyMarkup
}

func (r ApiSendLocationPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiSendLocationPostRequest {
	r.chatId = &chatId
	return r
}

// Latitude of the location
func (r ApiSendLocationPostRequest) Latitude(latitude float32) ApiSendLocationPostRequest {
	r.latitude = &latitude
	return r
}

// Longitude of the location
func (r ApiSendLocationPostRequest) Longitude(longitude float32) ApiSendLocationPostRequest {
	r.longitude = &longitude
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiSendLocationPostRequest) BusinessConnectionId(businessConnectionId string) ApiSendLocationPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiSendLocationPostRequest) MessageThreadId(messageThreadId int32) ApiSendLocationPostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// The radius of uncertainty for the location, measured in meters; 0-1500
func (r ApiSendLocationPostRequest) HorizontalAccuracy(horizontalAccuracy float32) ApiSendLocationPostRequest {
	r.horizontalAccuracy = &horizontalAccuracy
	return r
}

// Period in seconds during which the location will be updated (see [Live Locations](https://telegram.org/blog/live-locations), should be between 60 and 86400, or 0x7FFFFFFF for live locations that can be edited indefinitely.
func (r ApiSendLocationPostRequest) LivePeriod(livePeriod int32) ApiSendLocationPostRequest {
	r.livePeriod = &livePeriod
	return r
}

// For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified.
func (r ApiSendLocationPostRequest) Heading(heading int32) ApiSendLocationPostRequest {
	r.heading = &heading
	return r
}

// For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified.
func (r ApiSendLocationPostRequest) ProximityAlertRadius(proximityAlertRadius int32) ApiSendLocationPostRequest {
	r.proximityAlertRadius = &proximityAlertRadius
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiSendLocationPostRequest) DisableNotification(disableNotification bool) ApiSendLocationPostRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiSendLocationPostRequest) ProtectContent(protectContent bool) ApiSendLocationPostRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiSendLocationPostRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiSendLocationPostRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiSendLocationPostRequest) MessageEffectId(messageEffectId string) ApiSendLocationPostRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiSendLocationPostRequest) ReplyParameters(replyParameters ReplyParameters) ApiSendLocationPostRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiSendLocationPostRequest) ReplyMarkup(replyMarkup SendMessagePostRequestReplyMarkup) ApiSendLocationPostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiSendLocationPostRequest) Execute() (*SendMessagePost200Response, *http.Response, error) {
	return r.ApiService.SendLocationPostExecute(r)
}

/*
SendLocationPost Method for SendLocationPost

Use this method to send point on the map. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendLocationPostRequest
*/
func (a *DefaultAPIService) SendLocationPost(ctx context.Context) ApiSendLocationPostRequest {
	return ApiSendLocationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendMessagePost200Response
func (a *DefaultAPIService) SendLocationPostExecute(r ApiSendLocationPostRequest) (*SendMessagePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendMessagePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SendLocationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendLocation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.latitude == nil {
		return localVarReturnValue, nil, reportError("latitude is required and must be specified")
	}
	if r.longitude == nil {
		return localVarReturnValue, nil, reportError("longitude is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "latitude", r.latitude, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "longitude", r.longitude, "", "")
	if r.horizontalAccuracy != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "horizontal_accuracy", r.horizontalAccuracy, "", "")
	}
	if r.livePeriod != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "live_period", r.livePeriod, "", "")
	}
	if r.heading != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "heading", r.heading, "", "")
	}
	if r.proximityAlertRadius != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "proximity_alert_radius", r.proximityAlertRadius, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendMediaGroupPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	media *[]SendMediaGroupPostRequestMediaInner
	businessConnectionId *string
	messageThreadId *int32
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
}

func (r ApiSendMediaGroupPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiSendMediaGroupPostRequest {
	r.chatId = &chatId
	return r
}

// A JSON-serialized array describing messages to be sent, must include 2-10 items
func (r ApiSendMediaGroupPostRequest) Media(media []SendMediaGroupPostRequestMediaInner) ApiSendMediaGroupPostRequest {
	r.media = &media
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiSendMediaGroupPostRequest) BusinessConnectionId(businessConnectionId string) ApiSendMediaGroupPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiSendMediaGroupPostRequest) MessageThreadId(messageThreadId int32) ApiSendMediaGroupPostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Sends messages [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiSendMediaGroupPostRequest) DisableNotification(disableNotification bool) ApiSendMediaGroupPostRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent messages from forwarding and saving
func (r ApiSendMediaGroupPostRequest) ProtectContent(protectContent bool) ApiSendMediaGroupPostRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiSendMediaGroupPostRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiSendMediaGroupPostRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiSendMediaGroupPostRequest) MessageEffectId(messageEffectId string) ApiSendMediaGroupPostRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiSendMediaGroupPostRequest) ReplyParameters(replyParameters ReplyParameters) ApiSendMediaGroupPostRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiSendMediaGroupPostRequest) Execute() (*SendMediaGroupPost200Response, *http.Response, error) {
	return r.ApiService.SendMediaGroupPostExecute(r)
}

/*
SendMediaGroupPost Method for SendMediaGroupPost

Use this method to send a group of photos, videos, documents or audios as an album. Documents and audio files can be only grouped in an album with messages of the same type. On success, an array of [Messages](https://core.telegram.org/bots/api/#message) that were sent is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendMediaGroupPostRequest
*/
func (a *DefaultAPIService) SendMediaGroupPost(ctx context.Context) ApiSendMediaGroupPostRequest {
	return ApiSendMediaGroupPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendMediaGroupPost200Response
func (a *DefaultAPIService) SendMediaGroupPostExecute(r ApiSendMediaGroupPostRequest) (*SendMediaGroupPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendMediaGroupPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SendMediaGroupPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendMediaGroup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.media == nil {
		return localVarReturnValue, nil, reportError("media is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "media", r.media, "", "csv")
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendMessagePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	text *string
	businessConnectionId *string
	messageThreadId *int32
	parseMode *string
	entities *[]MessageEntity
	linkPreviewOptions *LinkPreviewOptions
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessagePostRequestReplyMarkup
}

func (r ApiSendMessagePostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiSendMessagePostRequest {
	r.chatId = &chatId
	return r
}

// Text of the message to be sent, 1-4096 characters after entities parsing
func (r ApiSendMessagePostRequest) Text(text string) ApiSendMessagePostRequest {
	r.text = &text
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiSendMessagePostRequest) BusinessConnectionId(businessConnectionId string) ApiSendMessagePostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiSendMessagePostRequest) MessageThreadId(messageThreadId int32) ApiSendMessagePostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Mode for parsing entities in the message text. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiSendMessagePostRequest) ParseMode(parseMode string) ApiSendMessagePostRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in message text, which can be specified instead of *parse\\\\_mode*
func (r ApiSendMessagePostRequest) Entities(entities []MessageEntity) ApiSendMessagePostRequest {
	r.entities = &entities
	return r
}

func (r ApiSendMessagePostRequest) LinkPreviewOptions(linkPreviewOptions LinkPreviewOptions) ApiSendMessagePostRequest {
	r.linkPreviewOptions = &linkPreviewOptions
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiSendMessagePostRequest) DisableNotification(disableNotification bool) ApiSendMessagePostRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiSendMessagePostRequest) ProtectContent(protectContent bool) ApiSendMessagePostRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiSendMessagePostRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiSendMessagePostRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiSendMessagePostRequest) MessageEffectId(messageEffectId string) ApiSendMessagePostRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiSendMessagePostRequest) ReplyParameters(replyParameters ReplyParameters) ApiSendMessagePostRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiSendMessagePostRequest) ReplyMarkup(replyMarkup SendMessagePostRequestReplyMarkup) ApiSendMessagePostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiSendMessagePostRequest) Execute() (*SendMessagePost200Response, *http.Response, error) {
	return r.ApiService.SendMessagePostExecute(r)
}

/*
SendMessagePost Method for SendMessagePost

Use this method to send text messages. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendMessagePostRequest
*/
func (a *DefaultAPIService) SendMessagePost(ctx context.Context) ApiSendMessagePostRequest {
	return ApiSendMessagePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendMessagePost200Response
func (a *DefaultAPIService) SendMessagePostExecute(r ApiSendMessagePostRequest) (*SendMessagePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendMessagePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SendMessagePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}
	if strlen(*r.text) < 1 {
		return localVarReturnValue, nil, reportError("text must have at least 1 elements")
	}
	if strlen(*r.text) > 4096 {
		return localVarReturnValue, nil, reportError("text must have less than 4096 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "text", r.text, "", "")
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.entities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "entities", r.entities, "", "csv")
	}
	if r.linkPreviewOptions != nil {
		paramJson, err := parameterToJson(*r.linkPreviewOptions)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("link_preview_options", paramJson)
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendPaidMediaPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendPaidMediaPostRequestChatId
	starCount *int32
	media *[]InputPaidMedia
	businessConnectionId *string
	payload *string
	caption *string
	parseMode *string
	captionEntities *[]MessageEntity
	showCaptionAboveMedia *bool
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	replyParameters *ReplyParameters
	replyMarkup *SendMessagePostRequestReplyMarkup
}

func (r ApiSendPaidMediaPostRequest) ChatId(chatId SendPaidMediaPostRequestChatId) ApiSendPaidMediaPostRequest {
	r.chatId = &chatId
	return r
}

// The number of Telegram Stars that must be paid to buy access to the media; 1-10000
func (r ApiSendPaidMediaPostRequest) StarCount(starCount int32) ApiSendPaidMediaPostRequest {
	r.starCount = &starCount
	return r
}

// A JSON-serialized array describing the media to be sent; up to 10 items
func (r ApiSendPaidMediaPostRequest) Media(media []InputPaidMedia) ApiSendPaidMediaPostRequest {
	r.media = &media
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiSendPaidMediaPostRequest) BusinessConnectionId(businessConnectionId string) ApiSendPaidMediaPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Bot-defined paid media payload, 0-128 bytes. This will not be displayed to the user, use it for your internal processes.
func (r ApiSendPaidMediaPostRequest) Payload(payload string) ApiSendPaidMediaPostRequest {
	r.payload = &payload
	return r
}

// Media caption, 0-1024 characters after entities parsing
func (r ApiSendPaidMediaPostRequest) Caption(caption string) ApiSendPaidMediaPostRequest {
	r.caption = &caption
	return r
}

// Mode for parsing entities in the media caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiSendPaidMediaPostRequest) ParseMode(parseMode string) ApiSendPaidMediaPostRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of *parse\\\\_mode*
func (r ApiSendPaidMediaPostRequest) CaptionEntities(captionEntities []MessageEntity) ApiSendPaidMediaPostRequest {
	r.captionEntities = &captionEntities
	return r
}

// Pass *True*, if the caption must be shown above the message media
func (r ApiSendPaidMediaPostRequest) ShowCaptionAboveMedia(showCaptionAboveMedia bool) ApiSendPaidMediaPostRequest {
	r.showCaptionAboveMedia = &showCaptionAboveMedia
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiSendPaidMediaPostRequest) DisableNotification(disableNotification bool) ApiSendPaidMediaPostRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiSendPaidMediaPostRequest) ProtectContent(protectContent bool) ApiSendPaidMediaPostRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiSendPaidMediaPostRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiSendPaidMediaPostRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

func (r ApiSendPaidMediaPostRequest) ReplyParameters(replyParameters ReplyParameters) ApiSendPaidMediaPostRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiSendPaidMediaPostRequest) ReplyMarkup(replyMarkup SendMessagePostRequestReplyMarkup) ApiSendPaidMediaPostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiSendPaidMediaPostRequest) Execute() (*SendMessagePost200Response, *http.Response, error) {
	return r.ApiService.SendPaidMediaPostExecute(r)
}

/*
SendPaidMediaPost Method for SendPaidMediaPost

Use this method to send paid media. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendPaidMediaPostRequest
*/
func (a *DefaultAPIService) SendPaidMediaPost(ctx context.Context) ApiSendPaidMediaPostRequest {
	return ApiSendPaidMediaPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendMessagePost200Response
func (a *DefaultAPIService) SendPaidMediaPostExecute(r ApiSendPaidMediaPostRequest) (*SendMessagePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendMessagePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SendPaidMediaPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendPaidMedia"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.starCount == nil {
		return localVarReturnValue, nil, reportError("starCount is required and must be specified")
	}
	if r.media == nil {
		return localVarReturnValue, nil, reportError("media is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "star_count", r.starCount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "media", r.media, "", "csv")
	if r.payload != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "payload", r.payload, "", "")
	}
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption", r.caption, "", "")
	}
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.captionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption_entities", r.captionEntities, "", "csv")
	}
	if r.showCaptionAboveMedia != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "show_caption_above_media", r.showCaptionAboveMedia, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendPhotoPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	photo *SendPhotoPostRequestPhoto
	businessConnectionId *string
	messageThreadId *int32
	caption *string
	parseMode *string
	captionEntities *[]MessageEntity
	showCaptionAboveMedia *bool
	hasSpoiler *bool
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessagePostRequestReplyMarkup
}

func (r ApiSendPhotoPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiSendPhotoPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiSendPhotoPostRequest) Photo(photo SendPhotoPostRequestPhoto) ApiSendPhotoPostRequest {
	r.photo = &photo
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiSendPhotoPostRequest) BusinessConnectionId(businessConnectionId string) ApiSendPhotoPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiSendPhotoPostRequest) MessageThreadId(messageThreadId int32) ApiSendPhotoPostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Photo caption (may also be used when resending photos by *file\\\\_id*), 0-1024 characters after entities parsing
func (r ApiSendPhotoPostRequest) Caption(caption string) ApiSendPhotoPostRequest {
	r.caption = &caption
	return r
}

// Mode for parsing entities in the photo caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiSendPhotoPostRequest) ParseMode(parseMode string) ApiSendPhotoPostRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of *parse\\\\_mode*
func (r ApiSendPhotoPostRequest) CaptionEntities(captionEntities []MessageEntity) ApiSendPhotoPostRequest {
	r.captionEntities = &captionEntities
	return r
}

// Pass *True*, if the caption must be shown above the message media
func (r ApiSendPhotoPostRequest) ShowCaptionAboveMedia(showCaptionAboveMedia bool) ApiSendPhotoPostRequest {
	r.showCaptionAboveMedia = &showCaptionAboveMedia
	return r
}

// Pass *True* if the photo needs to be covered with a spoiler animation
func (r ApiSendPhotoPostRequest) HasSpoiler(hasSpoiler bool) ApiSendPhotoPostRequest {
	r.hasSpoiler = &hasSpoiler
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiSendPhotoPostRequest) DisableNotification(disableNotification bool) ApiSendPhotoPostRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiSendPhotoPostRequest) ProtectContent(protectContent bool) ApiSendPhotoPostRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiSendPhotoPostRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiSendPhotoPostRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiSendPhotoPostRequest) MessageEffectId(messageEffectId string) ApiSendPhotoPostRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiSendPhotoPostRequest) ReplyParameters(replyParameters ReplyParameters) ApiSendPhotoPostRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiSendPhotoPostRequest) ReplyMarkup(replyMarkup SendMessagePostRequestReplyMarkup) ApiSendPhotoPostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiSendPhotoPostRequest) Execute() (*SendMessagePost200Response, *http.Response, error) {
	return r.ApiService.SendPhotoPostExecute(r)
}

/*
SendPhotoPost Method for SendPhotoPost

Use this method to send photos. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendPhotoPostRequest
*/
func (a *DefaultAPIService) SendPhotoPost(ctx context.Context) ApiSendPhotoPostRequest {
	return ApiSendPhotoPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendMessagePost200Response
func (a *DefaultAPIService) SendPhotoPostExecute(r ApiSendPhotoPostRequest) (*SendMessagePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendMessagePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SendPhotoPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendPhoto"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.photo == nil {
		return localVarReturnValue, nil, reportError("photo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "photo", r.photo, "", "")
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption", r.caption, "", "")
	}
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.captionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption_entities", r.captionEntities, "", "csv")
	}
	if r.showCaptionAboveMedia != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "show_caption_above_media", r.showCaptionAboveMedia, "", "")
	}
	if r.hasSpoiler != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "has_spoiler", r.hasSpoiler, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendPollPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	question *string
	options *[]InputPollOption
	businessConnectionId *string
	messageThreadId *int32
	questionParseMode *string
	questionEntities *[]MessageEntity
	isAnonymous *bool
	type_ *string
	allowsMultipleAnswers *bool
	correctOptionId *int32
	explanation *string
	explanationParseMode *string
	explanationEntities *[]MessageEntity
	openPeriod *int32
	closeDate *int32
	isClosed *bool
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessagePostRequestReplyMarkup
}

func (r ApiSendPollPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiSendPollPostRequest {
	r.chatId = &chatId
	return r
}

// Poll question, 1-300 characters
func (r ApiSendPollPostRequest) Question(question string) ApiSendPollPostRequest {
	r.question = &question
	return r
}

// A JSON-serialized list of 2-10 answer options
func (r ApiSendPollPostRequest) Options(options []InputPollOption) ApiSendPollPostRequest {
	r.options = &options
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiSendPollPostRequest) BusinessConnectionId(businessConnectionId string) ApiSendPollPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiSendPollPostRequest) MessageThreadId(messageThreadId int32) ApiSendPollPostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Mode for parsing entities in the question. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details. Currently, only custom emoji entities are allowed
func (r ApiSendPollPostRequest) QuestionParseMode(questionParseMode string) ApiSendPollPostRequest {
	r.questionParseMode = &questionParseMode
	return r
}

// A JSON-serialized list of special entities that appear in the poll question. It can be specified instead of *question\\\\_parse\\\\_mode*
func (r ApiSendPollPostRequest) QuestionEntities(questionEntities []MessageEntity) ApiSendPollPostRequest {
	r.questionEntities = &questionEntities
	return r
}

// *True*, if the poll needs to be anonymous, defaults to *True*
func (r ApiSendPollPostRequest) IsAnonymous(isAnonymous bool) ApiSendPollPostRequest {
	r.isAnonymous = &isAnonymous
	return r
}

// Poll type, “quiz” or “regular”, defaults to “regular”
func (r ApiSendPollPostRequest) Type_(type_ string) ApiSendPollPostRequest {
	r.type_ = &type_
	return r
}

// *True*, if the poll allows multiple answers, ignored for polls in quiz mode, defaults to *False*
func (r ApiSendPollPostRequest) AllowsMultipleAnswers(allowsMultipleAnswers bool) ApiSendPollPostRequest {
	r.allowsMultipleAnswers = &allowsMultipleAnswers
	return r
}

// 0-based identifier of the correct answer option, required for polls in quiz mode
func (r ApiSendPollPostRequest) CorrectOptionId(correctOptionId int32) ApiSendPollPostRequest {
	r.correctOptionId = &correctOptionId
	return r
}

// Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a quiz-style poll, 0-200 characters with at most 2 line feeds after entities parsing
func (r ApiSendPollPostRequest) Explanation(explanation string) ApiSendPollPostRequest {
	r.explanation = &explanation
	return r
}

// Mode for parsing entities in the explanation. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiSendPollPostRequest) ExplanationParseMode(explanationParseMode string) ApiSendPollPostRequest {
	r.explanationParseMode = &explanationParseMode
	return r
}

// A JSON-serialized list of special entities that appear in the poll explanation. It can be specified instead of *explanation\\\\_parse\\\\_mode*
func (r ApiSendPollPostRequest) ExplanationEntities(explanationEntities []MessageEntity) ApiSendPollPostRequest {
	r.explanationEntities = &explanationEntities
	return r
}

// Amount of time in seconds the poll will be active after creation, 5-600. Can&#39;t be used together with *close\\\\_date*.
func (r ApiSendPollPostRequest) OpenPeriod(openPeriod int32) ApiSendPollPostRequest {
	r.openPeriod = &openPeriod
	return r
}

// Point in time (Unix timestamp) when the poll will be automatically closed. Must be at least 5 and no more than 600 seconds in the future. Can&#39;t be used together with *open\\\\_period*.
func (r ApiSendPollPostRequest) CloseDate(closeDate int32) ApiSendPollPostRequest {
	r.closeDate = &closeDate
	return r
}

// Pass *True* if the poll needs to be immediately closed. This can be useful for poll preview.
func (r ApiSendPollPostRequest) IsClosed(isClosed bool) ApiSendPollPostRequest {
	r.isClosed = &isClosed
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiSendPollPostRequest) DisableNotification(disableNotification bool) ApiSendPollPostRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiSendPollPostRequest) ProtectContent(protectContent bool) ApiSendPollPostRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiSendPollPostRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiSendPollPostRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiSendPollPostRequest) MessageEffectId(messageEffectId string) ApiSendPollPostRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiSendPollPostRequest) ReplyParameters(replyParameters ReplyParameters) ApiSendPollPostRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiSendPollPostRequest) ReplyMarkup(replyMarkup SendMessagePostRequestReplyMarkup) ApiSendPollPostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiSendPollPostRequest) Execute() (*SendMessagePost200Response, *http.Response, error) {
	return r.ApiService.SendPollPostExecute(r)
}

/*
SendPollPost Method for SendPollPost

Use this method to send a native poll. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendPollPostRequest
*/
func (a *DefaultAPIService) SendPollPost(ctx context.Context) ApiSendPollPostRequest {
	return ApiSendPollPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendMessagePost200Response
func (a *DefaultAPIService) SendPollPostExecute(r ApiSendPollPostRequest) (*SendMessagePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendMessagePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SendPollPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendPoll"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.question == nil {
		return localVarReturnValue, nil, reportError("question is required and must be specified")
	}
	if strlen(*r.question) < 1 {
		return localVarReturnValue, nil, reportError("question must have at least 1 elements")
	}
	if strlen(*r.question) > 300 {
		return localVarReturnValue, nil, reportError("question must have less than 300 elements")
	}
	if r.options == nil {
		return localVarReturnValue, nil, reportError("options is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "question", r.question, "", "")
	if r.questionParseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "question_parse_mode", r.questionParseMode, "", "")
	}
	if r.questionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "question_entities", r.questionEntities, "", "csv")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "options", r.options, "", "csv")
	if r.isAnonymous != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_anonymous", r.isAnonymous, "", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	}
	if r.allowsMultipleAnswers != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allows_multiple_answers", r.allowsMultipleAnswers, "", "")
	}
	if r.correctOptionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "correct_option_id", r.correctOptionId, "", "")
	}
	if r.explanation != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "explanation", r.explanation, "", "")
	}
	if r.explanationParseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "explanation_parse_mode", r.explanationParseMode, "", "")
	}
	if r.explanationEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "explanation_entities", r.explanationEntities, "", "csv")
	}
	if r.openPeriod != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "open_period", r.openPeriod, "", "")
	}
	if r.closeDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "close_date", r.closeDate, "", "")
	}
	if r.isClosed != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_closed", r.isClosed, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendStickerPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	sticker *SendStickerPostRequestSticker
	businessConnectionId *string
	messageThreadId *int32
	emoji *string
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessagePostRequestReplyMarkup
}

func (r ApiSendStickerPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiSendStickerPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiSendStickerPostRequest) Sticker(sticker SendStickerPostRequestSticker) ApiSendStickerPostRequest {
	r.sticker = &sticker
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiSendStickerPostRequest) BusinessConnectionId(businessConnectionId string) ApiSendStickerPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiSendStickerPostRequest) MessageThreadId(messageThreadId int32) ApiSendStickerPostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Emoji associated with the sticker; only for just uploaded stickers
func (r ApiSendStickerPostRequest) Emoji(emoji string) ApiSendStickerPostRequest {
	r.emoji = &emoji
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiSendStickerPostRequest) DisableNotification(disableNotification bool) ApiSendStickerPostRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiSendStickerPostRequest) ProtectContent(protectContent bool) ApiSendStickerPostRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiSendStickerPostRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiSendStickerPostRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiSendStickerPostRequest) MessageEffectId(messageEffectId string) ApiSendStickerPostRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiSendStickerPostRequest) ReplyParameters(replyParameters ReplyParameters) ApiSendStickerPostRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiSendStickerPostRequest) ReplyMarkup(replyMarkup SendMessagePostRequestReplyMarkup) ApiSendStickerPostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiSendStickerPostRequest) Execute() (*SendMessagePost200Response, *http.Response, error) {
	return r.ApiService.SendStickerPostExecute(r)
}

/*
SendStickerPost Method for SendStickerPost

Use this method to send static .WEBP, [animated](https://telegram.org/blog/animated-stickers) .TGS, or [video](https://telegram.org/blog/video-stickers-better-reactions) .WEBM stickers. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendStickerPostRequest
*/
func (a *DefaultAPIService) SendStickerPost(ctx context.Context) ApiSendStickerPostRequest {
	return ApiSendStickerPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendMessagePost200Response
func (a *DefaultAPIService) SendStickerPostExecute(r ApiSendStickerPostRequest) (*SendMessagePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendMessagePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SendStickerPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendSticker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.sticker == nil {
		return localVarReturnValue, nil, reportError("sticker is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "sticker", r.sticker, "", "")
	if r.emoji != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "emoji", r.emoji, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendVenuePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	latitude *float32
	longitude *float32
	title *string
	address *string
	businessConnectionId *string
	messageThreadId *int32
	foursquareId *string
	foursquareType *string
	googlePlaceId *string
	googlePlaceType *string
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessagePostRequestReplyMarkup
}

func (r ApiSendVenuePostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiSendVenuePostRequest {
	r.chatId = &chatId
	return r
}

// Latitude of the venue
func (r ApiSendVenuePostRequest) Latitude(latitude float32) ApiSendVenuePostRequest {
	r.latitude = &latitude
	return r
}

// Longitude of the venue
func (r ApiSendVenuePostRequest) Longitude(longitude float32) ApiSendVenuePostRequest {
	r.longitude = &longitude
	return r
}

// Name of the venue
func (r ApiSendVenuePostRequest) Title(title string) ApiSendVenuePostRequest {
	r.title = &title
	return r
}

// Address of the venue
func (r ApiSendVenuePostRequest) Address(address string) ApiSendVenuePostRequest {
	r.address = &address
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiSendVenuePostRequest) BusinessConnectionId(businessConnectionId string) ApiSendVenuePostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiSendVenuePostRequest) MessageThreadId(messageThreadId int32) ApiSendVenuePostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Foursquare identifier of the venue
func (r ApiSendVenuePostRequest) FoursquareId(foursquareId string) ApiSendVenuePostRequest {
	r.foursquareId = &foursquareId
	return r
}

// Foursquare type of the venue, if known. (For example, “arts\\\\_entertainment/default”, “arts\\\\_entertainment/aquarium” or “food/icecream”.)
func (r ApiSendVenuePostRequest) FoursquareType(foursquareType string) ApiSendVenuePostRequest {
	r.foursquareType = &foursquareType
	return r
}

// Google Places identifier of the venue
func (r ApiSendVenuePostRequest) GooglePlaceId(googlePlaceId string) ApiSendVenuePostRequest {
	r.googlePlaceId = &googlePlaceId
	return r
}

// Google Places type of the venue. (See [supported types](https://developers.google.com/places/web-service/supported_types).)
func (r ApiSendVenuePostRequest) GooglePlaceType(googlePlaceType string) ApiSendVenuePostRequest {
	r.googlePlaceType = &googlePlaceType
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiSendVenuePostRequest) DisableNotification(disableNotification bool) ApiSendVenuePostRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiSendVenuePostRequest) ProtectContent(protectContent bool) ApiSendVenuePostRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiSendVenuePostRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiSendVenuePostRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiSendVenuePostRequest) MessageEffectId(messageEffectId string) ApiSendVenuePostRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiSendVenuePostRequest) ReplyParameters(replyParameters ReplyParameters) ApiSendVenuePostRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiSendVenuePostRequest) ReplyMarkup(replyMarkup SendMessagePostRequestReplyMarkup) ApiSendVenuePostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiSendVenuePostRequest) Execute() (*SendMessagePost200Response, *http.Response, error) {
	return r.ApiService.SendVenuePostExecute(r)
}

/*
SendVenuePost Method for SendVenuePost

Use this method to send information about a venue. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendVenuePostRequest
*/
func (a *DefaultAPIService) SendVenuePost(ctx context.Context) ApiSendVenuePostRequest {
	return ApiSendVenuePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendMessagePost200Response
func (a *DefaultAPIService) SendVenuePostExecute(r ApiSendVenuePostRequest) (*SendMessagePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendMessagePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SendVenuePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendVenue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.latitude == nil {
		return localVarReturnValue, nil, reportError("latitude is required and must be specified")
	}
	if r.longitude == nil {
		return localVarReturnValue, nil, reportError("longitude is required and must be specified")
	}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if r.address == nil {
		return localVarReturnValue, nil, reportError("address is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "latitude", r.latitude, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "longitude", r.longitude, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "address", r.address, "", "")
	if r.foursquareId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "foursquare_id", r.foursquareId, "", "")
	}
	if r.foursquareType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "foursquare_type", r.foursquareType, "", "")
	}
	if r.googlePlaceId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "google_place_id", r.googlePlaceId, "", "")
	}
	if r.googlePlaceType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "google_place_type", r.googlePlaceType, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendVideoNotePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	videoNote *SendVideoNotePostRequestVideoNote
	businessConnectionId *string
	messageThreadId *int32
	duration *int32
	length *int32
	thumbnail *SendAudioPostRequestThumbnail
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessagePostRequestReplyMarkup
}

func (r ApiSendVideoNotePostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiSendVideoNotePostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiSendVideoNotePostRequest) VideoNote(videoNote SendVideoNotePostRequestVideoNote) ApiSendVideoNotePostRequest {
	r.videoNote = &videoNote
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiSendVideoNotePostRequest) BusinessConnectionId(businessConnectionId string) ApiSendVideoNotePostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiSendVideoNotePostRequest) MessageThreadId(messageThreadId int32) ApiSendVideoNotePostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Duration of sent video in seconds
func (r ApiSendVideoNotePostRequest) Duration(duration int32) ApiSendVideoNotePostRequest {
	r.duration = &duration
	return r
}

// Video width and height, i.e. diameter of the video message
func (r ApiSendVideoNotePostRequest) Length(length int32) ApiSendVideoNotePostRequest {
	r.length = &length
	return r
}

func (r ApiSendVideoNotePostRequest) Thumbnail(thumbnail SendAudioPostRequestThumbnail) ApiSendVideoNotePostRequest {
	r.thumbnail = &thumbnail
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiSendVideoNotePostRequest) DisableNotification(disableNotification bool) ApiSendVideoNotePostRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiSendVideoNotePostRequest) ProtectContent(protectContent bool) ApiSendVideoNotePostRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiSendVideoNotePostRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiSendVideoNotePostRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiSendVideoNotePostRequest) MessageEffectId(messageEffectId string) ApiSendVideoNotePostRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiSendVideoNotePostRequest) ReplyParameters(replyParameters ReplyParameters) ApiSendVideoNotePostRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiSendVideoNotePostRequest) ReplyMarkup(replyMarkup SendMessagePostRequestReplyMarkup) ApiSendVideoNotePostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiSendVideoNotePostRequest) Execute() (*SendMessagePost200Response, *http.Response, error) {
	return r.ApiService.SendVideoNotePostExecute(r)
}

/*
SendVideoNotePost Method for SendVideoNotePost

As of [v.4.0](https://telegram.org/blog/video-messages-and-telescope), Telegram clients support rounded square MPEG4 videos of up to 1 minute long. Use this method to send video messages. On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendVideoNotePostRequest
*/
func (a *DefaultAPIService) SendVideoNotePost(ctx context.Context) ApiSendVideoNotePostRequest {
	return ApiSendVideoNotePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendMessagePost200Response
func (a *DefaultAPIService) SendVideoNotePostExecute(r ApiSendVideoNotePostRequest) (*SendMessagePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendMessagePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SendVideoNotePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendVideoNote"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.videoNote == nil {
		return localVarReturnValue, nil, reportError("videoNote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "video_note", r.videoNote, "", "")
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "duration", r.duration, "", "")
	}
	if r.length != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "length", r.length, "", "")
	}
	if r.thumbnail != nil {
		paramJson, err := parameterToJson(*r.thumbnail)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("thumbnail", paramJson)
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendVideoPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	video *SendVideoPostRequestVideo
	businessConnectionId *string
	messageThreadId *int32
	duration *int32
	width *int32
	height *int32
	thumbnail *SendAudioPostRequestThumbnail
	cover *SendVideoPostRequestCover
	startTimestamp *int32
	caption *string
	parseMode *string
	captionEntities *[]MessageEntity
	showCaptionAboveMedia *bool
	hasSpoiler *bool
	supportsStreaming *bool
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessagePostRequestReplyMarkup
}

func (r ApiSendVideoPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiSendVideoPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiSendVideoPostRequest) Video(video SendVideoPostRequestVideo) ApiSendVideoPostRequest {
	r.video = &video
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiSendVideoPostRequest) BusinessConnectionId(businessConnectionId string) ApiSendVideoPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiSendVideoPostRequest) MessageThreadId(messageThreadId int32) ApiSendVideoPostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Duration of sent video in seconds
func (r ApiSendVideoPostRequest) Duration(duration int32) ApiSendVideoPostRequest {
	r.duration = &duration
	return r
}

// Video width
func (r ApiSendVideoPostRequest) Width(width int32) ApiSendVideoPostRequest {
	r.width = &width
	return r
}

// Video height
func (r ApiSendVideoPostRequest) Height(height int32) ApiSendVideoPostRequest {
	r.height = &height
	return r
}

func (r ApiSendVideoPostRequest) Thumbnail(thumbnail SendAudioPostRequestThumbnail) ApiSendVideoPostRequest {
	r.thumbnail = &thumbnail
	return r
}

func (r ApiSendVideoPostRequest) Cover(cover SendVideoPostRequestCover) ApiSendVideoPostRequest {
	r.cover = &cover
	return r
}

// Start timestamp for the video in the message
func (r ApiSendVideoPostRequest) StartTimestamp(startTimestamp int32) ApiSendVideoPostRequest {
	r.startTimestamp = &startTimestamp
	return r
}

// Video caption (may also be used when resending videos by *file\\\\_id*), 0-1024 characters after entities parsing
func (r ApiSendVideoPostRequest) Caption(caption string) ApiSendVideoPostRequest {
	r.caption = &caption
	return r
}

// Mode for parsing entities in the video caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiSendVideoPostRequest) ParseMode(parseMode string) ApiSendVideoPostRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of *parse\\\\_mode*
func (r ApiSendVideoPostRequest) CaptionEntities(captionEntities []MessageEntity) ApiSendVideoPostRequest {
	r.captionEntities = &captionEntities
	return r
}

// Pass *True*, if the caption must be shown above the message media
func (r ApiSendVideoPostRequest) ShowCaptionAboveMedia(showCaptionAboveMedia bool) ApiSendVideoPostRequest {
	r.showCaptionAboveMedia = &showCaptionAboveMedia
	return r
}

// Pass *True* if the video needs to be covered with a spoiler animation
func (r ApiSendVideoPostRequest) HasSpoiler(hasSpoiler bool) ApiSendVideoPostRequest {
	r.hasSpoiler = &hasSpoiler
	return r
}

// Pass *True* if the uploaded video is suitable for streaming
func (r ApiSendVideoPostRequest) SupportsStreaming(supportsStreaming bool) ApiSendVideoPostRequest {
	r.supportsStreaming = &supportsStreaming
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiSendVideoPostRequest) DisableNotification(disableNotification bool) ApiSendVideoPostRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiSendVideoPostRequest) ProtectContent(protectContent bool) ApiSendVideoPostRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiSendVideoPostRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiSendVideoPostRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiSendVideoPostRequest) MessageEffectId(messageEffectId string) ApiSendVideoPostRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiSendVideoPostRequest) ReplyParameters(replyParameters ReplyParameters) ApiSendVideoPostRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiSendVideoPostRequest) ReplyMarkup(replyMarkup SendMessagePostRequestReplyMarkup) ApiSendVideoPostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiSendVideoPostRequest) Execute() (*SendMessagePost200Response, *http.Response, error) {
	return r.ApiService.SendVideoPostExecute(r)
}

/*
SendVideoPost Method for SendVideoPost

Use this method to send video files, Telegram clients support MPEG4 videos (other formats may be sent as [Document](https://core.telegram.org/bots/api/#document)). On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned. Bots can currently send video files of up to 50 MB in size, this limit may be changed in the future.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendVideoPostRequest
*/
func (a *DefaultAPIService) SendVideoPost(ctx context.Context) ApiSendVideoPostRequest {
	return ApiSendVideoPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendMessagePost200Response
func (a *DefaultAPIService) SendVideoPostExecute(r ApiSendVideoPostRequest) (*SendMessagePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendMessagePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SendVideoPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendVideo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.video == nil {
		return localVarReturnValue, nil, reportError("video is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "video", r.video, "", "")
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "duration", r.duration, "", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "width", r.width, "", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "height", r.height, "", "")
	}
	if r.thumbnail != nil {
		paramJson, err := parameterToJson(*r.thumbnail)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("thumbnail", paramJson)
	}
	if r.cover != nil {
		paramJson, err := parameterToJson(*r.cover)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("cover", paramJson)
	}
	if r.startTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "start_timestamp", r.startTimestamp, "", "")
	}
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption", r.caption, "", "")
	}
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.captionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption_entities", r.captionEntities, "", "csv")
	}
	if r.showCaptionAboveMedia != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "show_caption_above_media", r.showCaptionAboveMedia, "", "")
	}
	if r.hasSpoiler != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "has_spoiler", r.hasSpoiler, "", "")
	}
	if r.supportsStreaming != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "supports_streaming", r.supportsStreaming, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendVoicePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	voice *SendVoicePostRequestVoice
	businessConnectionId *string
	messageThreadId *int32
	caption *string
	parseMode *string
	captionEntities *[]MessageEntity
	duration *int32
	disableNotification *bool
	protectContent *bool
	allowPaidBroadcast *bool
	messageEffectId *string
	replyParameters *ReplyParameters
	replyMarkup *SendMessagePostRequestReplyMarkup
}

func (r ApiSendVoicePostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiSendVoicePostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiSendVoicePostRequest) Voice(voice SendVoicePostRequestVoice) ApiSendVoicePostRequest {
	r.voice = &voice
	return r
}

// Unique identifier of the business connection on behalf of which the message will be sent
func (r ApiSendVoicePostRequest) BusinessConnectionId(businessConnectionId string) ApiSendVoicePostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier for the target message thread (topic) of the forum; for forum supergroups only
func (r ApiSendVoicePostRequest) MessageThreadId(messageThreadId int32) ApiSendVoicePostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

// Voice message caption, 0-1024 characters after entities parsing
func (r ApiSendVoicePostRequest) Caption(caption string) ApiSendVoicePostRequest {
	r.caption = &caption
	return r
}

// Mode for parsing entities in the voice message caption. See [formatting options](https://core.telegram.org/bots/api/#formatting-options) for more details.
func (r ApiSendVoicePostRequest) ParseMode(parseMode string) ApiSendVoicePostRequest {
	r.parseMode = &parseMode
	return r
}

// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of *parse\\\\_mode*
func (r ApiSendVoicePostRequest) CaptionEntities(captionEntities []MessageEntity) ApiSendVoicePostRequest {
	r.captionEntities = &captionEntities
	return r
}

// Duration of the voice message in seconds
func (r ApiSendVoicePostRequest) Duration(duration int32) ApiSendVoicePostRequest {
	r.duration = &duration
	return r
}

// Sends the message [silently](https://telegram.org/blog/channels-2-0#silent-messages). Users will receive a notification with no sound.
func (r ApiSendVoicePostRequest) DisableNotification(disableNotification bool) ApiSendVoicePostRequest {
	r.disableNotification = &disableNotification
	return r
}

// Protects the contents of the sent message from forwarding and saving
func (r ApiSendVoicePostRequest) ProtectContent(protectContent bool) ApiSendVoicePostRequest {
	r.protectContent = &protectContent
	return r
}

// Pass *True* to allow up to 1000 messages per second, ignoring [broadcasting limits](https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once) for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot&#39;s balance
func (r ApiSendVoicePostRequest) AllowPaidBroadcast(allowPaidBroadcast bool) ApiSendVoicePostRequest {
	r.allowPaidBroadcast = &allowPaidBroadcast
	return r
}

// Unique identifier of the message effect to be added to the message; for private chats only
func (r ApiSendVoicePostRequest) MessageEffectId(messageEffectId string) ApiSendVoicePostRequest {
	r.messageEffectId = &messageEffectId
	return r
}

func (r ApiSendVoicePostRequest) ReplyParameters(replyParameters ReplyParameters) ApiSendVoicePostRequest {
	r.replyParameters = &replyParameters
	return r
}

func (r ApiSendVoicePostRequest) ReplyMarkup(replyMarkup SendMessagePostRequestReplyMarkup) ApiSendVoicePostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiSendVoicePostRequest) Execute() (*SendMessagePost200Response, *http.Response, error) {
	return r.ApiService.SendVoicePostExecute(r)
}

/*
SendVoicePost Method for SendVoicePost

Use this method to send audio files, if you want Telegram clients to display the file as a playable voice message. For this to work, your audio must be in an .OGG file encoded with OPUS, or in .MP3 format, or in .M4A format (other formats may be sent as [Audio](https://core.telegram.org/bots/api/#audio) or [Document](https://core.telegram.org/bots/api/#document)). On success, the sent [Message](https://core.telegram.org/bots/api/#message) is returned. Bots can currently send voice messages of up to 50 MB in size, this limit may be changed in the future.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendVoicePostRequest
*/
func (a *DefaultAPIService) SendVoicePost(ctx context.Context) ApiSendVoicePostRequest {
	return ApiSendVoicePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendMessagePost200Response
func (a *DefaultAPIService) SendVoicePostExecute(r ApiSendVoicePostRequest) (*SendMessagePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendMessagePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SendVoicePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sendVoice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.voice == nil {
		return localVarReturnValue, nil, reportError("voice is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageThreadId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "voice", r.voice, "", "")
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption", r.caption, "", "")
	}
	if r.parseMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "parse_mode", r.parseMode, "", "")
	}
	if r.captionEntities != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption_entities", r.captionEntities, "", "csv")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "duration", r.duration, "", "")
	}
	if r.disableNotification != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_notification", r.disableNotification, "", "")
	}
	if r.protectContent != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "protect_content", r.protectContent, "", "")
	}
	if r.allowPaidBroadcast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allow_paid_broadcast", r.allowPaidBroadcast, "", "")
	}
	if r.messageEffectId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_effect_id", r.messageEffectId, "", "")
	}
	if r.replyParameters != nil {
		paramJson, err := parameterToJson(*r.replyParameters)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_parameters", paramJson)
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetBusinessAccountBioPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	bio *string
}

// Unique identifier of the business connection
func (r ApiSetBusinessAccountBioPostRequest) BusinessConnectionId(businessConnectionId string) ApiSetBusinessAccountBioPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// The new value of the bio for the business account; 0-140 characters
func (r ApiSetBusinessAccountBioPostRequest) Bio(bio string) ApiSetBusinessAccountBioPostRequest {
	r.bio = &bio
	return r
}

func (r ApiSetBusinessAccountBioPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetBusinessAccountBioPostExecute(r)
}

/*
SetBusinessAccountBioPost Method for SetBusinessAccountBioPost

Changes the bio of a managed business account. Requires the *can\_change\_bio* business bot right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetBusinessAccountBioPostRequest
*/
func (a *DefaultAPIService) SetBusinessAccountBioPost(ctx context.Context) ApiSetBusinessAccountBioPostRequest {
	return ApiSetBusinessAccountBioPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetBusinessAccountBioPostExecute(r ApiSetBusinessAccountBioPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetBusinessAccountBioPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setBusinessAccountBio"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	if r.bio != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "bio", r.bio, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetBusinessAccountGiftSettingsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	showGiftButton *bool
	acceptedGiftTypes *AcceptedGiftTypes
}

// Unique identifier of the business connection
func (r ApiSetBusinessAccountGiftSettingsPostRequest) BusinessConnectionId(businessConnectionId string) ApiSetBusinessAccountGiftSettingsPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Pass True, if a button for sending a gift to the user or by the business account must always be shown in the input field
func (r ApiSetBusinessAccountGiftSettingsPostRequest) ShowGiftButton(showGiftButton bool) ApiSetBusinessAccountGiftSettingsPostRequest {
	r.showGiftButton = &showGiftButton
	return r
}

func (r ApiSetBusinessAccountGiftSettingsPostRequest) AcceptedGiftTypes(acceptedGiftTypes AcceptedGiftTypes) ApiSetBusinessAccountGiftSettingsPostRequest {
	r.acceptedGiftTypes = &acceptedGiftTypes
	return r
}

func (r ApiSetBusinessAccountGiftSettingsPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetBusinessAccountGiftSettingsPostExecute(r)
}

/*
SetBusinessAccountGiftSettingsPost Method for SetBusinessAccountGiftSettingsPost

Changes the privacy settings pertaining to incoming gifts in a managed business account. Requires the *can\_change\_gift\_settings* business bot right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetBusinessAccountGiftSettingsPostRequest
*/
func (a *DefaultAPIService) SetBusinessAccountGiftSettingsPost(ctx context.Context) ApiSetBusinessAccountGiftSettingsPostRequest {
	return ApiSetBusinessAccountGiftSettingsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetBusinessAccountGiftSettingsPostExecute(r ApiSetBusinessAccountGiftSettingsPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetBusinessAccountGiftSettingsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setBusinessAccountGiftSettings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.showGiftButton == nil {
		return localVarReturnValue, nil, reportError("showGiftButton is required and must be specified")
	}
	if r.acceptedGiftTypes == nil {
		return localVarReturnValue, nil, reportError("acceptedGiftTypes is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "show_gift_button", r.showGiftButton, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "accepted_gift_types", r.acceptedGiftTypes, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetBusinessAccountNamePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	firstName *string
	lastName *string
}

// Unique identifier of the business connection
func (r ApiSetBusinessAccountNamePostRequest) BusinessConnectionId(businessConnectionId string) ApiSetBusinessAccountNamePostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// The new value of the first name for the business account; 1-64 characters
func (r ApiSetBusinessAccountNamePostRequest) FirstName(firstName string) ApiSetBusinessAccountNamePostRequest {
	r.firstName = &firstName
	return r
}

// The new value of the last name for the business account; 0-64 characters
func (r ApiSetBusinessAccountNamePostRequest) LastName(lastName string) ApiSetBusinessAccountNamePostRequest {
	r.lastName = &lastName
	return r
}

func (r ApiSetBusinessAccountNamePostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetBusinessAccountNamePostExecute(r)
}

/*
SetBusinessAccountNamePost Method for SetBusinessAccountNamePost

Changes the first and last name of a managed business account. Requires the *can\_change\_name* business bot right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetBusinessAccountNamePostRequest
*/
func (a *DefaultAPIService) SetBusinessAccountNamePost(ctx context.Context) ApiSetBusinessAccountNamePostRequest {
	return ApiSetBusinessAccountNamePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetBusinessAccountNamePostExecute(r ApiSetBusinessAccountNamePostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetBusinessAccountNamePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setBusinessAccountName"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.firstName == nil {
		return localVarReturnValue, nil, reportError("firstName is required and must be specified")
	}
	if strlen(*r.firstName) < 1 {
		return localVarReturnValue, nil, reportError("firstName must have at least 1 elements")
	}
	if strlen(*r.firstName) > 64 {
		return localVarReturnValue, nil, reportError("firstName must have less than 64 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "first_name", r.firstName, "", "")
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "last_name", r.lastName, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetBusinessAccountProfilePhotoPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	photo *InputProfilePhoto
	isPublic *bool
}

// Unique identifier of the business connection
func (r ApiSetBusinessAccountProfilePhotoPostRequest) BusinessConnectionId(businessConnectionId string) ApiSetBusinessAccountProfilePhotoPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

func (r ApiSetBusinessAccountProfilePhotoPostRequest) Photo(photo InputProfilePhoto) ApiSetBusinessAccountProfilePhotoPostRequest {
	r.photo = &photo
	return r
}

// Pass True to set the public photo, which will be visible even if the main photo is hidden by the business account&#39;s privacy settings. An account can have only one public photo.
func (r ApiSetBusinessAccountProfilePhotoPostRequest) IsPublic(isPublic bool) ApiSetBusinessAccountProfilePhotoPostRequest {
	r.isPublic = &isPublic
	return r
}

func (r ApiSetBusinessAccountProfilePhotoPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetBusinessAccountProfilePhotoPostExecute(r)
}

/*
SetBusinessAccountProfilePhotoPost Method for SetBusinessAccountProfilePhotoPost

Changes the profile photo of a managed business account. Requires the *can\_edit\_profile\_photo* business bot right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetBusinessAccountProfilePhotoPostRequest
*/
func (a *DefaultAPIService) SetBusinessAccountProfilePhotoPost(ctx context.Context) ApiSetBusinessAccountProfilePhotoPostRequest {
	return ApiSetBusinessAccountProfilePhotoPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetBusinessAccountProfilePhotoPostExecute(r ApiSetBusinessAccountProfilePhotoPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetBusinessAccountProfilePhotoPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setBusinessAccountProfilePhoto"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.photo == nil {
		return localVarReturnValue, nil, reportError("photo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "photo", r.photo, "", "")
	if r.isPublic != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_public", r.isPublic, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetBusinessAccountUsernamePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	username *string
}

// Unique identifier of the business connection
func (r ApiSetBusinessAccountUsernamePostRequest) BusinessConnectionId(businessConnectionId string) ApiSetBusinessAccountUsernamePostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// The new value of the username for the business account; 0-32 characters
func (r ApiSetBusinessAccountUsernamePostRequest) Username(username string) ApiSetBusinessAccountUsernamePostRequest {
	r.username = &username
	return r
}

func (r ApiSetBusinessAccountUsernamePostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetBusinessAccountUsernamePostExecute(r)
}

/*
SetBusinessAccountUsernamePost Method for SetBusinessAccountUsernamePost

Changes the username of a managed business account. Requires the *can\_change\_username* business bot right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetBusinessAccountUsernamePostRequest
*/
func (a *DefaultAPIService) SetBusinessAccountUsernamePost(ctx context.Context) ApiSetBusinessAccountUsernamePostRequest {
	return ApiSetBusinessAccountUsernamePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetBusinessAccountUsernamePostExecute(r ApiSetBusinessAccountUsernamePostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetBusinessAccountUsernamePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setBusinessAccountUsername"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	if r.username != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "username", r.username, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetChatAdministratorCustomTitlePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *RestrictChatMemberPostRequestChatId
	userId *int32
	customTitle *string
}

func (r ApiSetChatAdministratorCustomTitlePostRequest) ChatId(chatId RestrictChatMemberPostRequestChatId) ApiSetChatAdministratorCustomTitlePostRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the target user
func (r ApiSetChatAdministratorCustomTitlePostRequest) UserId(userId int32) ApiSetChatAdministratorCustomTitlePostRequest {
	r.userId = &userId
	return r
}

// New custom title for the administrator; 0-16 characters, emoji are not allowed
func (r ApiSetChatAdministratorCustomTitlePostRequest) CustomTitle(customTitle string) ApiSetChatAdministratorCustomTitlePostRequest {
	r.customTitle = &customTitle
	return r
}

func (r ApiSetChatAdministratorCustomTitlePostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetChatAdministratorCustomTitlePostExecute(r)
}

/*
SetChatAdministratorCustomTitlePost Method for SetChatAdministratorCustomTitlePost

Use this method to set a custom title for an administrator in a supergroup promoted by the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetChatAdministratorCustomTitlePostRequest
*/
func (a *DefaultAPIService) SetChatAdministratorCustomTitlePost(ctx context.Context) ApiSetChatAdministratorCustomTitlePostRequest {
	return ApiSetChatAdministratorCustomTitlePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetChatAdministratorCustomTitlePostExecute(r ApiSetChatAdministratorCustomTitlePostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetChatAdministratorCustomTitlePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setChatAdministratorCustomTitle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.customTitle == nil {
		return localVarReturnValue, nil, reportError("customTitle is required and must be specified")
	}
	if strlen(*r.customTitle) < 0 {
		return localVarReturnValue, nil, reportError("customTitle must have at least 0 elements")
	}
	if strlen(*r.customTitle) > 16 {
		return localVarReturnValue, nil, reportError("customTitle must have less than 16 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "custom_title", r.customTitle, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetChatDescriptionPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	description *string
}

func (r ApiSetChatDescriptionPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiSetChatDescriptionPostRequest {
	r.chatId = &chatId
	return r
}

// New chat description, 0-255 characters
func (r ApiSetChatDescriptionPostRequest) Description(description string) ApiSetChatDescriptionPostRequest {
	r.description = &description
	return r
}

func (r ApiSetChatDescriptionPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetChatDescriptionPostExecute(r)
}

/*
SetChatDescriptionPost Method for SetChatDescriptionPost

Use this method to change the description of a group, a supergroup or a channel. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetChatDescriptionPostRequest
*/
func (a *DefaultAPIService) SetChatDescriptionPost(ctx context.Context) ApiSetChatDescriptionPostRequest {
	return ApiSetChatDescriptionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetChatDescriptionPostExecute(r ApiSetChatDescriptionPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetChatDescriptionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setChatDescription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetChatMenuButtonPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *int32
	menuButton *MenuButton
}

// Unique identifier for the target private chat. If not specified, default bot&#39;s menu button will be changed
func (r ApiSetChatMenuButtonPostRequest) ChatId(chatId int32) ApiSetChatMenuButtonPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiSetChatMenuButtonPostRequest) MenuButton(menuButton MenuButton) ApiSetChatMenuButtonPostRequest {
	r.menuButton = &menuButton
	return r
}

func (r ApiSetChatMenuButtonPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetChatMenuButtonPostExecute(r)
}

/*
SetChatMenuButtonPost Method for SetChatMenuButtonPost

Use this method to change the bot's menu button in a private chat, or the default menu button. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetChatMenuButtonPostRequest
*/
func (a *DefaultAPIService) SetChatMenuButtonPost(ctx context.Context) ApiSetChatMenuButtonPostRequest {
	return ApiSetChatMenuButtonPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetChatMenuButtonPostExecute(r ApiSetChatMenuButtonPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetChatMenuButtonPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setChatMenuButton"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.chatId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	}
	if r.menuButton != nil {
		paramJson, err := parameterToJson(*r.menuButton)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("menu_button", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetChatPermissionsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *RestrictChatMemberPostRequestChatId
	permissions *ChatPermissions
	useIndependentChatPermissions *bool
}

func (r ApiSetChatPermissionsPostRequest) ChatId(chatId RestrictChatMemberPostRequestChatId) ApiSetChatPermissionsPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiSetChatPermissionsPostRequest) Permissions(permissions ChatPermissions) ApiSetChatPermissionsPostRequest {
	r.permissions = &permissions
	return r
}

// Pass *True* if chat permissions are set independently. Otherwise, the *can\\\\_send\\\\_other\\\\_messages* and *can\\\\_add\\\\_web\\\\_page\\\\_previews* permissions will imply the *can\\\\_send\\\\_messages*, *can\\\\_send\\\\_audios*, *can\\\\_send\\\\_documents*, *can\\\\_send\\\\_photos*, *can\\\\_send\\\\_videos*, *can\\\\_send\\\\_video\\\\_notes*, and *can\\\\_send\\\\_voice\\\\_notes* permissions; the *can\\\\_send\\\\_polls* permission will imply the *can\\\\_send\\\\_messages* permission.
func (r ApiSetChatPermissionsPostRequest) UseIndependentChatPermissions(useIndependentChatPermissions bool) ApiSetChatPermissionsPostRequest {
	r.useIndependentChatPermissions = &useIndependentChatPermissions
	return r
}

func (r ApiSetChatPermissionsPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetChatPermissionsPostExecute(r)
}

/*
SetChatPermissionsPost Method for SetChatPermissionsPost

Use this method to set default chat permissions for all members. The bot must be an administrator in the group or a supergroup for this to work and must have the *can\_restrict\_members* administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetChatPermissionsPostRequest
*/
func (a *DefaultAPIService) SetChatPermissionsPost(ctx context.Context) ApiSetChatPermissionsPostRequest {
	return ApiSetChatPermissionsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetChatPermissionsPostExecute(r ApiSetChatPermissionsPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetChatPermissionsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setChatPermissions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.permissions == nil {
		return localVarReturnValue, nil, reportError("permissions is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "permissions", r.permissions, "", "")
	if r.useIndependentChatPermissions != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "use_independent_chat_permissions", r.useIndependentChatPermissions, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetChatPhotoPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	photo *interface{}
}

func (r ApiSetChatPhotoPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiSetChatPhotoPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiSetChatPhotoPostRequest) Photo(photo interface{}) ApiSetChatPhotoPostRequest {
	r.photo = &photo
	return r
}

func (r ApiSetChatPhotoPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetChatPhotoPostExecute(r)
}

/*
SetChatPhotoPost Method for SetChatPhotoPost

Use this method to set a new profile photo for the chat. Photos can't be changed for private chats. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetChatPhotoPostRequest
*/
func (a *DefaultAPIService) SetChatPhotoPost(ctx context.Context) ApiSetChatPhotoPostRequest {
	return ApiSetChatPhotoPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetChatPhotoPostExecute(r ApiSetChatPhotoPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetChatPhotoPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setChatPhoto"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.photo == nil {
		return localVarReturnValue, nil, reportError("photo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "photo", r.photo, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetChatStickerSetPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *RestrictChatMemberPostRequestChatId
	stickerSetName *string
}

func (r ApiSetChatStickerSetPostRequest) ChatId(chatId RestrictChatMemberPostRequestChatId) ApiSetChatStickerSetPostRequest {
	r.chatId = &chatId
	return r
}

// Name of the sticker set to be set as the group sticker set
func (r ApiSetChatStickerSetPostRequest) StickerSetName(stickerSetName string) ApiSetChatStickerSetPostRequest {
	r.stickerSetName = &stickerSetName
	return r
}

func (r ApiSetChatStickerSetPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetChatStickerSetPostExecute(r)
}

/*
SetChatStickerSetPost Method for SetChatStickerSetPost

Use this method to set a new group sticker set for a supergroup. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Use the field *can\_set\_sticker\_set* optionally returned in [getChat](https://core.telegram.org/bots/api/#getchat) requests to check if the bot can use this method. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetChatStickerSetPostRequest
*/
func (a *DefaultAPIService) SetChatStickerSetPost(ctx context.Context) ApiSetChatStickerSetPostRequest {
	return ApiSetChatStickerSetPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetChatStickerSetPostExecute(r ApiSetChatStickerSetPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetChatStickerSetPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setChatStickerSet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.stickerSetName == nil {
		return localVarReturnValue, nil, reportError("stickerSetName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "sticker_set_name", r.stickerSetName, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetChatTitlePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	title *string
}

func (r ApiSetChatTitlePostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiSetChatTitlePostRequest {
	r.chatId = &chatId
	return r
}

// New chat title, 1-128 characters
func (r ApiSetChatTitlePostRequest) Title(title string) ApiSetChatTitlePostRequest {
	r.title = &title
	return r
}

func (r ApiSetChatTitlePostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetChatTitlePostExecute(r)
}

/*
SetChatTitlePost Method for SetChatTitlePost

Use this method to change the title of a chat. Titles can't be changed for private chats. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetChatTitlePostRequest
*/
func (a *DefaultAPIService) SetChatTitlePost(ctx context.Context) ApiSetChatTitlePostRequest {
	return ApiSetChatTitlePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetChatTitlePostExecute(r ApiSetChatTitlePostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetChatTitlePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setChatTitle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if strlen(*r.title) < 1 {
		return localVarReturnValue, nil, reportError("title must have at least 1 elements")
	}
	if strlen(*r.title) > 128 {
		return localVarReturnValue, nil, reportError("title must have less than 128 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetCustomEmojiStickerSetThumbnailPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	name *string
	customEmojiId *string
}

// Sticker set name
func (r ApiSetCustomEmojiStickerSetThumbnailPostRequest) Name(name string) ApiSetCustomEmojiStickerSetThumbnailPostRequest {
	r.name = &name
	return r
}

// Custom emoji identifier of a sticker from the sticker set; pass an empty string to drop the thumbnail and use the first sticker as the thumbnail.
func (r ApiSetCustomEmojiStickerSetThumbnailPostRequest) CustomEmojiId(customEmojiId string) ApiSetCustomEmojiStickerSetThumbnailPostRequest {
	r.customEmojiId = &customEmojiId
	return r
}

func (r ApiSetCustomEmojiStickerSetThumbnailPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetCustomEmojiStickerSetThumbnailPostExecute(r)
}

/*
SetCustomEmojiStickerSetThumbnailPost Method for SetCustomEmojiStickerSetThumbnailPost

Use this method to set the thumbnail of a custom emoji sticker set. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetCustomEmojiStickerSetThumbnailPostRequest
*/
func (a *DefaultAPIService) SetCustomEmojiStickerSetThumbnailPost(ctx context.Context) ApiSetCustomEmojiStickerSetThumbnailPostRequest {
	return ApiSetCustomEmojiStickerSetThumbnailPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetCustomEmojiStickerSetThumbnailPostExecute(r ApiSetCustomEmojiStickerSetThumbnailPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetCustomEmojiStickerSetThumbnailPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setCustomEmojiStickerSetThumbnail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	if r.customEmojiId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "custom_emoji_id", r.customEmojiId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetGameScorePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	score *int32
	force *bool
	disableEditMessage *bool
	chatId *int32
	messageId *int32
	inlineMessageId *string
}

// User identifier
func (r ApiSetGameScorePostRequest) UserId(userId int32) ApiSetGameScorePostRequest {
	r.userId = &userId
	return r
}

// New score, must be non-negative
func (r ApiSetGameScorePostRequest) Score(score int32) ApiSetGameScorePostRequest {
	r.score = &score
	return r
}

// Pass *True* if the high score is allowed to decrease. This can be useful when fixing mistakes or banning cheaters
func (r ApiSetGameScorePostRequest) Force(force bool) ApiSetGameScorePostRequest {
	r.force = &force
	return r
}

// Pass *True* if the game message should not be automatically edited to include the current scoreboard
func (r ApiSetGameScorePostRequest) DisableEditMessage(disableEditMessage bool) ApiSetGameScorePostRequest {
	r.disableEditMessage = &disableEditMessage
	return r
}

// Required if *inline\\\\_message\\\\_id* is not specified. Unique identifier for the target chat
func (r ApiSetGameScorePostRequest) ChatId(chatId int32) ApiSetGameScorePostRequest {
	r.chatId = &chatId
	return r
}

// Required if *inline\\\\_message\\\\_id* is not specified. Identifier of the sent message
func (r ApiSetGameScorePostRequest) MessageId(messageId int32) ApiSetGameScorePostRequest {
	r.messageId = &messageId
	return r
}

// Required if *chat\\\\_id* and *message\\\\_id* are not specified. Identifier of the inline message
func (r ApiSetGameScorePostRequest) InlineMessageId(inlineMessageId string) ApiSetGameScorePostRequest {
	r.inlineMessageId = &inlineMessageId
	return r
}

func (r ApiSetGameScorePostRequest) Execute() (*EditMessageTextPost200Response, *http.Response, error) {
	return r.ApiService.SetGameScorePostExecute(r)
}

/*
SetGameScorePost Method for SetGameScorePost

Use this method to set the score of the specified user in a game message. On success, if the message is not an inline message, the [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned. Returns an error, if the new score is not greater than the user's current score in the chat and *force* is *False*.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetGameScorePostRequest
*/
func (a *DefaultAPIService) SetGameScorePost(ctx context.Context) ApiSetGameScorePostRequest {
	return ApiSetGameScorePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EditMessageTextPost200Response
func (a *DefaultAPIService) SetGameScorePostExecute(r ApiSetGameScorePostRequest) (*EditMessageTextPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EditMessageTextPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetGameScorePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setGameScore"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.score == nil {
		return localVarReturnValue, nil, reportError("score is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "score", r.score, "", "")
	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "force", r.force, "", "")
	}
	if r.disableEditMessage != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "disable_edit_message", r.disableEditMessage, "", "")
	}
	if r.chatId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	}
	if r.messageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	}
	if r.inlineMessageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "inline_message_id", r.inlineMessageId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetMessageReactionPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	messageId *int32
	reaction *[]ReactionType
	isBig *bool
}

func (r ApiSetMessageReactionPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiSetMessageReactionPostRequest {
	r.chatId = &chatId
	return r
}

// Identifier of the target message. If the message belongs to a media group, the reaction is set to the first non-deleted message in the group instead.
func (r ApiSetMessageReactionPostRequest) MessageId(messageId int32) ApiSetMessageReactionPostRequest {
	r.messageId = &messageId
	return r
}

// A JSON-serialized list of reaction types to set on the message. Currently, as non-premium users, bots can set up to one reaction per message. A custom emoji reaction can be used if it is either already present on the message or explicitly allowed by chat administrators. Paid reactions can&#39;t be used by bots.
func (r ApiSetMessageReactionPostRequest) Reaction(reaction []ReactionType) ApiSetMessageReactionPostRequest {
	r.reaction = &reaction
	return r
}

// Pass *True* to set the reaction with a big animation
func (r ApiSetMessageReactionPostRequest) IsBig(isBig bool) ApiSetMessageReactionPostRequest {
	r.isBig = &isBig
	return r
}

func (r ApiSetMessageReactionPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetMessageReactionPostExecute(r)
}

/*
SetMessageReactionPost Method for SetMessageReactionPost

Use this method to change the chosen reactions on a message. Service messages of some types can't be reacted to. Automatically forwarded messages from a channel to its discussion group have the same available reactions as messages in the channel. Bots can't use paid reactions. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetMessageReactionPostRequest
*/
func (a *DefaultAPIService) SetMessageReactionPost(ctx context.Context) ApiSetMessageReactionPostRequest {
	return ApiSetMessageReactionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetMessageReactionPostExecute(r ApiSetMessageReactionPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetMessageReactionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setMessageReaction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.messageId == nil {
		return localVarReturnValue, nil, reportError("messageId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	if r.reaction != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "reaction", r.reaction, "", "csv")
	}
	if r.isBig != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_big", r.isBig, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetMyCommandsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	commands *[]BotCommand
	scope *BotCommandScope
	languageCode *string
}

// A JSON-serialized list of bot commands to be set as the list of the bot&#39;s commands. At most 100 commands can be specified.
func (r ApiSetMyCommandsPostRequest) Commands(commands []BotCommand) ApiSetMyCommandsPostRequest {
	r.commands = &commands
	return r
}

func (r ApiSetMyCommandsPostRequest) Scope(scope BotCommandScope) ApiSetMyCommandsPostRequest {
	r.scope = &scope
	return r
}

// A two-letter ISO 639-1 language code. If empty, commands will be applied to all users from the given scope, for whose language there are no dedicated commands
func (r ApiSetMyCommandsPostRequest) LanguageCode(languageCode string) ApiSetMyCommandsPostRequest {
	r.languageCode = &languageCode
	return r
}

func (r ApiSetMyCommandsPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetMyCommandsPostExecute(r)
}

/*
SetMyCommandsPost Method for SetMyCommandsPost

Use this method to change the list of the bot's commands. See [this manual](https://core.telegram.org/bots/features#commands) for more details about bot commands. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetMyCommandsPostRequest
*/
func (a *DefaultAPIService) SetMyCommandsPost(ctx context.Context) ApiSetMyCommandsPostRequest {
	return ApiSetMyCommandsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetMyCommandsPostExecute(r ApiSetMyCommandsPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetMyCommandsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setMyCommands"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.commands == nil {
		return localVarReturnValue, nil, reportError("commands is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "commands", r.commands, "", "csv")
	if r.scope != nil {
		paramJson, err := parameterToJson(*r.scope)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("scope", paramJson)
	}
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "language_code", r.languageCode, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetMyDefaultAdministratorRightsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	rights *ChatAdministratorRights
	forChannels *bool
}

func (r ApiSetMyDefaultAdministratorRightsPostRequest) Rights(rights ChatAdministratorRights) ApiSetMyDefaultAdministratorRightsPostRequest {
	r.rights = &rights
	return r
}

// Pass *True* to change the default administrator rights of the bot in channels. Otherwise, the default administrator rights of the bot for groups and supergroups will be changed.
func (r ApiSetMyDefaultAdministratorRightsPostRequest) ForChannels(forChannels bool) ApiSetMyDefaultAdministratorRightsPostRequest {
	r.forChannels = &forChannels
	return r
}

func (r ApiSetMyDefaultAdministratorRightsPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetMyDefaultAdministratorRightsPostExecute(r)
}

/*
SetMyDefaultAdministratorRightsPost Method for SetMyDefaultAdministratorRightsPost

Use this method to change the default administrator rights requested by the bot when it's added as an administrator to groups or channels. These rights will be suggested to users, but they are free to modify the list before adding the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetMyDefaultAdministratorRightsPostRequest
*/
func (a *DefaultAPIService) SetMyDefaultAdministratorRightsPost(ctx context.Context) ApiSetMyDefaultAdministratorRightsPostRequest {
	return ApiSetMyDefaultAdministratorRightsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetMyDefaultAdministratorRightsPostExecute(r ApiSetMyDefaultAdministratorRightsPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetMyDefaultAdministratorRightsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setMyDefaultAdministratorRights"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.rights != nil {
		paramJson, err := parameterToJson(*r.rights)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("rights", paramJson)
	}
	if r.forChannels != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "for_channels", r.forChannels, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetMyDescriptionPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	description *string
	languageCode *string
}

// New bot description; 0-512 characters. Pass an empty string to remove the dedicated description for the given language.
func (r ApiSetMyDescriptionPostRequest) Description(description string) ApiSetMyDescriptionPostRequest {
	r.description = &description
	return r
}

// A two-letter ISO 639-1 language code. If empty, the description will be applied to all users for whose language there is no dedicated description.
func (r ApiSetMyDescriptionPostRequest) LanguageCode(languageCode string) ApiSetMyDescriptionPostRequest {
	r.languageCode = &languageCode
	return r
}

func (r ApiSetMyDescriptionPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetMyDescriptionPostExecute(r)
}

/*
SetMyDescriptionPost Method for SetMyDescriptionPost

Use this method to change the bot's description, which is shown in the chat with the bot if the chat is empty. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetMyDescriptionPostRequest
*/
func (a *DefaultAPIService) SetMyDescriptionPost(ctx context.Context) ApiSetMyDescriptionPostRequest {
	return ApiSetMyDescriptionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetMyDescriptionPostExecute(r ApiSetMyDescriptionPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetMyDescriptionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setMyDescription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "", "")
	}
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "language_code", r.languageCode, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetMyNamePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	name *string
	languageCode *string
}

// New bot name; 0-64 characters. Pass an empty string to remove the dedicated name for the given language.
func (r ApiSetMyNamePostRequest) Name(name string) ApiSetMyNamePostRequest {
	r.name = &name
	return r
}

// A two-letter ISO 639-1 language code. If empty, the name will be shown to all users for whose language there is no dedicated name.
func (r ApiSetMyNamePostRequest) LanguageCode(languageCode string) ApiSetMyNamePostRequest {
	r.languageCode = &languageCode
	return r
}

func (r ApiSetMyNamePostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetMyNamePostExecute(r)
}

/*
SetMyNamePost Method for SetMyNamePost

Use this method to change the bot's name. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetMyNamePostRequest
*/
func (a *DefaultAPIService) SetMyNamePost(ctx context.Context) ApiSetMyNamePostRequest {
	return ApiSetMyNamePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetMyNamePostExecute(r ApiSetMyNamePostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetMyNamePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setMyName"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	}
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "language_code", r.languageCode, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetMyShortDescriptionPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	shortDescription *string
	languageCode *string
}

// New short description for the bot; 0-120 characters. Pass an empty string to remove the dedicated short description for the given language.
func (r ApiSetMyShortDescriptionPostRequest) ShortDescription(shortDescription string) ApiSetMyShortDescriptionPostRequest {
	r.shortDescription = &shortDescription
	return r
}

// A two-letter ISO 639-1 language code. If empty, the short description will be applied to all users for whose language there is no dedicated short description.
func (r ApiSetMyShortDescriptionPostRequest) LanguageCode(languageCode string) ApiSetMyShortDescriptionPostRequest {
	r.languageCode = &languageCode
	return r
}

func (r ApiSetMyShortDescriptionPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetMyShortDescriptionPostExecute(r)
}

/*
SetMyShortDescriptionPost Method for SetMyShortDescriptionPost

Use this method to change the bot's short description, which is shown on the bot's profile page and is sent together with the link when users share the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetMyShortDescriptionPostRequest
*/
func (a *DefaultAPIService) SetMyShortDescriptionPost(ctx context.Context) ApiSetMyShortDescriptionPostRequest {
	return ApiSetMyShortDescriptionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetMyShortDescriptionPostExecute(r ApiSetMyShortDescriptionPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetMyShortDescriptionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setMyShortDescription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.shortDescription != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "short_description", r.shortDescription, "", "")
	}
	if r.languageCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "language_code", r.languageCode, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetPassportDataErrorsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	errors *[]PassportElementError
}

// User identifier
func (r ApiSetPassportDataErrorsPostRequest) UserId(userId int32) ApiSetPassportDataErrorsPostRequest {
	r.userId = &userId
	return r
}

// A JSON-serialized array describing the errors
func (r ApiSetPassportDataErrorsPostRequest) Errors(errors []PassportElementError) ApiSetPassportDataErrorsPostRequest {
	r.errors = &errors
	return r
}

func (r ApiSetPassportDataErrorsPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetPassportDataErrorsPostExecute(r)
}

/*
SetPassportDataErrorsPost Method for SetPassportDataErrorsPost

Informs a user that some of the Telegram Passport elements they provided contains errors. The user will not be able to re-submit their Passport to you until the errors are fixed (the contents of the field for which you returned the error must change). Returns *True* on success.

Use this if the data submitted by the user doesn't satisfy the standards your service requires for any reason. For example, if a birthday date seems invalid, a submitted document is blurry, a scan shows evidence of tampering, etc. Supply some details in the error message to make sure the user knows how to correct the issues.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetPassportDataErrorsPostRequest
*/
func (a *DefaultAPIService) SetPassportDataErrorsPost(ctx context.Context) ApiSetPassportDataErrorsPostRequest {
	return ApiSetPassportDataErrorsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetPassportDataErrorsPostExecute(r ApiSetPassportDataErrorsPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetPassportDataErrorsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setPassportDataErrors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.errors == nil {
		return localVarReturnValue, nil, reportError("errors is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "errors", r.errors, "", "csv")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetStickerEmojiListPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	sticker *string
	emojiList *[]string
}

// File identifier of the sticker
func (r ApiSetStickerEmojiListPostRequest) Sticker(sticker string) ApiSetStickerEmojiListPostRequest {
	r.sticker = &sticker
	return r
}

// A JSON-serialized list of 1-20 emoji associated with the sticker
func (r ApiSetStickerEmojiListPostRequest) EmojiList(emojiList []string) ApiSetStickerEmojiListPostRequest {
	r.emojiList = &emojiList
	return r
}

func (r ApiSetStickerEmojiListPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetStickerEmojiListPostExecute(r)
}

/*
SetStickerEmojiListPost Method for SetStickerEmojiListPost

Use this method to change the list of emoji assigned to a regular or custom emoji sticker. The sticker must belong to a sticker set created by the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetStickerEmojiListPostRequest
*/
func (a *DefaultAPIService) SetStickerEmojiListPost(ctx context.Context) ApiSetStickerEmojiListPostRequest {
	return ApiSetStickerEmojiListPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetStickerEmojiListPostExecute(r ApiSetStickerEmojiListPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetStickerEmojiListPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setStickerEmojiList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sticker == nil {
		return localVarReturnValue, nil, reportError("sticker is required and must be specified")
	}
	if r.emojiList == nil {
		return localVarReturnValue, nil, reportError("emojiList is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "sticker", r.sticker, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "emoji_list", r.emojiList, "", "csv")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetStickerKeywordsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	sticker *string
	keywords *[]string
}

// File identifier of the sticker
func (r ApiSetStickerKeywordsPostRequest) Sticker(sticker string) ApiSetStickerKeywordsPostRequest {
	r.sticker = &sticker
	return r
}

// A JSON-serialized list of 0-20 search keywords for the sticker with total length of up to 64 characters
func (r ApiSetStickerKeywordsPostRequest) Keywords(keywords []string) ApiSetStickerKeywordsPostRequest {
	r.keywords = &keywords
	return r
}

func (r ApiSetStickerKeywordsPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetStickerKeywordsPostExecute(r)
}

/*
SetStickerKeywordsPost Method for SetStickerKeywordsPost

Use this method to change search keywords assigned to a regular or custom emoji sticker. The sticker must belong to a sticker set created by the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetStickerKeywordsPostRequest
*/
func (a *DefaultAPIService) SetStickerKeywordsPost(ctx context.Context) ApiSetStickerKeywordsPostRequest {
	return ApiSetStickerKeywordsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetStickerKeywordsPostExecute(r ApiSetStickerKeywordsPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetStickerKeywordsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setStickerKeywords"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sticker == nil {
		return localVarReturnValue, nil, reportError("sticker is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "sticker", r.sticker, "", "")
	if r.keywords != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "keywords", r.keywords, "", "csv")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetStickerMaskPositionPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	sticker *string
	maskPosition *MaskPosition
}

// File identifier of the sticker
func (r ApiSetStickerMaskPositionPostRequest) Sticker(sticker string) ApiSetStickerMaskPositionPostRequest {
	r.sticker = &sticker
	return r
}

func (r ApiSetStickerMaskPositionPostRequest) MaskPosition(maskPosition MaskPosition) ApiSetStickerMaskPositionPostRequest {
	r.maskPosition = &maskPosition
	return r
}

func (r ApiSetStickerMaskPositionPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetStickerMaskPositionPostExecute(r)
}

/*
SetStickerMaskPositionPost Method for SetStickerMaskPositionPost

Use this method to change the [mask position](https://core.telegram.org/bots/api/#maskposition) of a mask sticker. The sticker must belong to a sticker set that was created by the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetStickerMaskPositionPostRequest
*/
func (a *DefaultAPIService) SetStickerMaskPositionPost(ctx context.Context) ApiSetStickerMaskPositionPostRequest {
	return ApiSetStickerMaskPositionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetStickerMaskPositionPostExecute(r ApiSetStickerMaskPositionPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetStickerMaskPositionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setStickerMaskPosition"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sticker == nil {
		return localVarReturnValue, nil, reportError("sticker is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "sticker", r.sticker, "", "")
	if r.maskPosition != nil {
		paramJson, err := parameterToJson(*r.maskPosition)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("mask_position", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetStickerPositionInSetPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	sticker *string
	position *int32
}

// File identifier of the sticker
func (r ApiSetStickerPositionInSetPostRequest) Sticker(sticker string) ApiSetStickerPositionInSetPostRequest {
	r.sticker = &sticker
	return r
}

// New sticker position in the set, zero-based
func (r ApiSetStickerPositionInSetPostRequest) Position(position int32) ApiSetStickerPositionInSetPostRequest {
	r.position = &position
	return r
}

func (r ApiSetStickerPositionInSetPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetStickerPositionInSetPostExecute(r)
}

/*
SetStickerPositionInSetPost Method for SetStickerPositionInSetPost

Use this method to move a sticker in a set created by the bot to a specific position. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetStickerPositionInSetPostRequest
*/
func (a *DefaultAPIService) SetStickerPositionInSetPost(ctx context.Context) ApiSetStickerPositionInSetPostRequest {
	return ApiSetStickerPositionInSetPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetStickerPositionInSetPostExecute(r ApiSetStickerPositionInSetPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetStickerPositionInSetPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setStickerPositionInSet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sticker == nil {
		return localVarReturnValue, nil, reportError("sticker is required and must be specified")
	}
	if r.position == nil {
		return localVarReturnValue, nil, reportError("position is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "sticker", r.sticker, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "position", r.position, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetStickerSetThumbnailPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	name *string
	userId *int32
	format *string
	thumbnail *SetStickerSetThumbnailPostRequestThumbnail
}

// Sticker set name
func (r ApiSetStickerSetThumbnailPostRequest) Name(name string) ApiSetStickerSetThumbnailPostRequest {
	r.name = &name
	return r
}

// User identifier of the sticker set owner
func (r ApiSetStickerSetThumbnailPostRequest) UserId(userId int32) ApiSetStickerSetThumbnailPostRequest {
	r.userId = &userId
	return r
}

// Format of the thumbnail, must be one of “static” for a **.WEBP** or **.PNG** image, “animated” for a **.TGS** animation, or “video” for a **.WEBM** video
func (r ApiSetStickerSetThumbnailPostRequest) Format(format string) ApiSetStickerSetThumbnailPostRequest {
	r.format = &format
	return r
}

func (r ApiSetStickerSetThumbnailPostRequest) Thumbnail(thumbnail SetStickerSetThumbnailPostRequestThumbnail) ApiSetStickerSetThumbnailPostRequest {
	r.thumbnail = &thumbnail
	return r
}

func (r ApiSetStickerSetThumbnailPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetStickerSetThumbnailPostExecute(r)
}

/*
SetStickerSetThumbnailPost Method for SetStickerSetThumbnailPost

Use this method to set the thumbnail of a regular or mask sticker set. The format of the thumbnail file must match the format of the stickers in the set. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetStickerSetThumbnailPostRequest
*/
func (a *DefaultAPIService) SetStickerSetThumbnailPost(ctx context.Context) ApiSetStickerSetThumbnailPostRequest {
	return ApiSetStickerSetThumbnailPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetStickerSetThumbnailPostExecute(r ApiSetStickerSetThumbnailPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetStickerSetThumbnailPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setStickerSetThumbnail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.format == nil {
		return localVarReturnValue, nil, reportError("format is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	if r.thumbnail != nil {
		paramJson, err := parameterToJson(*r.thumbnail)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("thumbnail", paramJson)
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "format", r.format, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetStickerSetTitlePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	name *string
	title *string
}

// Sticker set name
func (r ApiSetStickerSetTitlePostRequest) Name(name string) ApiSetStickerSetTitlePostRequest {
	r.name = &name
	return r
}

// Sticker set title, 1-64 characters
func (r ApiSetStickerSetTitlePostRequest) Title(title string) ApiSetStickerSetTitlePostRequest {
	r.title = &title
	return r
}

func (r ApiSetStickerSetTitlePostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetStickerSetTitlePostExecute(r)
}

/*
SetStickerSetTitlePost Method for SetStickerSetTitlePost

Use this method to set the title of a created sticker set. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetStickerSetTitlePostRequest
*/
func (a *DefaultAPIService) SetStickerSetTitlePost(ctx context.Context) ApiSetStickerSetTitlePostRequest {
	return ApiSetStickerSetTitlePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetStickerSetTitlePostExecute(r ApiSetStickerSetTitlePostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetStickerSetTitlePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setStickerSetTitle"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if strlen(*r.title) < 1 {
		return localVarReturnValue, nil, reportError("title must have at least 1 elements")
	}
	if strlen(*r.title) > 64 {
		return localVarReturnValue, nil, reportError("title must have less than 64 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetUserEmojiStatusPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	emojiStatusCustomEmojiId *string
	emojiStatusExpirationDate *int32
}

// Unique identifier of the target user
func (r ApiSetUserEmojiStatusPostRequest) UserId(userId int32) ApiSetUserEmojiStatusPostRequest {
	r.userId = &userId
	return r
}

// Custom emoji identifier of the emoji status to set. Pass an empty string to remove the status.
func (r ApiSetUserEmojiStatusPostRequest) EmojiStatusCustomEmojiId(emojiStatusCustomEmojiId string) ApiSetUserEmojiStatusPostRequest {
	r.emojiStatusCustomEmojiId = &emojiStatusCustomEmojiId
	return r
}

// Expiration date of the emoji status, if any
func (r ApiSetUserEmojiStatusPostRequest) EmojiStatusExpirationDate(emojiStatusExpirationDate int32) ApiSetUserEmojiStatusPostRequest {
	r.emojiStatusExpirationDate = &emojiStatusExpirationDate
	return r
}

func (r ApiSetUserEmojiStatusPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetUserEmojiStatusPostExecute(r)
}

/*
SetUserEmojiStatusPost Method for SetUserEmojiStatusPost

Changes the emoji status for a given user that previously allowed the bot to manage their emoji status via the Mini App method [requestEmojiStatusAccess](https://core.telegram.org/bots/webapps#initializing-mini-apps). Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetUserEmojiStatusPostRequest
*/
func (a *DefaultAPIService) SetUserEmojiStatusPost(ctx context.Context) ApiSetUserEmojiStatusPostRequest {
	return ApiSetUserEmojiStatusPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetUserEmojiStatusPostExecute(r ApiSetUserEmojiStatusPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetUserEmojiStatusPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setUserEmojiStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	if r.emojiStatusCustomEmojiId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "emoji_status_custom_emoji_id", r.emojiStatusCustomEmojiId, "", "")
	}
	if r.emojiStatusExpirationDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "emoji_status_expiration_date", r.emojiStatusExpirationDate, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetWebhookPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	url *string
	certificate *interface{}
	ipAddress *string
	maxConnections *int32
	allowedUpdates *[]string
	dropPendingUpdates *bool
	secretToken *string
}

// HTTPS URL to send updates to. Use an empty string to remove webhook integration
func (r ApiSetWebhookPostRequest) Url(url string) ApiSetWebhookPostRequest {
	r.url = &url
	return r
}

func (r ApiSetWebhookPostRequest) Certificate(certificate interface{}) ApiSetWebhookPostRequest {
	r.certificate = &certificate
	return r
}

// The fixed IP address which will be used to send webhook requests instead of the IP address resolved through DNS
func (r ApiSetWebhookPostRequest) IpAddress(ipAddress string) ApiSetWebhookPostRequest {
	r.ipAddress = &ipAddress
	return r
}

// The maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery, 1-100. Defaults to *40*. Use lower values to limit the load on your bot&#39;s server, and higher values to increase your bot&#39;s throughput.
func (r ApiSetWebhookPostRequest) MaxConnections(maxConnections int32) ApiSetWebhookPostRequest {
	r.maxConnections = &maxConnections
	return r
}

// A JSON-serialized list of the update types you want your bot to receive. For example, specify &#x60;[\\\&quot;message\\\&quot;, \\\&quot;edited_channel_post\\\&quot;, \\\&quot;callback_query\\\&quot;]&#x60; to only receive updates of these types. See [Update](https://core.telegram.org/bots/api/#update) for a complete list of available update types. Specify an empty list to receive all update types except *chat\\\\_member*, *message\\\\_reaction*, and *message\\\\_reaction\\\\_count* (default). If not specified, the previous setting will be used.   Please note that this parameter doesn&#39;t affect updates created before the call to the setWebhook, so unwanted updates may be received for a short period of time.
func (r ApiSetWebhookPostRequest) AllowedUpdates(allowedUpdates []string) ApiSetWebhookPostRequest {
	r.allowedUpdates = &allowedUpdates
	return r
}

// Pass *True* to drop all pending updates
func (r ApiSetWebhookPostRequest) DropPendingUpdates(dropPendingUpdates bool) ApiSetWebhookPostRequest {
	r.dropPendingUpdates = &dropPendingUpdates
	return r
}

// A secret token to be sent in a header “X-Telegram-Bot-Api-Secret-Token” in every webhook request, 1-256 characters. Only characters &#x60;A-Z&#x60;, &#x60;a-z&#x60;, &#x60;0-9&#x60;, &#x60;_&#x60; and &#x60;-&#x60; are allowed. The header is useful to ensure that the request comes from a webhook set by you.
func (r ApiSetWebhookPostRequest) SecretToken(secretToken string) ApiSetWebhookPostRequest {
	r.secretToken = &secretToken
	return r
}

func (r ApiSetWebhookPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.SetWebhookPostExecute(r)
}

/*
SetWebhookPost Method for SetWebhookPost

Use this method to specify a URL and receive incoming updates via an outgoing webhook. Whenever there is an update for the bot, we will send an HTTPS POST request to the specified URL, containing a JSON-serialized [Update](https://core.telegram.org/bots/api/#update). In case of an unsuccessful request (a request with response [HTTP status code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) different from `2XY`), we will repeat the request and give up after a reasonable amount of attempts. Returns *True* on success.

If you'd like to make sure that the webhook was set by you, you can specify secret data in the parameter *secret\_token*. If specified, the request will contain a header “X-Telegram-Bot-Api-Secret-Token” with the secret token as content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetWebhookPostRequest
*/
func (a *DefaultAPIService) SetWebhookPost(ctx context.Context) ApiSetWebhookPostRequest {
	return ApiSetWebhookPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) SetWebhookPostExecute(r ApiSetWebhookPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SetWebhookPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/setWebhook"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.url == nil {
		return localVarReturnValue, nil, reportError("url is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "url", r.url, "", "")
	if r.certificate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "certificate", r.certificate, "", "")
	}
	if r.ipAddress != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "ip_address", r.ipAddress, "", "")
	}
	if r.maxConnections != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "max_connections", r.maxConnections, "", "")
	}
	if r.allowedUpdates != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "allowed_updates", r.allowedUpdates, "", "csv")
	}
	if r.dropPendingUpdates != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "drop_pending_updates", r.dropPendingUpdates, "", "")
	}
	if r.secretToken != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "secret_token", r.secretToken, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStopMessageLiveLocationPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	chatId *EditMessageTextPostRequestChatId
	messageId *int32
	inlineMessageId *string
	replyMarkup *InlineKeyboardMarkup
}

// Unique identifier of the business connection on behalf of which the message to be edited was sent
func (r ApiStopMessageLiveLocationPostRequest) BusinessConnectionId(businessConnectionId string) ApiStopMessageLiveLocationPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

func (r ApiStopMessageLiveLocationPostRequest) ChatId(chatId EditMessageTextPostRequestChatId) ApiStopMessageLiveLocationPostRequest {
	r.chatId = &chatId
	return r
}

// Required if *inline\\\\_message\\\\_id* is not specified. Identifier of the message with live location to stop
func (r ApiStopMessageLiveLocationPostRequest) MessageId(messageId int32) ApiStopMessageLiveLocationPostRequest {
	r.messageId = &messageId
	return r
}

// Required if *chat\\\\_id* and *message\\\\_id* are not specified. Identifier of the inline message
func (r ApiStopMessageLiveLocationPostRequest) InlineMessageId(inlineMessageId string) ApiStopMessageLiveLocationPostRequest {
	r.inlineMessageId = &inlineMessageId
	return r
}

func (r ApiStopMessageLiveLocationPostRequest) ReplyMarkup(replyMarkup InlineKeyboardMarkup) ApiStopMessageLiveLocationPostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiStopMessageLiveLocationPostRequest) Execute() (*EditMessageTextPost200Response, *http.Response, error) {
	return r.ApiService.StopMessageLiveLocationPostExecute(r)
}

/*
StopMessageLiveLocationPost Method for StopMessageLiveLocationPost

Use this method to stop updating a live location message before *live\_period* expires. On success, if the message is not an inline message, the edited [Message](https://core.telegram.org/bots/api/#message) is returned, otherwise *True* is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiStopMessageLiveLocationPostRequest
*/
func (a *DefaultAPIService) StopMessageLiveLocationPost(ctx context.Context) ApiStopMessageLiveLocationPostRequest {
	return ApiStopMessageLiveLocationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EditMessageTextPost200Response
func (a *DefaultAPIService) StopMessageLiveLocationPostExecute(r ApiStopMessageLiveLocationPostRequest) (*EditMessageTextPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EditMessageTextPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.StopMessageLiveLocationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stopMessageLiveLocation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	if r.chatId != nil {
		paramJson, err := parameterToJson(*r.chatId)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("chat_id", paramJson)
	}
	if r.messageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	}
	if r.inlineMessageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "inline_message_id", r.inlineMessageId, "", "")
	}
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStopPollPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	messageId *int32
	businessConnectionId *string
	replyMarkup *InlineKeyboardMarkup
}

func (r ApiStopPollPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiStopPollPostRequest {
	r.chatId = &chatId
	return r
}

// Identifier of the original message with the poll
func (r ApiStopPollPostRequest) MessageId(messageId int32) ApiStopPollPostRequest {
	r.messageId = &messageId
	return r
}

// Unique identifier of the business connection on behalf of which the message to be edited was sent
func (r ApiStopPollPostRequest) BusinessConnectionId(businessConnectionId string) ApiStopPollPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

func (r ApiStopPollPostRequest) ReplyMarkup(replyMarkup InlineKeyboardMarkup) ApiStopPollPostRequest {
	r.replyMarkup = &replyMarkup
	return r
}

func (r ApiStopPollPostRequest) Execute() (*StopPollPost200Response, *http.Response, error) {
	return r.ApiService.StopPollPostExecute(r)
}

/*
StopPollPost Method for StopPollPost

Use this method to stop a poll which was sent by the bot. On success, the stopped [Poll](https://core.telegram.org/bots/api/#poll) is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiStopPollPostRequest
*/
func (a *DefaultAPIService) StopPollPost(ctx context.Context) ApiStopPollPostRequest {
	return ApiStopPollPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StopPollPost200Response
func (a *DefaultAPIService) StopPollPostExecute(r ApiStopPollPostRequest) (*StopPollPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StopPollPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.StopPollPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stopPoll"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.messageId == nil {
		return localVarReturnValue, nil, reportError("messageId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	if r.replyMarkup != nil {
		paramJson, err := parameterToJson(*r.replyMarkup)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("reply_markup", paramJson)
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransferBusinessAccountStarsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	starCount *int32
}

// Unique identifier of the business connection
func (r ApiTransferBusinessAccountStarsPostRequest) BusinessConnectionId(businessConnectionId string) ApiTransferBusinessAccountStarsPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Number of Telegram Stars to transfer; 1-10000
func (r ApiTransferBusinessAccountStarsPostRequest) StarCount(starCount int32) ApiTransferBusinessAccountStarsPostRequest {
	r.starCount = &starCount
	return r
}

func (r ApiTransferBusinessAccountStarsPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.TransferBusinessAccountStarsPostExecute(r)
}

/*
TransferBusinessAccountStarsPost Method for TransferBusinessAccountStarsPost

Transfers Telegram Stars from the business account balance to the bot's balance. Requires the *can\_transfer\_stars* business bot right. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTransferBusinessAccountStarsPostRequest
*/
func (a *DefaultAPIService) TransferBusinessAccountStarsPost(ctx context.Context) ApiTransferBusinessAccountStarsPostRequest {
	return ApiTransferBusinessAccountStarsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) TransferBusinessAccountStarsPostExecute(r ApiTransferBusinessAccountStarsPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.TransferBusinessAccountStarsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transferBusinessAccountStars"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.starCount == nil {
		return localVarReturnValue, nil, reportError("starCount is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "star_count", r.starCount, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransferGiftPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	ownedGiftId *string
	newOwnerChatId *int32
	starCount *int32
}

// Unique identifier of the business connection
func (r ApiTransferGiftPostRequest) BusinessConnectionId(businessConnectionId string) ApiTransferGiftPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier of the regular gift that should be transferred
func (r ApiTransferGiftPostRequest) OwnedGiftId(ownedGiftId string) ApiTransferGiftPostRequest {
	r.ownedGiftId = &ownedGiftId
	return r
}

// Unique identifier of the chat which will own the gift. The chat must be active in the last 24 hours.
func (r ApiTransferGiftPostRequest) NewOwnerChatId(newOwnerChatId int32) ApiTransferGiftPostRequest {
	r.newOwnerChatId = &newOwnerChatId
	return r
}

// The amount of Telegram Stars that will be paid for the transfer from the business account balance. If positive, then the *can\\\\_transfer\\\\_stars* business bot right is required.
func (r ApiTransferGiftPostRequest) StarCount(starCount int32) ApiTransferGiftPostRequest {
	r.starCount = &starCount
	return r
}

func (r ApiTransferGiftPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.TransferGiftPostExecute(r)
}

/*
TransferGiftPost Method for TransferGiftPost

Transfers an owned unique gift to another user. Requires the *can\_transfer\_and\_upgrade\_gifts* business bot right. Requires *can\_transfer\_stars* business bot right if the transfer is paid. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTransferGiftPostRequest
*/
func (a *DefaultAPIService) TransferGiftPost(ctx context.Context) ApiTransferGiftPostRequest {
	return ApiTransferGiftPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) TransferGiftPostExecute(r ApiTransferGiftPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.TransferGiftPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transferGift"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.ownedGiftId == nil {
		return localVarReturnValue, nil, reportError("ownedGiftId is required and must be specified")
	}
	if r.newOwnerChatId == nil {
		return localVarReturnValue, nil, reportError("newOwnerChatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "owned_gift_id", r.ownedGiftId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "new_owner_chat_id", r.newOwnerChatId, "", "")
	if r.starCount != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "star_count", r.starCount, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnbanChatMemberPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *BanChatMemberPostRequestChatId
	userId *int32
	onlyIfBanned *bool
}

func (r ApiUnbanChatMemberPostRequest) ChatId(chatId BanChatMemberPostRequestChatId) ApiUnbanChatMemberPostRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the target user
func (r ApiUnbanChatMemberPostRequest) UserId(userId int32) ApiUnbanChatMemberPostRequest {
	r.userId = &userId
	return r
}

// Do nothing if the user is not banned
func (r ApiUnbanChatMemberPostRequest) OnlyIfBanned(onlyIfBanned bool) ApiUnbanChatMemberPostRequest {
	r.onlyIfBanned = &onlyIfBanned
	return r
}

func (r ApiUnbanChatMemberPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.UnbanChatMemberPostExecute(r)
}

/*
UnbanChatMemberPost Method for UnbanChatMemberPost

Use this method to unban a previously banned user in a supergroup or channel. The user will **not** return to the group or channel automatically, but will be able to join via link, etc. The bot must be an administrator for this to work. By default, this method guarantees that after the call the user is not a member of the chat, but will be able to join it. So if the user is a member of the chat they will also be **removed** from the chat. If you don't want this, use the parameter *only\_if\_banned*. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnbanChatMemberPostRequest
*/
func (a *DefaultAPIService) UnbanChatMemberPost(ctx context.Context) ApiUnbanChatMemberPostRequest {
	return ApiUnbanChatMemberPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) UnbanChatMemberPostExecute(r ApiUnbanChatMemberPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UnbanChatMemberPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unbanChatMember"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	if r.onlyIfBanned != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "only_if_banned", r.onlyIfBanned, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnbanChatSenderChatPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	senderChatId *int32
}

func (r ApiUnbanChatSenderChatPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiUnbanChatSenderChatPostRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the target sender chat
func (r ApiUnbanChatSenderChatPostRequest) SenderChatId(senderChatId int32) ApiUnbanChatSenderChatPostRequest {
	r.senderChatId = &senderChatId
	return r
}

func (r ApiUnbanChatSenderChatPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.UnbanChatSenderChatPostExecute(r)
}

/*
UnbanChatSenderChatPost Method for UnbanChatSenderChatPost

Use this method to unban a previously banned channel chat in a supergroup or channel. The bot must be an administrator for this to work and must have the appropriate administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnbanChatSenderChatPostRequest
*/
func (a *DefaultAPIService) UnbanChatSenderChatPost(ctx context.Context) ApiUnbanChatSenderChatPostRequest {
	return ApiUnbanChatSenderChatPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) UnbanChatSenderChatPostExecute(r ApiUnbanChatSenderChatPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UnbanChatSenderChatPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unbanChatSenderChat"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.senderChatId == nil {
		return localVarReturnValue, nil, reportError("senderChatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "sender_chat_id", r.senderChatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnhideGeneralForumTopicPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *RestrictChatMemberPostRequestChatId
}

func (r ApiUnhideGeneralForumTopicPostRequest) ChatId(chatId RestrictChatMemberPostRequestChatId) ApiUnhideGeneralForumTopicPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiUnhideGeneralForumTopicPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.UnhideGeneralForumTopicPostExecute(r)
}

/*
UnhideGeneralForumTopicPost Method for UnhideGeneralForumTopicPost

Use this method to unhide the 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the *can\_manage\_topics* administrator rights. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnhideGeneralForumTopicPostRequest
*/
func (a *DefaultAPIService) UnhideGeneralForumTopicPost(ctx context.Context) ApiUnhideGeneralForumTopicPostRequest {
	return ApiUnhideGeneralForumTopicPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) UnhideGeneralForumTopicPostExecute(r ApiUnhideGeneralForumTopicPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UnhideGeneralForumTopicPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unhideGeneralForumTopic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnpinAllChatMessagesPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
}

func (r ApiUnpinAllChatMessagesPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiUnpinAllChatMessagesPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiUnpinAllChatMessagesPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.UnpinAllChatMessagesPostExecute(r)
}

/*
UnpinAllChatMessagesPost Method for UnpinAllChatMessagesPost

Use this method to clear the list of pinned messages in a chat. If the chat is not a private chat, the bot must be an administrator in the chat for this to work and must have the 'can\_pin\_messages' administrator right in a supergroup or 'can\_edit\_messages' administrator right in a channel. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnpinAllChatMessagesPostRequest
*/
func (a *DefaultAPIService) UnpinAllChatMessagesPost(ctx context.Context) ApiUnpinAllChatMessagesPostRequest {
	return ApiUnpinAllChatMessagesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) UnpinAllChatMessagesPostExecute(r ApiUnpinAllChatMessagesPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UnpinAllChatMessagesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unpinAllChatMessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnpinAllForumTopicMessagesPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *RestrictChatMemberPostRequestChatId
	messageThreadId *int32
}

func (r ApiUnpinAllForumTopicMessagesPostRequest) ChatId(chatId RestrictChatMemberPostRequestChatId) ApiUnpinAllForumTopicMessagesPostRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier for the target message thread of the forum topic
func (r ApiUnpinAllForumTopicMessagesPostRequest) MessageThreadId(messageThreadId int32) ApiUnpinAllForumTopicMessagesPostRequest {
	r.messageThreadId = &messageThreadId
	return r
}

func (r ApiUnpinAllForumTopicMessagesPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.UnpinAllForumTopicMessagesPostExecute(r)
}

/*
UnpinAllForumTopicMessagesPost Method for UnpinAllForumTopicMessagesPost

Use this method to clear the list of pinned messages in a forum topic. The bot must be an administrator in the chat for this to work and must have the *can\_pin\_messages* administrator right in the supergroup. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnpinAllForumTopicMessagesPostRequest
*/
func (a *DefaultAPIService) UnpinAllForumTopicMessagesPost(ctx context.Context) ApiUnpinAllForumTopicMessagesPostRequest {
	return ApiUnpinAllForumTopicMessagesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) UnpinAllForumTopicMessagesPostExecute(r ApiUnpinAllForumTopicMessagesPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UnpinAllForumTopicMessagesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unpinAllForumTopicMessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.messageThreadId == nil {
		return localVarReturnValue, nil, reportError("messageThreadId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "message_thread_id", r.messageThreadId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnpinAllGeneralForumTopicMessagesPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *RestrictChatMemberPostRequestChatId
}

func (r ApiUnpinAllGeneralForumTopicMessagesPostRequest) ChatId(chatId RestrictChatMemberPostRequestChatId) ApiUnpinAllGeneralForumTopicMessagesPostRequest {
	r.chatId = &chatId
	return r
}

func (r ApiUnpinAllGeneralForumTopicMessagesPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.UnpinAllGeneralForumTopicMessagesPostExecute(r)
}

/*
UnpinAllGeneralForumTopicMessagesPost Method for UnpinAllGeneralForumTopicMessagesPost

Use this method to clear the list of pinned messages in a General forum topic. The bot must be an administrator in the chat for this to work and must have the *can\_pin\_messages* administrator right in the supergroup. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnpinAllGeneralForumTopicMessagesPostRequest
*/
func (a *DefaultAPIService) UnpinAllGeneralForumTopicMessagesPost(ctx context.Context) ApiUnpinAllGeneralForumTopicMessagesPostRequest {
	return ApiUnpinAllGeneralForumTopicMessagesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) UnpinAllGeneralForumTopicMessagesPostExecute(r ApiUnpinAllGeneralForumTopicMessagesPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UnpinAllGeneralForumTopicMessagesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unpinAllGeneralForumTopicMessages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnpinChatMessagePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	businessConnectionId *string
	messageId *int32
}

func (r ApiUnpinChatMessagePostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiUnpinChatMessagePostRequest {
	r.chatId = &chatId
	return r
}

// Unique identifier of the business connection on behalf of which the message will be unpinned
func (r ApiUnpinChatMessagePostRequest) BusinessConnectionId(businessConnectionId string) ApiUnpinChatMessagePostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Identifier of the message to unpin. Required if *business\\\\_connection\\\\_id* is specified. If not specified, the most recent pinned message (by sending date) will be unpinned.
func (r ApiUnpinChatMessagePostRequest) MessageId(messageId int32) ApiUnpinChatMessagePostRequest {
	r.messageId = &messageId
	return r
}

func (r ApiUnpinChatMessagePostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.UnpinChatMessagePostExecute(r)
}

/*
UnpinChatMessagePost Method for UnpinChatMessagePost

Use this method to remove a message from the list of pinned messages in a chat. If the chat is not a private chat, the bot must be an administrator in the chat for this to work and must have the 'can\_pin\_messages' administrator right in a supergroup or 'can\_edit\_messages' administrator right in a channel. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnpinChatMessagePostRequest
*/
func (a *DefaultAPIService) UnpinChatMessagePost(ctx context.Context) ApiUnpinChatMessagePostRequest {
	return ApiUnpinChatMessagePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) UnpinChatMessagePostExecute(r ApiUnpinChatMessagePostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UnpinChatMessagePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unpinChatMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.businessConnectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.messageId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message_id", r.messageId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpgradeGiftPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	businessConnectionId *string
	ownedGiftId *string
	keepOriginalDetails *bool
	starCount *int32
}

// Unique identifier of the business connection
func (r ApiUpgradeGiftPostRequest) BusinessConnectionId(businessConnectionId string) ApiUpgradeGiftPostRequest {
	r.businessConnectionId = &businessConnectionId
	return r
}

// Unique identifier of the regular gift that should be upgraded to a unique one
func (r ApiUpgradeGiftPostRequest) OwnedGiftId(ownedGiftId string) ApiUpgradeGiftPostRequest {
	r.ownedGiftId = &ownedGiftId
	return r
}

// Pass True to keep the original gift text, sender and receiver in the upgraded gift
func (r ApiUpgradeGiftPostRequest) KeepOriginalDetails(keepOriginalDetails bool) ApiUpgradeGiftPostRequest {
	r.keepOriginalDetails = &keepOriginalDetails
	return r
}

// The amount of Telegram Stars that will be paid for the upgrade from the business account balance. If &#x60;gift.prepaid_upgrade_star_count &gt; 0&#x60;, then pass 0, otherwise, the *can\\\\_transfer\\\\_stars* business bot right is required and &#x60;gift.upgrade_star_count&#x60; must be passed.
func (r ApiUpgradeGiftPostRequest) StarCount(starCount int32) ApiUpgradeGiftPostRequest {
	r.starCount = &starCount
	return r
}

func (r ApiUpgradeGiftPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.UpgradeGiftPostExecute(r)
}

/*
UpgradeGiftPost Method for UpgradeGiftPost

Upgrades a given regular gift to a unique gift. Requires the *can\_transfer\_and\_upgrade\_gifts* business bot right. Additionally requires the *can\_transfer\_stars* business bot right if the upgrade is paid. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpgradeGiftPostRequest
*/
func (a *DefaultAPIService) UpgradeGiftPost(ctx context.Context) ApiUpgradeGiftPostRequest {
	return ApiUpgradeGiftPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) UpgradeGiftPostExecute(r ApiUpgradeGiftPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UpgradeGiftPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/upgradeGift"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.businessConnectionId == nil {
		return localVarReturnValue, nil, reportError("businessConnectionId is required and must be specified")
	}
	if r.ownedGiftId == nil {
		return localVarReturnValue, nil, reportError("ownedGiftId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "business_connection_id", r.businessConnectionId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "owned_gift_id", r.ownedGiftId, "", "")
	if r.keepOriginalDetails != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "keep_original_details", r.keepOriginalDetails, "", "")
	}
	if r.starCount != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "star_count", r.starCount, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadStickerFilePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	sticker *interface{}
	stickerFormat *string
}

// User identifier of sticker file owner
func (r ApiUploadStickerFilePostRequest) UserId(userId int32) ApiUploadStickerFilePostRequest {
	r.userId = &userId
	return r
}

func (r ApiUploadStickerFilePostRequest) Sticker(sticker interface{}) ApiUploadStickerFilePostRequest {
	r.sticker = &sticker
	return r
}

// Format of the sticker, must be one of “static”, “animated”, “video”
func (r ApiUploadStickerFilePostRequest) StickerFormat(stickerFormat string) ApiUploadStickerFilePostRequest {
	r.stickerFormat = &stickerFormat
	return r
}

func (r ApiUploadStickerFilePostRequest) Execute() (*GetFilePost200Response, *http.Response, error) {
	return r.ApiService.UploadStickerFilePostExecute(r)
}

/*
UploadStickerFilePost Method for UploadStickerFilePost

Use this method to upload a file with a sticker for later use in the [createNewStickerSet](https://core.telegram.org/bots/api/#createnewstickerset), [addStickerToSet](https://core.telegram.org/bots/api/#addstickertoset), or [replaceStickerInSet](https://core.telegram.org/bots/api/#replacestickerinset) methods (the file can be used multiple times). Returns the uploaded [File](https://core.telegram.org/bots/api/#file) on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUploadStickerFilePostRequest
*/
func (a *DefaultAPIService) UploadStickerFilePost(ctx context.Context) ApiUploadStickerFilePostRequest {
	return ApiUploadStickerFilePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetFilePost200Response
func (a *DefaultAPIService) UploadStickerFilePostExecute(r ApiUploadStickerFilePostRequest) (*GetFilePost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetFilePost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UploadStickerFilePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/uploadStickerFile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.sticker == nil {
		return localVarReturnValue, nil, reportError("sticker is required and must be specified")
	}
	if r.stickerFormat == nil {
		return localVarReturnValue, nil, reportError("stickerFormat is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "sticker", r.sticker, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "sticker_format", r.stickerFormat, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyChatPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	chatId *SendMessagePostRequestChatId
	customDescription *string
}

func (r ApiVerifyChatPostRequest) ChatId(chatId SendMessagePostRequestChatId) ApiVerifyChatPostRequest {
	r.chatId = &chatId
	return r
}

// Custom description for the verification; 0-70 characters. Must be empty if the organization isn&#39;t allowed to provide a custom verification description.
func (r ApiVerifyChatPostRequest) CustomDescription(customDescription string) ApiVerifyChatPostRequest {
	r.customDescription = &customDescription
	return r
}

func (r ApiVerifyChatPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.VerifyChatPostExecute(r)
}

/*
VerifyChatPost Method for VerifyChatPost

Verifies a chat [on behalf of the organization](https://telegram.org/verify#third-party-verification) which is represented by the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVerifyChatPostRequest
*/
func (a *DefaultAPIService) VerifyChatPost(ctx context.Context) ApiVerifyChatPostRequest {
	return ApiVerifyChatPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) VerifyChatPostExecute(r ApiVerifyChatPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VerifyChatPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verifyChat"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "chat_id", r.chatId, "", "")
	if r.customDescription != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "custom_description", r.customDescription, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyUserPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	userId *int32
	customDescription *string
}

// Unique identifier of the target user
func (r ApiVerifyUserPostRequest) UserId(userId int32) ApiVerifyUserPostRequest {
	r.userId = &userId
	return r
}

// Custom description for the verification; 0-70 characters. Must be empty if the organization isn&#39;t allowed to provide a custom verification description.
func (r ApiVerifyUserPostRequest) CustomDescription(customDescription string) ApiVerifyUserPostRequest {
	r.customDescription = &customDescription
	return r
}

func (r ApiVerifyUserPostRequest) Execute() (*SetWebhookPost200Response, *http.Response, error) {
	return r.ApiService.VerifyUserPostExecute(r)
}

/*
VerifyUserPost Method for VerifyUserPost

Verifies a user [on behalf of the organization](https://telegram.org/verify#third-party-verification) which is represented by the bot. Returns *True* on success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVerifyUserPostRequest
*/
func (a *DefaultAPIService) VerifyUserPost(ctx context.Context) ApiVerifyUserPostRequest {
	return ApiVerifyUserPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetWebhookPost200Response
func (a *DefaultAPIService) VerifyUserPostExecute(r ApiVerifyUserPostRequest) (*SetWebhookPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SetWebhookPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VerifyUserPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/verifyUser"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	if r.customDescription != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "custom_description", r.customDescription, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
